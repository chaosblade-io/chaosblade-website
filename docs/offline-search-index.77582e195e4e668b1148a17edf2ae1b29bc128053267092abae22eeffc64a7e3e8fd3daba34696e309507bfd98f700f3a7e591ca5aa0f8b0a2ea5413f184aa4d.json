[{"body":"参数\nContainer 资源均支持以下参数。\n   参数 类型 说明 默认值     container-ids string 容器ID，支持配置多个    container-names string 容器名称，支持配置多个    docker-endpoint string Docker server 地址 默认为本地的 /var/run/docker.sock   namespace string Pod 所属的命名空间 default   evict-count string 限制实验生效的数量    evict-percent string 限制实验生效数量的百分比，不包含 %    labels string Pod 资源标签，多个标签之间是或的关系    names string Pod 资源名    waiting-time string 实验结果等待时间，参数值要包含单位，例如 10s，1m 20s   force  是否强制删除     ","excerpt":"参数\nContainer 资源均支持以下参数。\n   参数 类型 说明 默认值     container-ids string 容器ID，支持配置多个    container-names …","ref":"/docs/operator/container/","title":"Container 场景"},{"body":"","excerpt":"","ref":"/docs/operator/container/container-resource/","title":"Container 资源自身的场景"},{"body":"介绍 CPU 相关的混沌实验包含 CPU 满载，可以指定核数、具体核满载或者总 CPU 负载百分比。\n旨在 CPU 在特定负载下，验证服务质量、监控告警、流量调度、弹性伸缩等能力。\nload、fullload、fl 命令都可以，即 blade create cpu load、blade create cpu fullload 或 blade create cpu fl\n执行命令：\nblade create cpu load [flags] 参数 --timeout string 设定运行时长，单位是秒，通用参数 --cpu-count string 指定 CPU 满载的个数 --cpu-list string 指定 CPU 满载的具体核，核索引从 0 开始 (0-3 or 1,3) --cpu-percent string 指定 CPU 负载百分比，取值在 0-100 案例 # 创建 CPU 满载实验 blade create cpu load # 返回结果如下 {\u0026#34;code\u0026#34;:200,\u0026#34;success\u0026#34;:true,\u0026#34;result\u0026#34;:\u0026#34;beeaaf3a7007031d\u0026#34;} # code 的值等于 200 说明执行成功，其中 result 的值就是 uid。使用 top 命令验证实验效果 Tasks: 100 total, 2 running, 98 sleeping, 0 stopped, 0 zombie %Cpu0 : 21.3 us, 78.7 sy, 0.0 ni, 0.0 id, 0.0 wa, 0.0 hi, 0.0 si, 0.0 st %Cpu1 : 20.9 us, 79.1 sy, 0.0 ni, 0.0 id, 0.0 wa, 0.0 hi, 0.0 si, 0.0 st %Cpu2 : 20.5 us, 79.5 sy, 0.0 ni, 0.0 id, 0.0 wa, 0.0 hi, 0.0 si, 0.0 st %Cpu3 : 20.9 us, 79.1 sy, 0.0 ni, 0.0 id, 0.0 wa, 0.0 hi, 0.0 si, 0.0 st # 4 核都满载，实验生效，销毁实验 blade destroy beeaaf3a7007031d # 返回结果如下 {\u0026#34;code\u0026#34;:200,\u0026#34;success\u0026#34;:true,\u0026#34;result\u0026#34;:\u0026#34;command: cpu load --help false --debug false\u0026#34;} # 指定随机两个核满载 blade create cpu load --cpu-count 2 # 使用 top 命令验证结果如下，实验生效 Tasks: 100 total, 2 running, 98 sleeping, 0 stopped, 0 zombie %Cpu0 : 17.9 us, 75.1 sy, 0.0 ni, 7.0 id, 0.0 wa, 0.0 hi, 0.0 si, 0.0 st %Cpu1 : 3.0 us, 6.7 sy, 0.0 ni, 90.3 id, 0.0 wa, 0.0 hi, 0.0 si, 0.0 st %Cpu2 : 0.7 us, 0.7 sy, 0.0 ni, 98.7 id, 0.0 wa, 0.0 hi, 0.0 si, 0.0 st %Cpu3 : 19.7 us, 80.3 sy, 0.0 ni, 0.0 id, 0.0 wa, 0.0 hi, 0.0 si, 0.0 st # 指定索引是 0，3 的核满载，核的索引从 0 开始 blade create cpu load --cpu-list 0,3 # 使用 top 命令验证结果如下，实验生效 Tasks: 101 total, 2 running, 99 sleeping, 0 stopped, 0 zombie %Cpu0 : 23.5 us, 76.5 sy, 0.0 ni, 0.0 id, 0.0 wa, 0.0 hi, 0.0 si, 0.0 st %Cpu1 : 0.0 us, 0.0 sy, 0.0 ni,100.0 id, 0.0 wa, 0.0 hi, 0.0 si, 0.0 st %Cpu2 : 0.0 us, 0.0 sy, 0.0 ni,100.0 id, 0.0 wa, 0.0 hi, 0.0 si, 0.0 st %Cpu3 : 20.9 us, 79.1 sy, 0.0 ni, 0.0 id, 0.0 wa, 0.0 hi, 0.0 si, 0.0 st # 指定索引 1 到 3 的核满载 blade create cpu load --cpu-list 1-3 Tasks: 102 total, 4 running, 98 sleeping, 0 stopped, 0 zombie %Cpu0 : 2.4 us, 7.1 sy, 0.0 ni, 90.2 id, 0.0 wa, 0.0 hi, 0.3 si, 0.0 st %Cpu1 : 20.0 us, 80.0 sy, 0.0 ni, 0.0 id, 0.0 wa, 0.0 hi, 0.0 si, 0.0 st %Cpu2 : 15.7 us, 78.7 sy, 0.0 ni, 5.7 id, 0.0 wa, 0.0 hi, 0.0 si, 0.0 st %Cpu3 : 19.1 us, 78.9 sy, 0.0 ni, 2.0 id, 0.0 wa, 0.0 hi, 0.0 si, 0.0 st # 指定百分比负载 blade create cpu load --cpu-percent 60 # 可以看到 CPU 总的使用率达到 60%， 空闲 40% Tasks: 100 total, 1 running, 99 sleeping, 0 stopped, 0 zombie %Cpu(s): 15.8 us, 44.1 sy, 0.0 ni, 40.0 id, 0.0 wa, 0.0 hi, 0.1 si, 0.0 st 实现原理 利用消耗CPU时间片来做。详见代码：burncpu\n常见问题 ","excerpt":"介绍 CPU 相关的混沌实验包含 CPU 满载，可以指定核数、具体核满载或者总 CPU 负载百分比。\n旨在 CPU 在特定负载下，验证服务质量、监控告警、流量调度、弹性伸缩等能力。 …","ref":"/docs/binaries/create/resource/cpu-load/","title":"CPU 负载实验"},{"body":"命令 支持 CPU 场景命令如下：\n blade create k8s container-cpu load，容器内 CPU 负载场景，同 blade create cpu load  参数 除了上述基础场景各自所需的参数外，在 kubernetes 环境下，还支持的参数如下：\n--container-ids string 容器ID，支持配置多个 --container-names string 容器名称，支持配置多个 --docker-endpoint string Docker server 地址，默认为本地的 /var/run/docker.sock --namespace string Pod 所属的命名空间，只能填写一个值，必填项 --evict-count string 限制实验生效的数量 --evict-percent string 限制实验生效数量的百分比，不包含 % --labels string Pod 资源标签，多个标签之前是或的关系 --names string Pod 资源名 --kubeconfig string kubeconfig 文件全路径（仅限使用 blade 命令调用时使用） --waiting-time string 实验结果等待时间，默认为 20s，参数值要包含单位，例如 10s，1m 案例 指定 default 命名空间下 Pod 名为 frontend-d89756ff7-pbnnc，容器 id 为 2ff814b246f86，做 CPU 负载 100% 实验举例。\nblade 命令执行方式 blade create k8s container-cpu fullload --cpu-percent 100 --container-ids 2ff814b246f86 --names frontend-d89756ff7-pbnnc --namespace default --kubeconfig config 如果执行失败，会返回详细的错误信息；如果执行成功，会返回实验的 UID：\n{\u0026#34;code\u0026#34;:200,\u0026#34;success\u0026#34;:true,\u0026#34;result\u0026#34;:\u0026#34;092e8b4d88d4f449\u0026#34;} 可通过以下命令查询实验状态：\nblade query k8s create 092e8b4d88d4f449 --kubeconfig config {\u0026#34;code\u0026#34;:200,\u0026#34;success\u0026#34;:true,\u0026#34;result\u0026#34;:{\u0026#34;uid\u0026#34;:\u0026#34;092e8b4d88d4f449\u0026#34;,\u0026#34;success\u0026#34;:true,\u0026#34;error\u0026#34;:\u0026#34;\u0026#34;,\u0026#34;statuses\u0026#34;:[{\u0026#34;id\u0026#34;:\u0026#34;eab5fb70b61c9c45\u0026#34;,\u0026#34;uid\u0026#34;:\u0026#34;2ff814b246f86aba2392379640e4c6b16efbfd61846fc419a24f8d8ccf0f86f0\u0026#34;,\u0026#34;name\u0026#34;:\u0026#34;php-redis\u0026#34;,\u0026#34;state\u0026#34;:\u0026#34;Success\u0026#34;,\u0026#34;kind\u0026#34;:\u0026#34;container\u0026#34;,\u0026#34;success\u0026#34;:true,\u0026#34;nodeName\u0026#34;:\u0026#34;cn-hangzhou.192.168.0.204\u0026#34;}]}} 通过资源监控，可以看到此 Pod 下 CPU 使用情况 销毁实验 blade destroy 092e8b4d88d4f449 kubectl 执行方式 yaml 的配置方式见：Container 内 CPU 负载场景\n","excerpt":"命令 支持 CPU 场景命令如下：\n blade create k8s container-cpu load，容器内 CPU 负载场景，同 blade create cpu load  参数 除了上述 …","ref":"/docs/binaries/create/k8s/container/container-cpu/","title":"容器内 CPU 负载实验场景"},{"body":"命令 支持 CPU 场景命令如下：\n blade create k8s node-cpu load，节点 CPU 负载场景，同 blade create cpu load  参数 除了上述基础场景各自所需的参数外，在 kubernetes 环境下，还支持的参数如下：\n--evict-count string 限制实验生效的数量 --evict-percent string 限制实验生效数量的百分比，不包含 % --labels string 节点资源标签 --names string 节点资源名，多个资源名之间使用逗号分隔 --kubeconfig string kubeconfig 文件全路径（仅限使用 blade 命令调用时使用） --waiting-time string 实验结果等待时间，默认为 20s，参数值要包含单位，例如 10s，1m 案例 面以指定一台节点，做 CPU 负载 80% 实验举例。\nblade 命令执行方式 下载 chaosblade 工具包，下载地址：https://github.com/chaosblade-io/chaosblade/releases/tag/v0.4.0-alpha ，解压即可使用。还是上述例子，使用 blade 命令执行如下：\nblade create k8s node-cpu fullload --names cn-hangzhou.192.168.0.205 --cpu-percent 80 --kubeconfig ~/.kube/config 使用 blade 命令执行，如果执行失败，会返回详细的错误信息；如果执行成功，会返回实验的 UID，使用查询命令可以查询详细的实验结果：\nblade query k8s create \u0026lt;UID\u0026gt; 销毁实验 此方式仅限使用 blade 创建的实验，使用以下命令停止：\nblade destroy \u0026lt;UID\u0026gt; \u0026lt;UID\u0026gt; 是执行 blade create 命令返回的结果，如果忘记，可使用 blade status --type create 命令查询。\nkubectl 执行方式 yaml 的配置方式见：Node CPU 负载场景\n","excerpt":"命令 支持 CPU 场景命令如下：\n blade create k8s node-cpu load，节点 CPU 负载场景，同 blade create cpu load  参数 除了上述基础场景各自 …","ref":"/docs/binaries/create/k8s/node/node-cpu/","title":"节点 CPU 负载实验场景"},{"body":"介绍 创建混沌实验命令，每个实验对应一个 uid，后续的查询、销毁实验都要用到此 uid，如果遗忘了 uid，可以通过 blade status --type create 命令进行查询。 create 可以简写为 c，即 blade create 可以简写为 blade c。\n参数 -h, --help 查看 create 命令帮助 可使用的父命令参数 -d, --debug 设置 DEBUG 执行模式 案例 # 查看 create 命令帮助文档 blade create -h # 查看如何创建 cpu 混沌实验 blade create cpu -h # 查看如何创建 cpu 满载实验 blade create cpu fullload -h # 创建 cpu 满载实验 blade create cpu fullload --cpu-count 1 # 返回结果如下 {\u0026#34;code\u0026#34;:200,\u0026#34;success\u0026#34;:true,\u0026#34;result\u0026#34;:\u0026#34;6fa04946baf42920\u0026#34;} # code 的值等于 200 说明执行成功，其中 result 的值就是 uid。使用 top 命令验证实验效果 %Cpu0 :100.0 us, 0.0 sy, 0.0 ni, 0.0 id, 0.0 wa, 0.0 hi, 0.0 si, 0.0 st # 销毁上述实验 blade destroy 6fa04946baf42920 # 返回结果如下 {\u0026#34;code\u0026#34;:200,\u0026#34;success\u0026#34;:true,\u0026#34;result\u0026#34;:\u0026#34;command: cpu fullload --cpu-count 2 --debug false --help false\u0026#34;} # 返回值会打印此次实验的命令。再次使用 top 命令验证实验效果 %Cpu0 : 0.3 us, 0.3 sy, 0.0 ni, 99.3 id, 0.0 wa, 0.0 hi, 0.0 si, 0.0 st ","excerpt":"介绍 创建混沌实验命令，每个实验对应一个 uid，后续的查询、销毁实验都要用到此 uid，如果遗忘了 uid，可以通过 blade status --type create 命令进行查询。 …","ref":"/docs/binaries/create/","title":"create 命令"},{"body":"参数 以下是此场景特有参数，通用参数详见：blade create http\n--time string 延迟时间，单位是毫秒，必填项 --offset string 延迟时间上下偏移量，比如 --time 3000 --offset 1000，则延迟时间范围是 2000-4000 毫秒 案例 http-client 进程的 /httpdemo/hello 接口：内部通过 restTemplate 组件访问 http://127.0.0.1:8801/getName 接口获取返回值，代码如下：\n@RequestMapping(\u0026#34;/httpdemo/hello\u0026#34;) @ResponseBody public String hello(long timeout) { if (timeout == 0) { timeout = 3000; } try { FutureTask futureTask = new FutureTask(new Callable() { @Override public Object call() throws Exception { RestTemplate restTemplate = new RestTemplate(); String name = restTemplate.getForObject(\u0026#34;http://127.0.0.1:8801/getName?name=friend\u0026#34;, String.class); return \u0026#34;hello \u0026#34; + name + \u0026#34;\\n\u0026#34;; } }); new Thread(futureTask).start(); return (String) futureTask.get(timeout, TimeUnit.MILLISECONDS); } catch (TimeoutException e) { return \u0026#34;timeout, \u0026#34; + e.getMessage() + \u0026#34;\\n\u0026#34;; } catch (Exception e) { return \u0026#34;exception, \u0026#34; + e.getMessage() + \u0026#34;\\n\u0026#34;; } } 我们开始执行混沌实验，对 http://127.0.0.1:8801/getName 接口请求注入 3 秒延迟故障。futureTask.get(2000, TimeUnit.MILLISECONDS) 会发生超时返回：\nblade c http delay --time 3000 --uri http://127.0.0.1:8801/getName --rest --process http-client {\u0026#34;code\u0026#34;:200,\u0026#34;success\u0026#34;:true,\u0026#34;result\u0026#34;:\u0026#34;9fd5572869968775\u0026#34;} 验证结果，故障注入前：\n故障注入后：\n停止实验：\nblade d 9fd5572869968775 ","excerpt":"参数 以下是此场景特有参数，通用参数详见：blade create http\n--time string 延迟时间，单位是毫秒，必填项 --offset string 延迟时间上下偏移量， …","ref":"/docs/binaries/create/java/http/http-delay/","title":"http 请求延迟"},{"body":"参数 以下是此场景特有参数，通用参数详见：blade create servlet\n--time string 延迟时间，单位是毫秒，必填项 --offset string 延迟上下浮动时间，例如 --time 3000 --offset 1000，延迟时间的取值范围是 2000-4000 毫秒 案例 访问 http://localhost:8080/dubbodemo/servlet/path?name=bob 请求延迟 3 秒，影响 2 条请求\nblade c servlet delay --time 3000 --requestpath /servlet/path --effect-count 2 {\u0026#34;code\u0026#34;:200,\u0026#34;success\u0026#34;:true,\u0026#34;result\u0026#34;:\u0026#34;154c866919172119\u0026#34;} 访问请求进行验证。\n请求参数是 name=family，延迟 2 秒，延迟时间上下浮动 1 秒，影响范围是 50% 的请求，同时开启 debug 日志用于排查问题，命令如下：\nblade c servlet delay --time 2000 --offset 1000 --querystring name=family --effect-percent 50 --debug {\u0026#34;code\u0026#34;:200,\u0026#34;success\u0026#34;:true,\u0026#34;result\u0026#34;:\u0026#34;49236d2406d168f4\u0026#34;} 监控 应用进程用户目录 /logs/chaosblade/chaosblade.log 日志\n可以看到下发了 create 指令并开启 debug 日志。\n请求两次 http://localhost:8080/dubbodemo/servlet/path?name=bob ，由于参数 querystring 和下发的命令不匹配，所以没有生效。\n随后请求两次 http://localhost:8080/dubbodemo/servlet/path?name=family，第一次打印了 Match rule 日志，说明匹配成功，延迟生效；第二次打印了 limited by，说明匹配成功，但是由于 effect-percent 参数的限制，所以场景被限制，此请求没有发生延迟。\n实验原理 常见问题 ","excerpt":"参数 以下是此场景特有参数，通用参数详见：blade create servlet\n--time string 延迟时间，单位是毫秒，必填项 --offset string 延迟上下浮动时间， …","ref":"/docs/binaries/create/java/servlet/servlet-delay/","title":"Java web 请求延迟"},{"body":"介绍 jvm 本身相关场景，以及可以指定类，方法注入延迟、返回值、异常故障场景，也可以编写 groovy 和 java 脚本来实现复杂的场景。\n参数 此处列举 jvm 支持的通用参数：\n--pid string 指定 java 进程号 --process string 指定 java 进程名，如果同时填写 --timeout string 设定运行时长，单位是秒，通用参数 JVM 方法级别的故障场景通用参数：\n--classname string 指定类名，必须是实现类，带全包名，例如 com.xxx.xxx.XController (必填项) --methodname string 指定方法名，注意相同方法名的方法都会被注入相同故障 (必填项) --after 方法执行完成返回前注入故障，比如修改复杂的返回对象 --effect-count string 限制影响数量 --effect-percent string 限制影响百分比 各场景还有自身所独有的参数，可以在每个场景文档中查看\n案例 此处举个简单的例子：当前 Java 进程 CPU 使用率满载\n# 先执行 prepare 操作 blade prepare jvm --process tomcat {\u0026#34;code\u0026#34;:200,\u0026#34;success\u0026#34;:true,\u0026#34;result\u0026#34;:\u0026#34;af9ec083eaf32e26\u0026#34;} # 执行进程内 CPU 满载 blade create jvm cpufullload --process tomcat {\u0026#34;code\u0026#34;:200,\u0026#34;success\u0026#34;:true,\u0026#34;result\u0026#34;:\u0026#34;2a97b8c2fe9d7c01\u0026#34;} 验证结果：\n停止实验：\n# 停止实验 blade destroy 2a97b8c2fe9d7c01 # 卸载 agent blade revoke af9ec083eaf32e26 ","excerpt":"介绍 jvm 本身相关场景，以及可以指定类，方法注入延迟、返回值、异常故障场景，也可以编写 groovy 和 java 脚本来实现复杂的场景。\n参数 此处列举 jvm 支持的通用参数：\n--pid …","ref":"/docs/binaries/create/java/jvm/","title":"jvm 实验场景"},{"body":"指定一个节点，做 CPU 负载 80% 实验。\n参数    参数 类型 说明     timeout string 设定运行时长，单位是秒，通用参数   cpu-count string 指定 CPU 满载的个数   cpu-list string 指定 CPU 满载的具体核，核索引从 0 开始 (0-3 or 1,3)   cpu-percent string 指定 CPU 负载百分比，取值在 0-100    配置文件 实验配置文件：node_cpu_load.yaml\napiVersion:chaosblade.io/v1alpha1kind:ChaosBlademetadata:name:cpu-loadspec:experiments:- scope:nodetarget:cpuaction:fullloaddesc:\u0026#34;increase node cpu load by names\u0026#34;matchers:- name:namesvalue:- \u0026#34;docker20\u0026#34;- name:cpu-percentvalue:- \u0026#34;80\u0026#34;开始实验 选择一个节点，修改 node_cpu_load.yaml 中的 names 值。\n执行命令，开始实验：\n$ kubectl apply -f node_cpu_load.yaml 查看实验状态 执行 kubectl get blade cpu-load -o json 命令，查看实验状态：\n{ \u0026#34;apiVersion\u0026#34;: \u0026#34;chaosblade.io/v1alpha1\u0026#34;, \u0026#34;kind\u0026#34;: \u0026#34;ChaosBlade\u0026#34;, \u0026#34;metadata\u0026#34;: { \u0026#34;annotations\u0026#34;: { \u0026#34;kubectl.kubernetes.io/last-applied-configuration\u0026#34;: \u0026#34;{\\\u0026#34;apiVersion\\\u0026#34;:\\\u0026#34;chaosblade.io/v1alpha1\\\u0026#34;,\\\u0026#34;kind\\\u0026#34;:\\\u0026#34;ChaosBlade\\\u0026#34;,\\\u0026#34;metadata\\\u0026#34;:{\\\u0026#34;annotations\\\u0026#34;:{},\\\u0026#34;name\\\u0026#34;:\\\u0026#34;cpu-load\\\u0026#34;},\\\u0026#34;spec\\\u0026#34;:{\\\u0026#34;experiments\\\u0026#34;:[{\\\u0026#34;action\\\u0026#34;:\\\u0026#34;fullload\\\u0026#34;,\\\u0026#34;desc\\\u0026#34;:\\\u0026#34;increase node cpu load by names\\\u0026#34;,\\\u0026#34;matchers\\\u0026#34;:[{\\\u0026#34;name\\\u0026#34;:\\\u0026#34;names\\\u0026#34;,\\\u0026#34;value\\\u0026#34;:[\\\u0026#34;docker20\\\u0026#34;]},{\\\u0026#34;name\\\u0026#34;:\\\u0026#34;cpu-percent\\\u0026#34;,\\\u0026#34;value\\\u0026#34;:[\\\u0026#34;80\\\u0026#34;]}],\\\u0026#34;scope\\\u0026#34;:\\\u0026#34;node\\\u0026#34;,\\\u0026#34;target\\\u0026#34;:\\\u0026#34;cpu\\\u0026#34;}]}}\\n\u0026#34; }, \u0026#34;creationTimestamp\u0026#34;: \u0026#34;2020-06-08T02:14:04Z\u0026#34;, \u0026#34;finalizers\u0026#34;: [ \u0026#34;finalizer.chaosblade.io\u0026#34; ], \u0026#34;generation\u0026#34;: 1, \u0026#34;name\u0026#34;: \u0026#34;cpu-load\u0026#34;, \u0026#34;resourceVersion\u0026#34;: \u0026#34;974292\u0026#34;, \u0026#34;selfLink\u0026#34;: \u0026#34;/apis/chaosblade.io/v1alpha1/chaosblades/cpu-load\u0026#34;, \u0026#34;uid\u0026#34;: \u0026#34;21a10bcb-a5ab-4c9e-834a-95599768490a\u0026#34; }, \u0026#34;spec\u0026#34;: { \u0026#34;experiments\u0026#34;: [ { \u0026#34;action\u0026#34;: \u0026#34;fullload\u0026#34;, \u0026#34;desc\u0026#34;: \u0026#34;increase node cpu load by names\u0026#34;, \u0026#34;matchers\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;names\u0026#34;, \u0026#34;value\u0026#34;: [ \u0026#34;docker20\u0026#34; ] }, { \u0026#34;name\u0026#34;: \u0026#34;cpu-percent\u0026#34;, \u0026#34;value\u0026#34;: [ \u0026#34;80\u0026#34; ] } ], \u0026#34;scope\u0026#34;: \u0026#34;node\u0026#34;, \u0026#34;target\u0026#34;: \u0026#34;cpu\u0026#34; } ] }, \u0026#34;status\u0026#34;: { \u0026#34;expStatuses\u0026#34;: [ { \u0026#34;action\u0026#34;: \u0026#34;fullload\u0026#34;, \u0026#34;resStatuses\u0026#34;: [ { \u0026#34;id\u0026#34;: \u0026#34;f5854d2a9b79cd79\u0026#34;, \u0026#34;kind\u0026#34;: \u0026#34;node\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;docker20\u0026#34;, \u0026#34;nodeName\u0026#34;: \u0026#34;docker20\u0026#34;, \u0026#34;state\u0026#34;: \u0026#34;Success\u0026#34;, \u0026#34;success\u0026#34;: true, \u0026#34;uid\u0026#34;: \u0026#34;51d4553b-8da2-46ab-9b3d-51a11ae6d06f\u0026#34; } ], \u0026#34;scope\u0026#34;: \u0026#34;node\u0026#34;, \u0026#34;state\u0026#34;: \u0026#34;Success\u0026#34;, \u0026#34;success\u0026#34;: true, \u0026#34;target\u0026#34;: \u0026#34;cpu\u0026#34; } ], \u0026#34;phase\u0026#34;: \u0026#34;Running\u0026#34; } } 观测结果 停止实验 执行命令：kubectl delete -f node_cpu_load.yaml\n或者直接删除 blade 资源：kubectl delete blade cpu-load\n","excerpt":"指定一个节点，做 CPU 负载 80% 实验。\n参数    参数 类型 说明     timeout string 设定运行时长，单位是秒，通用参数   cpu-count string 指定 CPU …","ref":"/docs/operator/node/node-resource/cpu-load/","title":"Node CPU 负载场景"},{"body":"","excerpt":"","ref":"/docs/binaries/create/k8s/node/","title":"Node 实验场景"},{"body":"","excerpt":"","ref":"/docs/operator/node/node-resource/","title":"Node 资源自身的场景"},{"body":"","excerpt":"","ref":"/try/operator-pod/","title":"Pod 实验场景"},{"body":"","excerpt":"","ref":"/docs/operator/pod/pod-resource/","title":"Pod 资源自身的场景"},{"body":"删除 chaosblade 命名空间下，Pod 名为 guestbook-7b87b7459f-cqkq2 中 container id 是 c6cdcf60b82b854bc4bab64308b466102245259d23e14e449590a8ed816403ed 的容器。\n配置文件 实验配置文件：remove_container_by_id.yaml\napiVersion:chaosblade.io/v1alpha1kind:ChaosBlademetadata:name:remove-container-by-idspec:experiments:- scope:containertarget:containeraction:removedesc:\u0026#34;remove container by id\u0026#34;matchers:- name:container-idsvalue:[\u0026#34;c6cdcf60b82b854bc4bab64308b466102245259d23e14e449590a8ed816403ed\u0026#34;]# pod name- name:namesvalue:[\u0026#34;guestbook-7b87b7459f-cqkq2\u0026#34;]- name:namespacevalue:[\u0026#34;chaosblade\u0026#34;]开始实验 获取 container 名称：\n$ kubectl get pod guestbook-7b87b7459f-cqkq2 -o custom-columns=CONTAINER:.status.containerStatuses[0].name,ID:.status.containerStatuses[0].containerID 修改 remove_container_by_id.yaml 中的 container-ids 和 names。\n执行命令，开始实验：\n$ kubectl apply -f remove_container_by_id.yaml 查看实验状态 执行 kubectl get blade remove-container-by-id -o json 命令，查看实验状态：\n{ \u0026#34;apiVersion\u0026#34;: \u0026#34;chaosblade.io/v1alpha1\u0026#34;, \u0026#34;kind\u0026#34;: \u0026#34;ChaosBlade\u0026#34;, \u0026#34;metadata\u0026#34;: { \u0026#34;annotations\u0026#34;: { \u0026#34;kubectl.kubernetes.io/last-applied-configuration\u0026#34;: \u0026#34;{\\\u0026#34;apiVersion\\\u0026#34;:\\\u0026#34;chaosblade.io/v1alpha1\\\u0026#34;,\\\u0026#34;kind\\\u0026#34;:\\\u0026#34;ChaosBlade\\\u0026#34;,\\\u0026#34;metadata\\\u0026#34;:{\\\u0026#34;annotations\\\u0026#34;:{},\\\u0026#34;name\\\u0026#34;:\\\u0026#34;remove-container-by-id\\\u0026#34;},\\\u0026#34;spec\\\u0026#34;:{\\\u0026#34;experiments\\\u0026#34;:[{\\\u0026#34;action\\\u0026#34;:\\\u0026#34;remove\\\u0026#34;,\\\u0026#34;desc\\\u0026#34;:\\\u0026#34;remove container by id\\\u0026#34;,\\\u0026#34;matchers\\\u0026#34;:[{\\\u0026#34;name\\\u0026#34;:\\\u0026#34;container-ids\\\u0026#34;,\\\u0026#34;value\\\u0026#34;:[\\\u0026#34;5600afacf083f9ddb43fa43c186de235c18313ab1194844ad03b241ba8158166\\\u0026#34;]},{\\\u0026#34;name\\\u0026#34;:\\\u0026#34;names\\\u0026#34;,\\\u0026#34;value\\\u0026#34;:[\\\u0026#34;guestbook-7b87b7459f-cqkq2\\\u0026#34;]},{\\\u0026#34;name\\\u0026#34;:\\\u0026#34;namespace\\\u0026#34;,\\\u0026#34;value\\\u0026#34;:[\\\u0026#34;chaosblade\\\u0026#34;]}],\\\u0026#34;scope\\\u0026#34;:\\\u0026#34;container\\\u0026#34;,\\\u0026#34;target\\\u0026#34;:\\\u0026#34;container\\\u0026#34;}]}}\\n\u0026#34; }, \u0026#34;creationTimestamp\u0026#34;: \u0026#34;2020-06-04T03:31:18Z\u0026#34;, \u0026#34;finalizers\u0026#34;: [ \u0026#34;finalizer.chaosblade.io\u0026#34; ], \u0026#34;generation\u0026#34;: 1, \u0026#34;name\u0026#34;: \u0026#34;remove-container-by-id\u0026#34;, \u0026#34;resourceVersion\u0026#34;: \u0026#34;145441\u0026#34;, \u0026#34;selfLink\u0026#34;: \u0026#34;/apis/chaosblade.io/v1alpha1/chaosblades/remove-container-by-id\u0026#34;, \u0026#34;uid\u0026#34;: \u0026#34;8bc90e2e-9456-455f-81de-c6522e75a653\u0026#34; }, \u0026#34;spec\u0026#34;: { \u0026#34;experiments\u0026#34;: [ { \u0026#34;action\u0026#34;: \u0026#34;remove\u0026#34;, \u0026#34;desc\u0026#34;: \u0026#34;remove container by id\u0026#34;, \u0026#34;matchers\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;container-ids\u0026#34;, \u0026#34;value\u0026#34;: [ \u0026#34;5600afacf083f9ddb43fa43c186de235c18313ab1194844ad03b241ba8158166\u0026#34; ] }, { \u0026#34;name\u0026#34;: \u0026#34;names\u0026#34;, \u0026#34;value\u0026#34;: [ \u0026#34;guestbook-7b87b7459f-cqkq2\u0026#34; ] }, { \u0026#34;name\u0026#34;: \u0026#34;namespace\u0026#34;, \u0026#34;value\u0026#34;: [ \u0026#34;chaosblade\u0026#34; ] } ], \u0026#34;scope\u0026#34;: \u0026#34;container\u0026#34;, \u0026#34;target\u0026#34;: \u0026#34;container\u0026#34; } ] }, \u0026#34;status\u0026#34;: { \u0026#34;expStatuses\u0026#34;: [ { \u0026#34;action\u0026#34;: \u0026#34;remove\u0026#34;, \u0026#34;resStatuses\u0026#34;: [ { \u0026#34;id\u0026#34;: \u0026#34;641cf55a4372a157\u0026#34;, \u0026#34;kind\u0026#34;: \u0026#34;container\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;guestbook\u0026#34;, \u0026#34;nodeName\u0026#34;: \u0026#34;keking\u0026#34;, \u0026#34;state\u0026#34;: \u0026#34;Success\u0026#34;, \u0026#34;success\u0026#34;: true, \u0026#34;uid\u0026#34;: \u0026#34;5600afacf083f9ddb43fa43c186de235c18313ab1194844ad03b241ba8158166\u0026#34; } ], \u0026#34;scope\u0026#34;: \u0026#34;container\u0026#34;, \u0026#34;state\u0026#34;: \u0026#34;Success\u0026#34;, \u0026#34;success\u0026#34;: true, \u0026#34;target\u0026#34;: \u0026#34;container\u0026#34; } ], \u0026#34;phase\u0026#34;: \u0026#34;Running\u0026#34; } } 观测结果 停止实验 执行命令：kubectl delete -f remove_container_by_id.yaml\n或者直接删除 blade 资源：kubectl delete blade remove-container-by-id\n","excerpt":"删除 chaosblade 命名空间下，Pod 名为 guestbook-7b87b7459f-cqkq2 中 container id …","ref":"/docs/operator/container/container-resource/remove/","title":"删除 Container 场景"},{"body":"删除 chaosblade 命名空间下标签是 role=master 的 pod。\n执行观测 开始观察需要删除的 pod：\nkubectl get pod -l \u0026#34;role=master\u0026#34; -n chaosblade -w 配置文件 实验配置文件：delete_pod_by_labels.yaml\napiVersion:chaosblade.io/v1alpha1kind:ChaosBlademetadata:name:delete-two-pod-by-labelsspec:experiments:- scope:podtarget:podaction:deletedesc:\u0026#34;delete pod by labels\u0026#34;matchers:- name:labelsvalue:- \u0026#34;role=master\u0026#34;- name:namespacevalue:- \u0026#34;chaosblade\u0026#34;- name:evict-countvalue:- \u0026#34;2\u0026#34;开始实验 新建终端，并开始实验：\nkubectl apply -f delete_pod_by_labels.yaml 查看实验状态 执行命令：kubectl get blade delete-two-pod-by-labels -o json，查看实验状态：\n{ \u0026#34;apiVersion\u0026#34;: \u0026#34;chaosblade.io/v1alpha1\u0026#34;, \u0026#34;kind\u0026#34;: \u0026#34;ChaosBlade\u0026#34;, \u0026#34;metadata\u0026#34;: { \u0026#34;annotations\u0026#34;: { \u0026#34;kubectl.kubernetes.io/last-applied-configuration\u0026#34;: \u0026#34;{\\\u0026#34;apiVersion\\\u0026#34;:\\\u0026#34;chaosblade.io/v1alpha1\\\u0026#34;,\\\u0026#34;kind\\\u0026#34;:\\\u0026#34;ChaosBlade\\\u0026#34;,\\\u0026#34;metadata\\\u0026#34;:{\\\u0026#34;annotations\\\u0026#34;:{},\\\u0026#34;name\\\u0026#34;:\\\u0026#34;delete-two-pod-by-labels\\\u0026#34;},\\\u0026#34;spec\\\u0026#34;:{\\\u0026#34;experiments\\\u0026#34;:[{\\\u0026#34;action\\\u0026#34;:\\\u0026#34;delete\\\u0026#34;,\\\u0026#34;desc\\\u0026#34;:\\\u0026#34;delete pod by labels\\\u0026#34;,\\\u0026#34;matchers\\\u0026#34;:[{\\\u0026#34;name\\\u0026#34;:\\\u0026#34;labels\\\u0026#34;,\\\u0026#34;value\\\u0026#34;:[\\\u0026#34;role=maste\\\u0026#34;]},{\\\u0026#34;name\\\u0026#34;:\\\u0026#34;namespace\\\u0026#34;,\\\u0026#34;value\\\u0026#34;:[\\\u0026#34;chaosblade\\\u0026#34;]},{\\\u0026#34;name\\\u0026#34;:\\\u0026#34;evict-count\\\u0026#34;,\\\u0026#34;value\\\u0026#34;:[\\\u0026#34;2\\\u0026#34;]}],\\\u0026#34;scope\\\u0026#34;:\\\u0026#34;pod\\\u0026#34;,\\\u0026#34;target\\\u0026#34;:\\\u0026#34;pod\\\u0026#34;}]}}\\n\u0026#34; }, \u0026#34;creationTimestamp\u0026#34;: \u0026#34;2020-06-01T02:11:36Z\u0026#34;, \u0026#34;finalizers\u0026#34;: [ \u0026#34;finalizer.chaosblade.io\u0026#34; ], \u0026#34;generation\u0026#34;: 1, \u0026#34;name\u0026#34;: \u0026#34;delete-two-pod-by-labels\u0026#34;, \u0026#34;resourceVersion\u0026#34;: \u0026#34;10139772\u0026#34;, \u0026#34;selfLink\u0026#34;: \u0026#34;/apis/chaosblade.io/v1alpha1/chaosblades/delete-two-pod-by-labels\u0026#34;, \u0026#34;uid\u0026#34;: \u0026#34;5eec72c7-b52b-4c35-a3b4-e6f6772f496b\u0026#34; }, \u0026#34;spec\u0026#34;: { \u0026#34;experiments\u0026#34;: [ { \u0026#34;action\u0026#34;: \u0026#34;delete\u0026#34;, \u0026#34;desc\u0026#34;: \u0026#34;delete pod by labels\u0026#34;, \u0026#34;matchers\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;labels\u0026#34;, \u0026#34;value\u0026#34;: [ \u0026#34;role=maste\u0026#34; ] }, { \u0026#34;name\u0026#34;: \u0026#34;namespace\u0026#34;, \u0026#34;value\u0026#34;: [ \u0026#34;chaosblade\u0026#34; ] }, { \u0026#34;name\u0026#34;: \u0026#34;evict-count\u0026#34;, \u0026#34;value\u0026#34;: [ \u0026#34;2\u0026#34; ] } ], \u0026#34;scope\u0026#34;: \u0026#34;pod\u0026#34;, \u0026#34;target\u0026#34;: \u0026#34;pod\u0026#34; } ] }, \u0026#34;status\u0026#34;: { \u0026#34;expStatuses\u0026#34;: [ { \u0026#34;action\u0026#34;: \u0026#34;delete\u0026#34;, \u0026#34;resStatuses\u0026#34;: [ { \u0026#34;kind\u0026#34;: \u0026#34;pod\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;redis-8488c84bb7-w5gzl\u0026#34;, \u0026#34;nodeName\u0026#34;: \u0026#34;keking\u0026#34;, \u0026#34;state\u0026#34;: \u0026#34;Success\u0026#34;, \u0026#34;success\u0026#34;: true, \u0026#34;uid\u0026#34;: \u0026#34;b61981d7-f1f8-43a7-885f-d2db012f7647\u0026#34; } ], \u0026#34;scope\u0026#34;: \u0026#34;pod\u0026#34;, \u0026#34;state\u0026#34;: \u0026#34;Success\u0026#34;, \u0026#34;success\u0026#34;: true, \u0026#34;target\u0026#34;: \u0026#34;pod\u0026#34; } ], \u0026#34;phase\u0026#34;: \u0026#34;Running\u0026#34; } } 等待 phase 状态变为 Running\n查看实验结果 可以看到 pod 名称发生变化，表示原 pod 已被删除。\n停止实验 执行命令：kubectl delete -f delete_pod_by_labels.yaml\n或者直接删除 blade 资源：kubectl delete blade delete-two-pod-by-labels\n","excerpt":"删除 chaosblade 命名空间下标签是 role=master 的 pod。\n执行观测 开始观察需要删除的 pod：\nkubectl get pod -l …","ref":"/docs/operator/pod/pod-resource/remove/","title":"删除 Pod"},{"body":"CLI 安装 下载 chaosblade 获取 chaosblade 最新的 release 包，目前支持的平台是 linux/amd64 和 darwin/64，下载对应平台的包。\n下载完成后解压即可，无需编译。\n使用 chaosblade 进入解压后的文件夹，可以看到以下内容：\n├── bin │ ├── chaos_burncpu │ ├── chaos_burnio │ ├── chaos_changedns │ ├── chaos_delaynetwork │ ├── chaos_dropnetwork │ ├── chaos_filldisk │ ├── chaos_killprocess │ ├── chaos_lossnetwork │ ├── jvm.spec.yaml │ └── tools.jar ├── blade └── lib └── sandbox 其中 blade 是可执行文件，即 chaosblade 工具的 cli，混沌实验执行的工具。执行 ./blade help 可以查看支持命令有哪些：\nAn easy to use and powerful chaos engineering experiment toolkit Usage: blade [command] Available Commands: create Create a chaos engineering experiment destroy Destroy a chaos experiment help Help about any command prepare Prepare to experiment revoke Undo chaos engineering experiment preparation status Query preparation stage or experiment status version Print version info Flags: -d, --debug Set client to DEBUG mode -h, --help help for blade Use \u0026quot;blade [command] --help\u0026quot; for more information about a command. Operator 安装 在 Kubernetes 平台上运行 ChaosBlade，请使用 ChaosBlade Operator。\nChaosBlade Operator 需要使用 Helm 安装，进入 release 页面 下载安装包（ChaosBlade 还提供了阿里云 OSS 的下载地址，提升国内下载速度）。\n使用 Helm 3 安装：\n# 下载安装包 $ wget -qO chaosblade-operator-0.6.0.tgz https://chaosblade.oss-cn-hangzhou.aliyuncs.com/agent/github/0.6.0/chaosblade-operator-0.6.0-v3.tgz # 为 chaosblade 创建一个 namespace $ kubectl create namespace chaosblade # 安装 ChaosBlade-Operator $ helm install chaos chaosblade-operator-0.6.0.tgz --set webhook.enable=true --namespace=chaosblade # 查看安装结果 $ kubectl get pod -n chaosblade | grep chaosblade chaosblade-operator-6b6b484599-gdgq8 1/1 Running 0 4d23h chaosblade-tool-7wtph 1/1 Running 0 4d20h chaosblade-tool-r4zdk 1/1 Running 0 4d23h  ChaosBlade Operator 启动后将会在每个节点部署一个 chaosblade-tool Pod 和一个 chaosblade-operator Pod，如果都运行正常，则安装成功。上面设置 --set webhook.enable=true 是为了进行 Pod 文件系统 I/O 故障实验，如果不需要进行该实验，则无需添加该设置。\n 卸载 执行 helm del --purge chaosblade-operator 卸载即可，将会停止全部实验，删除所有创建的资源。\n","excerpt":"CLI 安装 下载 chaosblade 获取 chaosblade 最新的 release 包，目前支持的平台是 linux/amd64 和 darwin/64，下载对应平台的包。\n下载完成后解压即 …","ref":"/docs/installation/","title":"安装部署"},{"body":"命令 支持 CPU 场景命令如下：\n blade create docker cpu load 容器内 CPU 负载场景，同 [blade create cpu load](blade create cpu load.md)  参数 除了上述基础场景各自所需的参数外，在 docker 环境下，还支持的参数如下：\n--blade-override 是否覆盖容器内已有的 chaosblade 工具，默认是 false，表示不覆盖，chaosblade 在容器内的部署路径为 /opt/chaosblade --blade-tar-file string 指定本地 chaosblade-VERSION.tar.gz 工具包全路径，用于拷贝到容器内执行 --container-id string 目标容器 ID --docker-endpoint string Docker server 地址，默认为本地的 /var/run/docker.sock 案例 对 container id 是 5239e26f6329 的做 CPU 使用率 80% 的实验场景，执行命令如下：\nblade create docker cpu fullload --cpu-percent 80 --blade-tar-file /root/chaosblade-0.4.0.tar.gz --container-id 5239e26f6329 执行成功会返回 {\u0026quot;code\u0026quot;:200,\u0026quot;success\u0026quot;:true,\u0026quot;result\u0026quot;:\u0026quot;0a47bb2f75dc71ab\u0026quot;} 可在本机或者容器内使用 top 命令验证 CPU 使用率：\n%Cpu(s): 22.7 us, 57.2 sy, 0.0 ni, 20.1 id, 0.0 wa, 0.0 hi, 0.0 si, 0.0 st 销毁实验执行以下命令：\nblade destroy 0a47bb2f75dc71ab 常见问题 Q: 执行报如下错误：{\u0026quot;code\u0026quot;:801,\u0026quot;success\u0026quot;:false,\u0026quot;error\u0026quot;:\u0026quot;\\u0001\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0002\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0002\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000Omv: cannot stat '/opt/chaosblade-0.4.0.linux-amd64': No such file or directory\u0026quot;}\nA：需要修改将 chaosblade-0.4.0.linux-amd64.tar.gz 包名改为 chaosblade-VERSION.tar.gz 格式，即此处改为 chaosblade-0.4.0.tar.gz\nQ: 执行报如下错误： {\u0026quot;code\u0026quot;:801,\u0026quot;success\u0026quot;:false,\u0026quot;error\u0026quot;:\u0026quot;\\u0001\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0002\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\u0026quot;}\nA：重试即可\n兜底方案 登录容器，kill 掉 chaos_burncpu 进程即可，或者主机上执行。\n","excerpt":"命令 支持 CPU 场景命令如下：\n blade create docker cpu load 容器内 CPU 负载场景，同 [blade create cpu load](blade create …","ref":"/docs/binaries/create/docker/docker-cpu/","title":"容器内 CPU 负载实验场景"},{"body":"参数 -j, --javaHome string 指定 JAVA_HOME 路径，用于指定 java bin 和 tools.jar，如果不添加此参数，默认会优先获取 JAVA_HOME 环境变量，如果获取失败，会解析指定进程参数获取 JAVA_HOME，获取失败，会使用 chaosblade 自带的 tools.jar --pid string java 进程ID -P, --port int java agent 暴露服务的本地端口，用于下发实验命令 -p, --process string java 进程关键词，用于定位 java 进程 -d, --debug 开启 debug 模式 案例 指定 pid 执行 java agent 挂载\nblade prepare jvm --pid 26652 # 命令也可简写为 blade p jvm --pid 26652 执行成功，会返回实验准备的 UID，例如：\n{\u0026#34;code\u0026#34;:200,\u0026#34;success\u0026#34;:true,\u0026#34;result\u0026#34;:\u0026#34;2552c05c6066dde5\u0026#34;} 2552c05c6066dde5 就是实验准备对象的 UID，执行卸载操作需要用到此 UID，例如：\nblade revoke 2552c05c6066dde5 # 命令也可简写为 blade r 2552c05c6066dde5 如果 UID 忘记，可通过以下命令查询\nblade status --type prepare --target jvm # 命令也可简写为： blade s --type p --target jvm 挂载 java agent 操作是个比较耗时的过程，在未返回结果前请耐心等待。\n实现原理 常见问题 Q: {\u0026quot;code\u0026quot;:500,\u0026quot;success\u0026quot;:false,\u0026quot;error\u0026quot;:\u0026quot;cannot get port from local, please execute prepare command first\u0026quot;}\nA: 没有挂载所需的 java agent，执行 prepare jvm 命令挂载\nQ: {\u0026quot;code\u0026quot;:602,\u0026quot;success\u0026quot;:false,\u0026quot;error\u0026quot;:\u0026quot;less --process or --pid flags\u0026quot;}\nA: 缺少必要参数用于指定 java 应用进程\n","excerpt":"参数 -j, --javaHome string 指定 JAVA_HOME 路径，用于指定 java bin 和 tools.jar，如果不添加此参数，默认会优先获取 JAVA_HOME 环境变量，如 …","ref":"/docs/binaries/prepare/jvm/","title":"挂载 java agent"},{"body":"参数 以下是此场景特有参数，通用参数详见：blade create jvm\n--effect-count string 影响的请求条数 --effect-percent string 影响的请求百分比 --time string 延迟时间，单位是毫秒，必填项 --offset string 延迟时间上下偏移量，比如 --time 3000 --offset 1000，则延迟时间范围是 2000-4000 毫秒 案例 业务方法通过 future 获取返回值，代码如下：\n@RequestMapping(value = \u0026#34;async\u0026#34;) @ResponseBody public String asyncHello(final String name, long timeout) { if (timeout == 0) { timeout = 3000; } try { FutureTask futureTask = new FutureTask(new Callable() { @Override public Object call() throws Exception { return sayHello(name); } }); new Thread(futureTask).start(); return (String)futureTask.get(timeout, TimeUnit.MILLISECONDS); } catch (TimeoutException e) { return \u0026#34;timeout, \u0026#34; + e.getMessage() + \u0026#34;\\n\u0026#34;; } catch (Exception e) { return e.getMessage() + \u0026#34;\\n\u0026#34;; } } 我们对 sayHello 方法调用注入 4 秒延迟故障，futureTask.get(2000, TimeUnit.MILLISECONDS) 会发生超时返回：\nblade c jvm delay --time 4000 --classname=com.example.controller.DubboController --methodname=sayHello --process tomcat {\u0026#34;code\u0026#34;:200,\u0026#34;success\u0026#34;:true,\u0026#34;result\u0026#34;:\u0026#34;d6ebea0dc28b6ab3\u0026#34;} 注入故障前：\n注入故障后：\n停止实验：\nblade d d6ebea0dc28b6ab3 ","excerpt":"参数 以下是此场景特有参数，通用参数详见：blade create jvm\n--effect-count string 影响的请求条数 --effect-percent string …","ref":"/docs/binaries/create/java/jvm/jvm-delay/","title":"指定类方法调用延迟"},{"body":"ChaosBlade 使用 Hugo 的 Docsy 主题，并在其基础上进行了定制。\n前提条件  安装 hugo Clone chaosblade docs  git clone https://github.com/chaosblade-io/chaosblade-website.git \u0026amp;\u0026amp; cd chaosblade-website/    运行 在本地运行站点：\nhugo serve 运行状态：\nBuilding sites … WARN 2020/06/22 16:51:44 Page.URL is deprecated and will be removed in a future release. Use .Permalink or .RelPermalink. If what you want is the front matter URL value, use .Params.url | ZH -------------------+----- Pages | 63 Paginator pages | 0 Non-page files | 2 Static files | 68 Processed images | 6 Aliases | 3 Sitemaps | 1 Cleaned | 0 Built in 401 ms Watching for changes in /Users/guoxudong/github/chaosblade-web/chaos-website/{archetypes,assets,content,layouts,static,themes} Watching for config changes in /Users/guoxudong/github/chaosblade-web/chaos-website/config.toml, /Users/guoxudong/github/chaosblade-web/chaos-website/themes/docsy/config.toml Environment: \u0026#34;development\u0026#34; Serving pages from memory Running in Fast Render Mode. For full rebuilds on change: hugo server --disableFastRender Web Server is available at //localhost:1313/ (bind address 127.0.0.1) Press Ctrl+C to stop 发布 在完成文档更新后，运行 hugo 命令即可完成前端页面文件的渲染，渲染后的文件存放在 docs 目录中。\nhugo 渲染完成：\n| EN -------------------+----- Pages | 99 Paginator pages | 0 Non-page files | 0 Static files | 47 Processed images | 0 Aliases | 2 Sitemaps | 1 Cleaned | 0 之后将修改内容放入一个 commit 中，提交 PR 即可（建议一个功能一个 PR），\n在你的 fork 仓库中发布 为了方便 review，请将修改后的内容在你的 fork 仓库中以 GitHub Pages 的形式发布，以提供预览。\n为 fork 仓库设置 GitHub Pages  进入仓库的 Settings 页面 跳转到 GitHub Pages 部分 设置源为 master 分支的 /docs 目录  发布到 GitHub Pages 为了使 GitHub Page 设置生效，请将更改推送到 fork 仓库的 master 分支。\n  更改 /content/zh 中的内容 在根目录运行 hugo 命令 提交更改并将其推送到 fork 仓库的 master 分支 几分钟后，应该就可以在 fork 仓库的 GitHub Pages 页面看到文档  例如：https://sunny0826.github.io/chaosblade/   之后请将预览页面地址贴在 PR 的 commented 中  ","excerpt":"ChaosBlade 使用 Hugo 的 Docsy 主题，并在其基础上进行了定制。\n前提条件  安装 hugo Clone chaosblade docs  git clone …","ref":"/contributing/docs/","title":"撰写文档"},{"body":"给 kubernetes 的 pod 注入文件系统I/O故障。\n注意：此场景需要激活 --webhook-enable 参数，如需使用此功能，请在 chaosblade-operator 参数中添加 --webhook-enable，或者在安装时指定：例如 helm 安装时添加 --set webhook.enable=true 指定。\n 实验参数    参数 类型 说明     methods string I/O故障方法。   delay string I/O延迟时间。   errno string 指定特性的I/O异常错误码。   random string 随机产生I/O异常错误码。   percent string I/O错误百分比 [0-100]。   path string I/O异常的目录或者文件。    前提条件  集群中部署了 chaosblade-admission-webhook 需要注入故障的 volume 设置 mountPropagation 为 HostToContainer pod 上面添加了如下 annotations: chaosblade/inject-volume:\u0026#34;data\u0026#34;//需要注入故障的volumenamechaosblade/inject-volume-subpath:\u0026#34;conf\u0026#34;//volume挂载的子目录  部署测试 pod chaosblade webhook 会根据 pod 的 annotation，注入 fuse 的 sidecar 容器：\n chaosblade/inject-volume 指明需要注入故障的 volume name，比如例子中的 data。 chaosblade/inject-volume-subpath 指明 volume 挂载路径的子目录。上面的例子中，volume 的挂载路径是 /data,子目录是 conf，则在 pod 内，注入I/O异常的目录是 /data/conf。 指定需要注入故障的 volume 需要指定 mountPropagation：HostToContainer，这个字段的含义可以参考官方文档 Volumes。  测试 pod 配置文件：io-test-pod.yaml\napiVersion:apps/v1kind:Deploymentmetadata:labels:app:testname:testnamespace:chaosbladespec:replicas:1selector:matchLabels:app:testtemplate:metadata:annotations:chaosblade/inject-volume:datachaosblade/inject-volume-subpath:conflabels:app:testspec:containers:- command:[\u0026#34;/bin/sh\u0026#34;,\u0026#34;-c\u0026#34;,\u0026#34;while true; do sleep 10000; done\u0026#34;]image:busyboximagePullPolicy:IfNotPresentname:testvolumeMounts:- mountPath:/datamountPropagation:HostToContainername:datavolumes:- hostPath:path:/data/fusename:data部署\n# 部署测试 pod $ kubectl apply -f io-test-pod.yaml # 查看 sidecar 是否注入成功 $ kubectl get pod test-7c9fc6fd88-7lx6b -n chaosblade NAME READY STATUS RESTARTS AGE test-7c9fc6fd88-7lx6b 2/2 Running 0 4m8s 配置文件 实验配置文件：pod_io.yaml\napiVersion:chaosblade.io/v1alpha1kind:ChaosBlademetadata:name:inject-pod-by-labelsspec:experiments:- scope:podtarget:podaction:IOdesc:\u0026#34;Pod IO Exception by labels\u0026#34;matchers:- name:labelsvalue:- \u0026#34;app=test\u0026#34;- name:namespacevalue:- \u0026#34;chaosblade\u0026#34;- name:methodvalue:- \u0026#34;read\u0026#34;- name:delayvalue:- \u0026#34;1000\u0026#34;- name:pathvalue:- \u0026#34;\u0026#34;- name:percentvalue:- \u0026#34;60\u0026#34;- name:errnovalue:- \u0026#34;28\u0026#34;开始实验 执行命令，开始实验：\nkubectl apply -f pod_io.yaml 查看实验状态 执行 kubectl get blade inject-pod-by-labels -o json  命令，查看实验状态：\n{ \u0026#34;apiVersion\u0026#34;: \u0026#34;chaosblade.io/v1alpha1\u0026#34;, \u0026#34;kind\u0026#34;: \u0026#34;ChaosBlade\u0026#34;, \u0026#34;metadata\u0026#34;: { \u0026#34;annotations\u0026#34;: { \u0026#34;kubectl.kubernetes.io/last-applied-configuration\u0026#34;: \u0026#34;{\\\u0026#34;apiVersion\\\u0026#34;:\\\u0026#34;chaosblade.io/v1alpha1\\\u0026#34;,\\\u0026#34;kind\\\u0026#34;:\\\u0026#34;ChaosBlade\\\u0026#34;,\\\u0026#34;metadata\\\u0026#34;:{\\\u0026#34;annotations\\\u0026#34;:{},\\\u0026#34;name\\\u0026#34;:\\\u0026#34;inject-pod-by-labels\\\u0026#34;},\\\u0026#34;spec\\\u0026#34;:{\\\u0026#34;experiments\\\u0026#34;:[{\\\u0026#34;action\\\u0026#34;:\\\u0026#34;IO\\\u0026#34;,\\\u0026#34;desc\\\u0026#34;:\\\u0026#34;Pod IO Exception by labels\\\u0026#34;,\\\u0026#34;matchers\\\u0026#34;:[{\\\u0026#34;name\\\u0026#34;:\\\u0026#34;labels\\\u0026#34;,\\\u0026#34;value\\\u0026#34;:[\\\u0026#34;app=test\\\u0026#34;]},{\\\u0026#34;name\\\u0026#34;:\\\u0026#34;namespace\\\u0026#34;,\\\u0026#34;value\\\u0026#34;:[\\\u0026#34;chaosblade\\\u0026#34;]},{\\\u0026#34;name\\\u0026#34;:\\\u0026#34;method\\\u0026#34;,\\\u0026#34;value\\\u0026#34;:[\\\u0026#34;read\\\u0026#34;]},{\\\u0026#34;name\\\u0026#34;:\\\u0026#34;delay\\\u0026#34;,\\\u0026#34;value\\\u0026#34;:[\\\u0026#34;1000\\\u0026#34;]},{\\\u0026#34;name\\\u0026#34;:\\\u0026#34;path\\\u0026#34;,\\\u0026#34;value\\\u0026#34;:[\\\u0026#34;\\\u0026#34;]},{\\\u0026#34;name\\\u0026#34;:\\\u0026#34;percent\\\u0026#34;,\\\u0026#34;value\\\u0026#34;:[\\\u0026#34;60\\\u0026#34;]},{\\\u0026#34;name\\\u0026#34;:\\\u0026#34;errno\\\u0026#34;,\\\u0026#34;value\\\u0026#34;:[\\\u0026#34;28\\\u0026#34;]}],\\\u0026#34;scope\\\u0026#34;:\\\u0026#34;pod\\\u0026#34;,\\\u0026#34;target\\\u0026#34;:\\\u0026#34;pod\\\u0026#34;}]}}\\n\u0026#34; }, \u0026#34;creationTimestamp\u0026#34;: \u0026#34;2020-06-02T07:45:31Z\u0026#34;, \u0026#34;finalizers\u0026#34;: [ \u0026#34;finalizer.chaosblade.io\u0026#34; ], \u0026#34;generation\u0026#34;: 1, \u0026#34;name\u0026#34;: \u0026#34;inject-pod-by-labels\u0026#34;, \u0026#34;resourceVersion\u0026#34;: \u0026#34;7725368\u0026#34;, \u0026#34;selfLink\u0026#34;: \u0026#34;/apis/chaosblade.io/v1alpha1/chaosblades/inject-pod-by-labels\u0026#34;, \u0026#34;uid\u0026#34;: \u0026#34;302bed87-0dce-4179-8b25-6a87588906fa\u0026#34; }, \u0026#34;spec\u0026#34;: { \u0026#34;experiments\u0026#34;: [ { \u0026#34;action\u0026#34;: \u0026#34;IO\u0026#34;, \u0026#34;desc\u0026#34;: \u0026#34;Pod IO Exception by labels\u0026#34;, \u0026#34;matchers\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;labels\u0026#34;, \u0026#34;value\u0026#34;: [ \u0026#34;app=test\u0026#34; ] }, { \u0026#34;name\u0026#34;: \u0026#34;namespace\u0026#34;, \u0026#34;value\u0026#34;: [ \u0026#34;chaosblade\u0026#34; ] }, { \u0026#34;name\u0026#34;: \u0026#34;method\u0026#34;, \u0026#34;value\u0026#34;: [ \u0026#34;read\u0026#34; ] }, { \u0026#34;name\u0026#34;: \u0026#34;delay\u0026#34;, \u0026#34;value\u0026#34;: [ \u0026#34;1000\u0026#34; ] }, { \u0026#34;name\u0026#34;: \u0026#34;path\u0026#34;, \u0026#34;value\u0026#34;: [ \u0026#34;\u0026#34; ] }, { \u0026#34;name\u0026#34;: \u0026#34;percent\u0026#34;, \u0026#34;value\u0026#34;: [ \u0026#34;60\u0026#34; ] }, { \u0026#34;name\u0026#34;: \u0026#34;errno\u0026#34;, \u0026#34;value\u0026#34;: [ \u0026#34;28\u0026#34; ] } ], \u0026#34;scope\u0026#34;: \u0026#34;pod\u0026#34;, \u0026#34;target\u0026#34;: \u0026#34;pod\u0026#34; } ] }, \u0026#34;status\u0026#34;: { \u0026#34;expStatuses\u0026#34;: [ { \u0026#34;action\u0026#34;: \u0026#34;IO\u0026#34;, \u0026#34;resStatuses\u0026#34;: [ { \u0026#34;kind\u0026#34;: \u0026#34;pod\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;test-7c9fc6fd88-7lx6b\u0026#34;, \u0026#34;nodeName\u0026#34;: \u0026#34;keking\u0026#34;, \u0026#34;state\u0026#34;: \u0026#34;Success\u0026#34;, \u0026#34;success\u0026#34;: true, \u0026#34;uid\u0026#34;: \u0026#34;18fd4930-28d0-41f2-b8af-7dc9f08b39a8\u0026#34; } ], \u0026#34;scope\u0026#34;: \u0026#34;pod\u0026#34;, \u0026#34;state\u0026#34;: \u0026#34;Success\u0026#34;, \u0026#34;success\u0026#34;: true, \u0026#34;target\u0026#34;: \u0026#34;pod\u0026#34; } ], \u0026#34;phase\u0026#34;: \u0026#34;Running\u0026#34; } } 观测结果 # 进入实验 pod $ kubectl exec -it test-7c9fc6fd88-7lx6b bash # 在 pod 内读取指定目录中的文件，如果没有可以新建一个 $ time cat /data/conf/test.yaml cat: read error: No space left on device real 0m3.007s user 0m0.002s sys 0m0.002s # 因为有重试，显示有 3s 的延迟 # 因为设置了 60% 的异常，所有还是有成功的情况 $ time cat /data/conf/test.yaml 123 real 0m0.004s user 0m0.002s sys 0m0.000s 在本例中，我们对 read 操作注入两种异常，异常率为百分之60:\n 对 read 操作增加 1s 的延迟。 对 read 操作返回错误 28。  这里只是做了一种类型的实验，更多的实验类型详见官方文档。\n停止实验 执行命令：kubectl delete -f pod_io.yaml\n或者直接删除 blade 资源：kubectl delete blade inject-pod-by-labels\n删除测试 pod：kubectl delete -f io-test-pod.yaml\n附录 支持的I/O故障方法\nopen read write mkdir rmdir opendir fsync flush release truncate getattr chown chmod utimens allocate getlk setlk setlkw statfs readlink symlink create access link mknod rename unlink getxattr listxattr removexattr setxattr\nI/O异常错误码\n   错误码 错误信息     1 Operation not permitted   2 No such file or directory   5 I/O error   6 No such device or address   12 Out of memory   16 Device or resource busy   17 File exists   20 Not a directory   22 Invalid argument   24 Too many open files   28 No space left on device    ","excerpt":"给 kubernetes 的 pod 注入文件系统I/O故障。\n注意：此场景需要激活 --webhook-enable 参数，如需使用此功能，请在 chaosblade-operator …","ref":"/docs/operator/pod/pod-io/pod-io-error/","title":"文件系统 I/O 故障"},{"body":"","excerpt":"","ref":"/blog/articles/","title":"文章"},{"body":"此实验会删除指定容器中的 redis-server 进程。\n参数    参数 类型 说明     process string 进程关键词，会在整个命令行中查找   process-cmd string 进程命令，只会在命令中查找   count string 限制杀掉进程的数量，0 表示无限制   signal string 指定杀进程的信号量，默认是 9，例如 \u0026ndash;signal 15   timeout string 设定运行时长，单位是秒，通用参数    配置文件 实验配置文件：kill_container_process_by_id.yaml\napiVersion:chaosblade.io/v1alpha1kind:ChaosBlademetadata:name:kill-container-process-by-idspec:experiments:- scope:containertarget:processaction:killdesc:\u0026#34;kill container process by id\u0026#34;matchers:- name:container-idsvalue:- \u0026#34;94bc61ac84fb505f3f89b3ce5e4cc804ea8501ed091940b17b0f492835dc57d1\u0026#34;- name:processvalue:[\u0026#34;redis-server\u0026#34;]- name:namesvalue:[\u0026#34;redis-slave-55d8c8ffbd-4pz8m\u0026#34;]- name:namespacevalue:[\u0026#34;chaosblade\u0026#34;]开始实验 选择一个 pod，获取容器 ID ，修改 kill_container_process_by_id.yaml 中的 container-ids 值。\n执行命令，开始实验：\n$ kubectl apply -f kill_container_process_by_id.yaml 查看实验状态 执行 kubectl get blade kill-container-process-by-id -o json 命令，查看实验状态：\n{ \u0026#34;apiVersion\u0026#34;: \u0026#34;v1\u0026#34;, \u0026#34;items\u0026#34;: [ { \u0026#34;apiVersion\u0026#34;: \u0026#34;chaosblade.io/v1alpha1\u0026#34;, \u0026#34;kind\u0026#34;: \u0026#34;ChaosBlade\u0026#34;, \u0026#34;metadata\u0026#34;: { \u0026#34;annotations\u0026#34;: { \u0026#34;kubectl.kubernetes.io/last-applied-configuration\u0026#34;: \u0026#34;{\\\u0026#34;apiVersion\\\u0026#34;:\\\u0026#34;chaosblade.io/v1alpha1\\\u0026#34;,\\\u0026#34;kind\\\u0026#34;:\\\u0026#34;ChaosBlade\\\u0026#34;,\\\u0026#34;metadata\\\u0026#34;:{\\\u0026#34;annotations\\\u0026#34;:{},\\\u0026#34;name\\\u0026#34;:\\\u0026#34;kill-container-process-by-id\\\u0026#34;},\\\u0026#34;spec\\\u0026#34;:{\\\u0026#34;experiments\\\u0026#34;:[{\\\u0026#34;action\\\u0026#34;:\\\u0026#34;kill\\\u0026#34;,\\\u0026#34;desc\\\u0026#34;:\\\u0026#34;kill container process by id\\\u0026#34;,\\\u0026#34;matchers\\\u0026#34;:[{\\\u0026#34;name\\\u0026#34;:\\\u0026#34;container-ids\\\u0026#34;,\\\u0026#34;value\\\u0026#34;:[\\\u0026#34;bfc9ca01fac33f60d300485f96549644b634f274351df1d4897526451f49e3fb\\\u0026#34;]},{\\\u0026#34;name\\\u0026#34;:\\\u0026#34;process\\\u0026#34;,\\\u0026#34;value\\\u0026#34;:[\\\u0026#34;redis-server\\\u0026#34;]},{\\\u0026#34;name\\\u0026#34;:\\\u0026#34;names\\\u0026#34;,\\\u0026#34;value\\\u0026#34;:[\\\u0026#34;redis-slave-55d8c8ffbd-4pz8m\\\u0026#34;]},{\\\u0026#34;name\\\u0026#34;:\\\u0026#34;namespace\\\u0026#34;,\\\u0026#34;value\\\u0026#34;:[\\\u0026#34;chaosblade\\\u0026#34;]}],\\\u0026#34;scope\\\u0026#34;:\\\u0026#34;container\\\u0026#34;,\\\u0026#34;target\\\u0026#34;:\\\u0026#34;process\\\u0026#34;}]}}\\n\u0026#34; }, \u0026#34;creationTimestamp\u0026#34;: \u0026#34;2020-06-11T01:34:44Z\u0026#34;, \u0026#34;finalizers\u0026#34;: [ \u0026#34;finalizer.chaosblade.io\u0026#34; ], \u0026#34;generation\u0026#34;: 1, \u0026#34;name\u0026#34;: \u0026#34;kill-container-process-by-id\u0026#34;, \u0026#34;resourceVersion\u0026#34;: \u0026#34;1600447\u0026#34;, \u0026#34;selfLink\u0026#34;: \u0026#34;/apis/chaosblade.io/v1alpha1/chaosblades/kill-container-process-by-id\u0026#34;, \u0026#34;uid\u0026#34;: \u0026#34;fd4ea009-b974-49b0-a744-dc0004bef79a\u0026#34; }, \u0026#34;spec\u0026#34;: { \u0026#34;experiments\u0026#34;: [ { \u0026#34;action\u0026#34;: \u0026#34;kill\u0026#34;, \u0026#34;desc\u0026#34;: \u0026#34;kill container process by id\u0026#34;, \u0026#34;matchers\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;container-ids\u0026#34;, \u0026#34;value\u0026#34;: [ \u0026#34;bfc9ca01fac33f60d300485f96549644b634f274351df1d4897526451f49e3fb\u0026#34; ] }, { \u0026#34;name\u0026#34;: \u0026#34;process\u0026#34;, \u0026#34;value\u0026#34;: [ \u0026#34;redis-server\u0026#34; ] }, { \u0026#34;name\u0026#34;: \u0026#34;names\u0026#34;, \u0026#34;value\u0026#34;: [ \u0026#34;redis-slave-55d8c8ffbd-4pz8m\u0026#34; ] }, { \u0026#34;name\u0026#34;: \u0026#34;namespace\u0026#34;, \u0026#34;value\u0026#34;: [ \u0026#34;chaosblade\u0026#34; ] } ], \u0026#34;scope\u0026#34;: \u0026#34;container\u0026#34;, \u0026#34;target\u0026#34;: \u0026#34;process\u0026#34; } ] }, \u0026#34;status\u0026#34;: { \u0026#34;expStatuses\u0026#34;: [ { \u0026#34;action\u0026#34;: \u0026#34;kill\u0026#34;, \u0026#34;resStatuses\u0026#34;: [ { \u0026#34;id\u0026#34;: \u0026#34;4431cdce8d038643\u0026#34;, \u0026#34;kind\u0026#34;: \u0026#34;container\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;redis-slave\u0026#34;, \u0026#34;nodeName\u0026#34;: \u0026#34;docker20\u0026#34;, \u0026#34;state\u0026#34;: \u0026#34;Success\u0026#34;, \u0026#34;success\u0026#34;: true, \u0026#34;uid\u0026#34;: \u0026#34;bfc9ca01fac33f60d300485f96549644b634f274351df1d4897526451f49e3fb\u0026#34; } ], \u0026#34;scope\u0026#34;: \u0026#34;container\u0026#34;, \u0026#34;state\u0026#34;: \u0026#34;Success\u0026#34;, \u0026#34;success\u0026#34;: true, \u0026#34;target\u0026#34;: \u0026#34;process\u0026#34; } ], \u0026#34;phase\u0026#34;: \u0026#34;Running\u0026#34; } } ], \u0026#34;kind\u0026#34;: \u0026#34;List\u0026#34;, \u0026#34;metadata\u0026#34;: { \u0026#34;resourceVersion\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;selfLink\u0026#34;: \u0026#34;\u0026#34; } } 观测结果 # 开始实验前查看容器 id $ kubectl get pod redis-slave-55d8c8ffbd-4pz8m -o custom-columns=POD_NAME:.metadata.name,CONTAINER:.status.containerStatuses[0].name,ID:.status.containerStatuses[0].containerID POD_NAME CONTAINER ID redis-slave-55d8c8ffbd-4pz8m redis-master docker://bfc9ca01fac33f60d300485f96549644b634f274351df1d4897526451f49e3fb # 实验后查看容器 id $ kubectl get pod redis-slave-55d8c8ffbd-4pz8m -o custom-columns=POD_NAME:.metadata.name,CONTAINER:.status.containerStatuses[0].name,ID:.status.containerStatuses[0].containerID POD_NAME CONTAINER ID redis-slave-55d8c8ffbd-4pz8m redis-slave docker://94bc61ac84fb505f3f89b3ce5e4cc804ea8501ed091940b17b0f492835dc57d1 容器 id 变化，主进程被杀掉后容器进行了重启，符合实验逾期。\nredis-server 的进程号发生改变，说明被杀掉后，又被重新拉起。\n停止实验 执行命令：kubectl delete -f kill_container_process_by_id.yaml\n或者直接删除 blade 资源：kubectl delete blade kill-container-process-by-id\n","excerpt":"此实验会删除指定容器中的 redis-server 进程。\n参数    参数 类型 说明     process string 进程关键词，会在整个命令行中查找   process-cmd …","ref":"/docs/operator/container/container-process/kill_container_process/","title":"杀指定进程场景"},{"body":"此实验会删除指定节点上的 redis-server 进程。\n参数    参数 类型 说明     process string 进程关键词，会在整个命令行中查找   process-cmd string 进程命令，只会在命令中查找   count string 限制杀掉进程的数量，0 表示无限制   signal string 指定杀进程的信号量，默认是 9，例如 \u0026ndash;signal 15   timeout string 设定运行时长，单位是秒，通用参数    配置文件 实验配置文件：kill_node_process_by_names.yaml\napiVersion:chaosblade.io/v1alpha1kind:ChaosBlademetadata:name:kill-node-process-by-namesspec:experiments:- scope:nodetarget:processaction:killdesc:\u0026#34;kill node process by names\u0026#34;matchers:- name:namesvalue:[\u0026#34;docker20\u0026#34;]- name:processvalue:[\u0026#34;redis-server\u0026#34;]开始实验 选择一个节点，修改 kill_node_process_by_names.yaml 中的 names 值。\n执行命令，开始实验：\n$ kubectl apply -f kill_node_process_by_names.yaml 查看实验状态 执行 kubectl get blade kill-node-process-by-names -o json 命令，查看实验状态：\n{ \u0026#34;apiVersion\u0026#34;: \u0026#34;chaosblade.io/v1alpha1\u0026#34;, \u0026#34;kind\u0026#34;: \u0026#34;ChaosBlade\u0026#34;, \u0026#34;metadata\u0026#34;: { \u0026#34;annotations\u0026#34;: { \u0026#34;kubectl.kubernetes.io/last-applied-configuration\u0026#34;: \u0026#34;{\\\u0026#34;apiVersion\\\u0026#34;:\\\u0026#34;chaosblade.io/v1alpha1\\\u0026#34;,\\\u0026#34;kind\\\u0026#34;:\\\u0026#34;ChaosBlade\\\u0026#34;,\\\u0026#34;metadata\\\u0026#34;:{\\\u0026#34;annotations\\\u0026#34;:{},\\\u0026#34;name\\\u0026#34;:\\\u0026#34;kill-node-process-by-names\\\u0026#34;},\\\u0026#34;spec\\\u0026#34;:{\\\u0026#34;experiments\\\u0026#34;:[{\\\u0026#34;action\\\u0026#34;:\\\u0026#34;kill\\\u0026#34;,\\\u0026#34;desc\\\u0026#34;:\\\u0026#34;kill node process by names\\\u0026#34;,\\\u0026#34;matchers\\\u0026#34;:[{\\\u0026#34;name\\\u0026#34;:\\\u0026#34;names\\\u0026#34;,\\\u0026#34;value\\\u0026#34;:[\\\u0026#34;docker20\\\u0026#34;]},{\\\u0026#34;name\\\u0026#34;:\\\u0026#34;process\\\u0026#34;,\\\u0026#34;value\\\u0026#34;:[\\\u0026#34;redis-server\\\u0026#34;]}],\\\u0026#34;scope\\\u0026#34;:\\\u0026#34;node\\\u0026#34;,\\\u0026#34;target\\\u0026#34;:\\\u0026#34;process\\\u0026#34;}]}}\\n\u0026#34; }, \u0026#34;creationTimestamp\u0026#34;: \u0026#34;2020-06-08T06:23:30Z\u0026#34;, \u0026#34;finalizers\u0026#34;: [ \u0026#34;finalizer.chaosblade.io\u0026#34; ], \u0026#34;generation\u0026#34;: 1, \u0026#34;name\u0026#34;: \u0026#34;kill-node-process-by-names\u0026#34;, \u0026#34;resourceVersion\u0026#34;: \u0026#34;1010910\u0026#34;, \u0026#34;selfLink\u0026#34;: \u0026#34;/apis/chaosblade.io/v1alpha1/chaosblades/kill-node-process-by-names\u0026#34;, \u0026#34;uid\u0026#34;: \u0026#34;e6120a54-bfc3-44ab-9225-01b77e0b89d0\u0026#34; }, \u0026#34;spec\u0026#34;: { \u0026#34;experiments\u0026#34;: [ { \u0026#34;action\u0026#34;: \u0026#34;kill\u0026#34;, \u0026#34;desc\u0026#34;: \u0026#34;kill node process by names\u0026#34;, \u0026#34;matchers\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;names\u0026#34;, \u0026#34;value\u0026#34;: [ \u0026#34;docker20\u0026#34; ] }, { \u0026#34;name\u0026#34;: \u0026#34;process\u0026#34;, \u0026#34;value\u0026#34;: [ \u0026#34;redis-server\u0026#34; ] } ], \u0026#34;scope\u0026#34;: \u0026#34;node\u0026#34;, \u0026#34;target\u0026#34;: \u0026#34;process\u0026#34; } ] }, \u0026#34;status\u0026#34;: { \u0026#34;expStatuses\u0026#34;: [ { \u0026#34;action\u0026#34;: \u0026#34;kill\u0026#34;, \u0026#34;resStatuses\u0026#34;: [ { \u0026#34;id\u0026#34;: \u0026#34;61921300c4eefa75\u0026#34;, \u0026#34;kind\u0026#34;: \u0026#34;node\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;docker20\u0026#34;, \u0026#34;nodeName\u0026#34;: \u0026#34;docker20\u0026#34;, \u0026#34;state\u0026#34;: \u0026#34;Success\u0026#34;, \u0026#34;success\u0026#34;: true, \u0026#34;uid\u0026#34;: \u0026#34;51d4553b-8da2-46ab-9b3d-51a11ae6d06f\u0026#34; } ], \u0026#34;scope\u0026#34;: \u0026#34;node\u0026#34;, \u0026#34;state\u0026#34;: \u0026#34;Success\u0026#34;, \u0026#34;success\u0026#34;: true, \u0026#34;target\u0026#34;: \u0026#34;process\u0026#34; } ], \u0026#34;phase\u0026#34;: \u0026#34;Running\u0026#34; } } 观测结果 # 进入实验 node $ ssh kk@192.168.1.129 # 查看 redis-server 进程号 $ ps -ef | grep redis-server root 31327 31326 0 06:15 ? 00:00:00 redis-server *:6379 # 可以看到进程号发生了变化 $ ps -ef | grep redis-server root 2873 2872 0 06:23 ? 00:00:00 redis-server *:6379 redis-server 的进程号发生改变，说明被杀掉后，又被重新拉起。\n停止实验 执行命令：kubectl delete -f kill_node_process_by_names.yaml\n或者直接删除 blade 资源：kubectl delete blade kill-node-process-by-names\n","excerpt":"此实验会删除指定节点上的 redis-server 进程。\n参数    参数 类型 说明     process string 进程关键词，会在整个命令行中查找   process-cmd …","ref":"/docs/operator/node/node-process/kill_node_process/","title":"杀节点上指定进程"},{"body":"介绍 此实验会指定进程号杀掉进程。支持命令行或者命令中进程匹配。\n此实验可以验证程序的自愈能力，或者服务进程不存在时，系统的容错能力。\n参数 --process string 进程关键词，会在整个命令行中查找 --process-cmd string 进程命令，只会在命令中查找 --count string 限制杀掉进程的数量，0 表示无限制 --signal string 指定杀进程的信号量，默认是 9，例如 --signal 15 --timeout string 设定运行时长，单位是秒，通用参数 案例 # 删除包含 SimpleHTTPServer 关键词的进程 blade create process kill --process SimpleHTTPServer # 删除 java 进程 blade create process kill --process-cmd java # 指定信号量和本地端口杀进程 blade c process kill --local-port 8080 --signal 15 # 执行前 netstat -tanp | grep 8080 tcp 0 0 0.0.0.0:8080 0.0.0.0:* LISTEN 10764/java # 执行后此进程已不存在 实现原理 --process 内部使用 ps -ef | grep KEY 查找；--process-cmd 内部使用 pgrep 命令查找。\n使用 kill -9 PIDS 杀死进程。\n常见问题 Q：信号量有哪些？\nA：Common kill signals\nSignal name\tSignal value\tEffect SIGHUP\t1\tHangup SIGINT\t2\tInterrupt from keyboard SIGKILL\t9\tKill signal SIGTERM\t15\tTermination signal SIGSTOP\t17,19,23\tStop the process Q：杀死的进程能否恢复\nA：blade 命令不能恢复杀掉的进程\n","excerpt":"介绍 此实验会指定进程号杀掉进程。支持命令行或者命令中进程匹配。\n此实验可以验证程序的自愈能力，或者服务进程不存在时，系统的容错能力。\n参数 --process string 进程关键词，会在整个命令 …","ref":"/docs/binaries/create/process/process-kill/","title":"杀进程"},{"body":"指定节点磁盘占用 80%\n参数 节点磁盘填充均支持以下参数。\n   参数 类型 说明 默认值     path string 需要填充的目录 /   size string 需要填充的文件大小，单位是 M，取值是整数，例如 \u0026ndash;size 1024    reserve string 保留磁盘大小，单位是MB。取值是不包含单位的正整数，例如 \u0026ndash;reserve 1024。如果 size、percent、reserve 参数都存在，优先级是 percent \u0026gt; reserve \u0026gt; size    percent string 指定磁盘使用率，取值是不带%号的正整数，例如 \u0026ndash;percent 80    retain-handle  是否保留填充    timeout string 设定运行时长，单位是秒，通用参数     配置文件 实验配置文件：fill_node_disk_by_names.yaml\napiVersion:chaosblade.io/v1alpha1kind:ChaosBlademetadata:name:fill-node-disk-by-namesspec:experiments:- scope:nodetarget:diskaction:filldesc:\u0026#34;node disk fill\u0026#34;matchers:- name:namesvalue:[\u0026#34;docker20\u0026#34;]- name:percentvalue:[\u0026#34;80\u0026#34;]开始实验 选择一个节点，修改 fill_node_disk_by_names.yaml 中的 names 值。\n执行命令，开始实验：\n$ kubectl apply -f fill_node_disk_by_names.yaml 查看实验状态 执行 kubectl get blade fill-node-disk-by-names -o json 命令，查看实验状态：\n{ \u0026#34;apiVersion\u0026#34;: \u0026#34;chaosblade.io/v1alpha1\u0026#34;, \u0026#34;kind\u0026#34;: \u0026#34;ChaosBlade\u0026#34;, \u0026#34;metadata\u0026#34;: { \u0026#34;annotations\u0026#34;: { \u0026#34;kubectl.kubernetes.io/last-applied-configuration\u0026#34;: \u0026#34;{\\\u0026#34;apiVersion\\\u0026#34;:\\\u0026#34;chaosblade.io/v1alpha1\\\u0026#34;,\\\u0026#34;kind\\\u0026#34;:\\\u0026#34;ChaosBlade\\\u0026#34;,\\\u0026#34;metadata\\\u0026#34;:{\\\u0026#34;annotations\\\u0026#34;:{},\\\u0026#34;name\\\u0026#34;:\\\u0026#34;fill-node-disk-by-names\\\u0026#34;},\\\u0026#34;spec\\\u0026#34;:{\\\u0026#34;experiments\\\u0026#34;:[{\\\u0026#34;action\\\u0026#34;:\\\u0026#34;fill\\\u0026#34;,\\\u0026#34;desc\\\u0026#34;:\\\u0026#34;node disk fill\\\u0026#34;,\\\u0026#34;matchers\\\u0026#34;:[{\\\u0026#34;name\\\u0026#34;:\\\u0026#34;names\\\u0026#34;,\\\u0026#34;value\\\u0026#34;:[\\\u0026#34;docker20\\\u0026#34;]},{\\\u0026#34;name\\\u0026#34;:\\\u0026#34;percent\\\u0026#34;,\\\u0026#34;value\\\u0026#34;:[\\\u0026#34;80\\\u0026#34;]}],\\\u0026#34;scope\\\u0026#34;:\\\u0026#34;node\\\u0026#34;,\\\u0026#34;target\\\u0026#34;:\\\u0026#34;disk\\\u0026#34;}]}}\\n\u0026#34; }, \u0026#34;creationTimestamp\u0026#34;: \u0026#34;2020-06-08T03:57:46Z\u0026#34;, \u0026#34;finalizers\u0026#34;: [ \u0026#34;finalizer.chaosblade.io\u0026#34; ], \u0026#34;generation\u0026#34;: 1, \u0026#34;name\u0026#34;: \u0026#34;fill-node-disk-by-names\u0026#34;, \u0026#34;resourceVersion\u0026#34;: \u0026#34;989523\u0026#34;, \u0026#34;selfLink\u0026#34;: \u0026#34;/apis/chaosblade.io/v1alpha1/chaosblades/fill-node-disk-by-names\u0026#34;, \u0026#34;uid\u0026#34;: \u0026#34;7afd5214-47ee-4048-a6ff-34ac6fd45ff3\u0026#34; }, \u0026#34;spec\u0026#34;: { \u0026#34;experiments\u0026#34;: [ { \u0026#34;action\u0026#34;: \u0026#34;fill\u0026#34;, \u0026#34;desc\u0026#34;: \u0026#34;node disk fill\u0026#34;, \u0026#34;matchers\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;names\u0026#34;, \u0026#34;value\u0026#34;: [ \u0026#34;docker20\u0026#34; ] }, { \u0026#34;name\u0026#34;: \u0026#34;percent\u0026#34;, \u0026#34;value\u0026#34;: [ \u0026#34;80\u0026#34; ] } ], \u0026#34;scope\u0026#34;: \u0026#34;node\u0026#34;, \u0026#34;target\u0026#34;: \u0026#34;disk\u0026#34; } ] }, \u0026#34;status\u0026#34;: { \u0026#34;expStatuses\u0026#34;: [ { \u0026#34;action\u0026#34;: \u0026#34;fill\u0026#34;, \u0026#34;resStatuses\u0026#34;: [ { \u0026#34;id\u0026#34;: \u0026#34;6c155cf5627c699a\u0026#34;, \u0026#34;kind\u0026#34;: \u0026#34;node\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;docker20\u0026#34;, \u0026#34;nodeName\u0026#34;: \u0026#34;docker20\u0026#34;, \u0026#34;state\u0026#34;: \u0026#34;Success\u0026#34;, \u0026#34;success\u0026#34;: true, \u0026#34;uid\u0026#34;: \u0026#34;51d4553b-8da2-46ab-9b3d-51a11ae6d06f\u0026#34; } ], \u0026#34;scope\u0026#34;: \u0026#34;node\u0026#34;, \u0026#34;state\u0026#34;: \u0026#34;Success\u0026#34;, \u0026#34;success\u0026#34;: true, \u0026#34;target\u0026#34;: \u0026#34;disk\u0026#34; } ], \u0026#34;phase\u0026#34;: \u0026#34;Running\u0026#34; } } 观测结果 可以看到磁盘占用 80%。\n# 进入实验 node $ ssh kk@192.168.1.129 # 查看磁盘使用率 $ df -h Filesystem Size Used Avail Use% Mounted on udev 7.9G 0 7.9G 0% /dev tmpfs 1.6G 2.2M 1.6G 1% /run /dev/sda2 98G 73G 20G 79% / tmpfs 7.9G 0 7.9G 0% /dev/shm tmpfs 5.0M 0 5.0M 0% /run/lock tmpfs 7.9G 0 7.9G 0% /sys/fs/cgroup /dev/loop1 90M 90M 0 100% /snap/core/8268 tmpfs 1.6G 0 1.6G 0% /run/user/1000 /dev/loop0 98M 98M 0 100% /snap/core/9289 停止实验 执行命令：kubectl delete -f fill_node_disk_by_names.yaml\n或者直接删除 blade 资源：kubectl delete blade fill-node-disk-by-names\n","excerpt":"指定节点磁盘占用 80%\n参数 节点磁盘填充均支持以下参数。\n   参数 类型 说明 默认值     path string 需要填充的目录 /   size string 需要填充的文件大小， …","ref":"/docs/operator/node/node-disk/fill_node_disk/","title":"磁盘填充场景"},{"body":"对 chaosblade 命名空间中，对 redis-master-68857cd57c-hknb6 Pod 中 container id 是 02655dfdd9f0f712a10d63fdc6721f4dcee0a390e37717fff068bf3f85abf85e 的容器的 6379 端口添加 3000 毫秒访问延迟，延迟时间上下浮动 1000 毫秒。\n实验参数    参数 类型 说明     destination-ip string 目标 IP. 支持通过子网掩码来指定一个网段的IP地址, 例如 192.168.1.0/24. 则 192.168.1.0~192.168.1.255 都生效。你也可以指定固定的 IP，如 192.168.1.1 或者 192.168.1.1/32，也可以通过都号分隔多个参数，例如 192.168.1.1,192.168.2.1。   exclude-port string 排除掉的端口，默认会忽略掉通信的对端端口，目的是保留通信可用。可以指定多个，使用逗号分隔或者连接符表示范围，例如 22,8000 或者 8000-8010。 这个参数不能与 \u0026ndash;local-port 或者 \u0026ndash;remote-port 参数一起使用。   exclude-ip string 排除受影响的 IP，支持通过子网掩码来指定一个网段的IP地址, 例如 192.168.1.0/24. 则 192.168.1.0~192.168.1.255 都生效。你也可以指定固定的 IP，如 192.168.1.1 或者 192.168.1.1/32，也可以通过都号分隔多个参数，例如 192.168.1.1,192.168.2.1。   interface string 网卡设备，例如 eth0 (必要参数)。   local-port string 本地端口，一般是本机暴露服务的端口。可以指定多个，使用逗号分隔或者连接符表示范围，例如 80,8000-8080。   offset string 延迟时间上下浮动的值, 单位是毫秒。   remote-port string 远程端口，一般是要访问的外部暴露服务的端口。可以指定多个，使用逗号分隔或者连接符表示范围，例如 80,8000-8080。   time string 延迟时间，单位是毫秒 (必要参数)。   force  强制覆盖已有的 tc 规则，请务必在明确之前的规则可覆盖的情况下使用。   ignore-peer-port  针对添加 \u0026ndash;exclude-port 参数，报 ss 命令找不到的情况下使用，忽略排除端口。   timeout string 设定运行时长，单位是秒，通用参数。    配置文件 实验配置文件：delay_container_network_by_id.yaml：\napiVersion:chaosblade.io/v1alpha1kind:ChaosBlademetadata:name:delay-container-network-by-idspec:experiments:- scope:containertarget:networkaction:delaydesc:\u0026#34;delay container network by container id\u0026#34;matchers:- name:container-idsvalue:- \u0026#34;02655dfdd9f0f712a10d63fdc6721f4dcee0a390e37717fff068bf3f85abf85e\u0026#34;- name:namesvalue:- \u0026#34;redis-master-68857cd57c-hknb6\u0026#34;- name:namespacevalue:- \u0026#34;chaosblade\u0026#34;- name:local-portvalue:[\u0026#34;6379\u0026#34;]- name:interfacevalue:[\u0026#34;eth0\u0026#34;]- name:timevalue:[\u0026#34;3000\u0026#34;]- name:offsetvalue:[\u0026#34;1000\u0026#34;]开始实验 获取 Pod 名称和 container id：\n$ kubectl get pod redis-master-68857cd57c-hknb6 -o custom-columns=POD_NAME:.metadata.name,CONTAINER:.status.containerStatuses[0].name,ID:.status.containerStatuses[0].containerID 修改 delay_container_network_by_id.yaml 中的 container-ids 和 names。\n执行命令，开始实验：\n$ kubectl apply -f delay_container_network_by_id.yaml 查看实验状态 执行 kubectl get blade delay-container-network-by-id -o json 命令，查看实验状态：\n{ \u0026#34;apiVersion\u0026#34;: \u0026#34;chaosblade.io/v1alpha1\u0026#34;, \u0026#34;kind\u0026#34;: \u0026#34;ChaosBlade\u0026#34;, \u0026#34;metadata\u0026#34;: { \u0026#34;annotations\u0026#34;: { \u0026#34;kubectl.kubernetes.io/last-applied-configuration\u0026#34;: \u0026#34;{\\\u0026#34;apiVersion\\\u0026#34;:\\\u0026#34;chaosblade.io/v1alpha1\\\u0026#34;,\\\u0026#34;kind\\\u0026#34;:\\\u0026#34;ChaosBlade\\\u0026#34;,\\\u0026#34;metadata\\\u0026#34;:{\\\u0026#34;annotations\\\u0026#34;:{},\\\u0026#34;name\\\u0026#34;:\\\u0026#34;delay-container-network-by-id\\\u0026#34;},\\\u0026#34;spec\\\u0026#34;:{\\\u0026#34;experiments\\\u0026#34;:[{\\\u0026#34;action\\\u0026#34;:\\\u0026#34;delay\\\u0026#34;,\\\u0026#34;desc\\\u0026#34;:\\\u0026#34;delay container network by container id\\\u0026#34;,\\\u0026#34;matchers\\\u0026#34;:[{\\\u0026#34;name\\\u0026#34;:\\\u0026#34;container-ids\\\u0026#34;,\\\u0026#34;value\\\u0026#34;:[\\\u0026#34;02655dfdd9f0f712a10d63fdc6721f4dcee0a390e37717fff068bf3f85abf85e\\\u0026#34;]},{\\\u0026#34;name\\\u0026#34;:\\\u0026#34;names\\\u0026#34;,\\\u0026#34;value\\\u0026#34;:[\\\u0026#34;redis-master-68857cd57c-hknb6\\\u0026#34;]},{\\\u0026#34;name\\\u0026#34;:\\\u0026#34;namespace\\\u0026#34;,\\\u0026#34;value\\\u0026#34;:[\\\u0026#34;chaosblade\\\u0026#34;]},{\\\u0026#34;name\\\u0026#34;:\\\u0026#34;local-port\\\u0026#34;,\\\u0026#34;value\\\u0026#34;:[\\\u0026#34;6379\\\u0026#34;]},{\\\u0026#34;name\\\u0026#34;:\\\u0026#34;interface\\\u0026#34;,\\\u0026#34;value\\\u0026#34;:[\\\u0026#34;eth0\\\u0026#34;]},{\\\u0026#34;name\\\u0026#34;:\\\u0026#34;time\\\u0026#34;,\\\u0026#34;value\\\u0026#34;:[\\\u0026#34;3000\\\u0026#34;]},{\\\u0026#34;name\\\u0026#34;:\\\u0026#34;offset\\\u0026#34;,\\\u0026#34;value\\\u0026#34;:[\\\u0026#34;1000\\\u0026#34;]}],\\\u0026#34;scope\\\u0026#34;:\\\u0026#34;container\\\u0026#34;,\\\u0026#34;target\\\u0026#34;:\\\u0026#34;network\\\u0026#34;}]}}\\n\u0026#34; }, \u0026#34;creationTimestamp\u0026#34;: \u0026#34;2020-06-04T07:23:55Z\u0026#34;, \u0026#34;finalizers\u0026#34;: [ \u0026#34;finalizer.chaosblade.io\u0026#34; ], \u0026#34;generation\u0026#34;: 1, \u0026#34;name\u0026#34;: \u0026#34;delay-container-network-by-id\u0026#34;, \u0026#34;resourceVersion\u0026#34;: \u0026#34;178235\u0026#34;, \u0026#34;selfLink\u0026#34;: \u0026#34;/apis/chaosblade.io/v1alpha1/chaosblades/delay-container-network-by-id\u0026#34;, \u0026#34;uid\u0026#34;: \u0026#34;d63730e6-4039-49f3-93fb-ba0936bc50ac\u0026#34; }, \u0026#34;spec\u0026#34;: { \u0026#34;experiments\u0026#34;: [ { \u0026#34;action\u0026#34;: \u0026#34;delay\u0026#34;, \u0026#34;desc\u0026#34;: \u0026#34;delay container network by container id\u0026#34;, \u0026#34;matchers\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;container-ids\u0026#34;, \u0026#34;value\u0026#34;: [ \u0026#34;02655dfdd9f0f712a10d63fdc6721f4dcee0a390e37717fff068bf3f85abf85e\u0026#34; ] }, { \u0026#34;name\u0026#34;: \u0026#34;names\u0026#34;, \u0026#34;value\u0026#34;: [ \u0026#34;redis-master-68857cd57c-hknb6\u0026#34; ] }, { \u0026#34;name\u0026#34;: \u0026#34;namespace\u0026#34;, \u0026#34;value\u0026#34;: [ \u0026#34;chaosblade\u0026#34; ] }, { \u0026#34;name\u0026#34;: \u0026#34;local-port\u0026#34;, \u0026#34;value\u0026#34;: [ \u0026#34;6379\u0026#34; ] }, { \u0026#34;name\u0026#34;: \u0026#34;interface\u0026#34;, \u0026#34;value\u0026#34;: [ \u0026#34;eth0\u0026#34; ] }, { \u0026#34;name\u0026#34;: \u0026#34;time\u0026#34;, \u0026#34;value\u0026#34;: [ \u0026#34;3000\u0026#34; ] }, { \u0026#34;name\u0026#34;: \u0026#34;offset\u0026#34;, \u0026#34;value\u0026#34;: [ \u0026#34;1000\u0026#34; ] } ], \u0026#34;scope\u0026#34;: \u0026#34;container\u0026#34;, \u0026#34;target\u0026#34;: \u0026#34;network\u0026#34; } ] }, \u0026#34;status\u0026#34;: { \u0026#34;expStatuses\u0026#34;: [ { \u0026#34;action\u0026#34;: \u0026#34;delay\u0026#34;, \u0026#34;resStatuses\u0026#34;: [ { \u0026#34;id\u0026#34;: \u0026#34;91c03ddd172ce1a5\u0026#34;, \u0026#34;kind\u0026#34;: \u0026#34;container\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;redis-master\u0026#34;, \u0026#34;nodeName\u0026#34;: \u0026#34;keking\u0026#34;, \u0026#34;state\u0026#34;: \u0026#34;Success\u0026#34;, \u0026#34;success\u0026#34;: true, \u0026#34;uid\u0026#34;: \u0026#34;02655dfdd9f0f712a10d63fdc6721f4dcee0a390e37717fff068bf3f85abf85e\u0026#34; } ], \u0026#34;scope\u0026#34;: \u0026#34;container\u0026#34;, \u0026#34;state\u0026#34;: \u0026#34;Success\u0026#34;, \u0026#34;success\u0026#34;: true, \u0026#34;target\u0026#34;: \u0026#34;network\u0026#34; } ], \u0026#34;phase\u0026#34;: \u0026#34;Running\u0026#34; } } 观测结果 # 获取实验 pod ip $ kubectl get pod -l app=redis,role=master -o jsonpath={.items..status.podIP} 10.42.0.19 # 进入观测 pod $ kubectl exec -it redis-slave-55d8c8ffbd-jd8sm bash # 在 pod 中安装 telnet $ apt-get update \u0026amp;\u0026amp; apt-get install -y telnet # 测试时间 $ time echo \u0026#34;\u0026#34; | telnet 10.42.0.19 6379 Trying 10.42.0.19... Connected to 10.42.0.19. Escape character is \u0026#39;^]\u0026#39;. Connection closed by foreign host. real 0m3.790s user 0m0.007s sys 0m0.001s 可以看到结果符合预期。\n停止实验 执行命令：kubectl delete -f delay_container_network_by_id.yaml\n或者直接删除 blade 资源：kubectl delete blade delay-container-network-by-id\n","excerpt":"对 chaosblade 命名空间中，对 redis-master-68857cd57c-hknb6 Pod 中 container id …","ref":"/docs/operator/container/container-network/delay_container_network/","title":"网络延迟场景"},{"body":" 实验前，请先登录 node 节点，使用 ifconfig 命令查看网卡信息，不是所有系统默认的网卡名称都是 eth0。\n docker20 节点的本地 32436 端口添加 3000 毫秒访问延迟，延迟时间上下浮动 1000 毫秒。\n参数    参数 类型 说明     destination-ip string 目标 IP. 支持通过子网掩码来指定一个网段的IP地址, 例如 192.168.1.0/24. 则 192.168.1.0~192.168.1.255 都生效。你也可以指定固定的 IP，如 192.168.1.1 或者 192.168.1.1/32，也可以通过都号分隔多个参数，例如 192.168.1.1,192.168.2.1。   exclude-port string 排除掉的端口，默认会忽略掉通信的对端端口，目的是保留通信可用。可以指定多个，使用逗号分隔或者连接符表示范围，例如 22,8000 或者 8000-8010。 这个参数不能与 \u0026ndash;local-port 或者 \u0026ndash;remote-port 参数一起使用。   exclude-ip string 排除受影响的 IP，支持通过子网掩码来指定一个网段的IP地址, 例如 192.168.1.0/24. 则 192.168.1.0~192.168.1.255 都生效。你也可以指定固定的 IP，如 192.168.1.1 或者 192.168.1.1/32，也可以通过都号分隔多个参数，例如 192.168.1.1,192.168.2.1。   interface string 网卡设备，例如 eth0 (必要参数)。   local-port string 本地端口，一般是本机暴露服务的端口。可以指定多个，使用逗号分隔或者连接符表示范围，例如 80,8000-8080。   offset string 延迟时间上下浮动的值, 单位是毫秒。   remote-port string 远程端口，一般是要访问的外部暴露服务的端口。可以指定多个，使用逗号分隔或者连接符表示范围，例如 80,8000-8080。   time string 延迟时间，单位是毫秒 (必要参数)。   force  强制覆盖已有的 tc 规则，请务必在明确之前的规则可覆盖的情况下使用。   ignore-peer-port  针对添加 \u0026ndash;exclude-port 参数，报 ss 命令找不到的情况下使用，忽略排除端口。   timeout string 设定运行时长，单位是秒，通用参数。    配置文件 实验配置文件：delay_node_network_by_names.yaml\napiVersion:chaosblade.io/v1alpha1kind:ChaosBlademetadata:name:delay-node-network-by-namesspec:experiments:- scope:nodetarget:networkaction:delaydesc:\u0026#34;delay node network loss\u0026#34;matchers:- name:namesvalue:[\u0026#34;docker20\u0026#34;]- name:interfacevalue:[\u0026#34;ens33\u0026#34;]- name:local-portvalue:[\u0026#34;32436\u0026#34;]- name:timevalue:[\u0026#34;3000\u0026#34;]- name:offsetvalue:[\u0026#34;1000\u0026#34;]开始实验 选择一个节点，修改 delay_node_network_by_names.yaml 中的 names 值。\n对 docker20 节点本地端口 32436 访问丢包率 100%。\n执行命令，开始实验：\n$ kubectl apply -f delay_node_network_by_names.yaml 查看实验状态\n执行 kubectl get blade delay-node-network-by-names -o json 命令，查看实验状态：\n{ \u0026#34;apiVersion\u0026#34;: \u0026#34;chaosblade.io/v1alpha1\u0026#34;, \u0026#34;kind\u0026#34;: \u0026#34;ChaosBlade\u0026#34;, \u0026#34;metadata\u0026#34;: { \u0026#34;annotations\u0026#34;: { \u0026#34;kubectl.kubernetes.io/last-applied-configuration\u0026#34;: \u0026#34;{\\\u0026#34;apiVersion\\\u0026#34;:\\\u0026#34;chaosblade.io/v1alpha1\\\u0026#34;,\\\u0026#34;kind\\\u0026#34;:\\\u0026#34;ChaosBlade\\\u0026#34;,\\\u0026#34;metadata\\\u0026#34;:{\\\u0026#34;annotations\\\u0026#34;:{},\\\u0026#34;name\\\u0026#34;:\\\u0026#34;delay-node-network-by-names\\\u0026#34;},\\\u0026#34;spec\\\u0026#34;:{\\\u0026#34;experiments\\\u0026#34;:[{\\\u0026#34;action\\\u0026#34;:\\\u0026#34;delay\\\u0026#34;,\\\u0026#34;desc\\\u0026#34;:\\\u0026#34;delay node network loss\\\u0026#34;,\\\u0026#34;matchers\\\u0026#34;:[{\\\u0026#34;name\\\u0026#34;:\\\u0026#34;names\\\u0026#34;,\\\u0026#34;value\\\u0026#34;:[\\\u0026#34;docker20\\\u0026#34;]},{\\\u0026#34;name\\\u0026#34;:\\\u0026#34;interface\\\u0026#34;,\\\u0026#34;value\\\u0026#34;:[\\\u0026#34;ens33\\\u0026#34;]},{\\\u0026#34;name\\\u0026#34;:\\\u0026#34;local-port\\\u0026#34;,\\\u0026#34;value\\\u0026#34;:[\\\u0026#34;32436\\\u0026#34;]},{\\\u0026#34;name\\\u0026#34;:\\\u0026#34;time\\\u0026#34;,\\\u0026#34;value\\\u0026#34;:[\\\u0026#34;3000\\\u0026#34;]},{\\\u0026#34;name\\\u0026#34;:\\\u0026#34;offset\\\u0026#34;,\\\u0026#34;value\\\u0026#34;:[\\\u0026#34;1000\\\u0026#34;]}],\\\u0026#34;scope\\\u0026#34;:\\\u0026#34;node\\\u0026#34;,\\\u0026#34;target\\\u0026#34;:\\\u0026#34;network\\\u0026#34;}]}}\\n\u0026#34; }, \u0026#34;creationTimestamp\u0026#34;: \u0026#34;2020-06-08T03:28:30Z\u0026#34;, \u0026#34;finalizers\u0026#34;: [ \u0026#34;finalizer.chaosblade.io\u0026#34; ], \u0026#34;generation\u0026#34;: 1, \u0026#34;name\u0026#34;: \u0026#34;delay-node-network-by-names\u0026#34;, \u0026#34;resourceVersion\u0026#34;: \u0026#34;985238\u0026#34;, \u0026#34;selfLink\u0026#34;: \u0026#34;/apis/chaosblade.io/v1alpha1/chaosblades/delay-node-network-by-names\u0026#34;, \u0026#34;uid\u0026#34;: \u0026#34;d6cf9ba1-56e3-474c-89f3-1df89696c250\u0026#34; }, \u0026#34;spec\u0026#34;: { \u0026#34;experiments\u0026#34;: [ { \u0026#34;action\u0026#34;: \u0026#34;delay\u0026#34;, \u0026#34;desc\u0026#34;: \u0026#34;delay node network loss\u0026#34;, \u0026#34;matchers\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;names\u0026#34;, \u0026#34;value\u0026#34;: [ \u0026#34;docker20\u0026#34; ] }, { \u0026#34;name\u0026#34;: \u0026#34;interface\u0026#34;, \u0026#34;value\u0026#34;: [ \u0026#34;ens33\u0026#34; ] }, { \u0026#34;name\u0026#34;: \u0026#34;local-port\u0026#34;, \u0026#34;value\u0026#34;: [ \u0026#34;32436\u0026#34; ] }, { \u0026#34;name\u0026#34;: \u0026#34;time\u0026#34;, \u0026#34;value\u0026#34;: [ \u0026#34;3000\u0026#34; ] }, { \u0026#34;name\u0026#34;: \u0026#34;offset\u0026#34;, \u0026#34;value\u0026#34;: [ \u0026#34;1000\u0026#34; ] } ], \u0026#34;scope\u0026#34;: \u0026#34;node\u0026#34;, \u0026#34;target\u0026#34;: \u0026#34;network\u0026#34; } ] }, \u0026#34;status\u0026#34;: { \u0026#34;expStatuses\u0026#34;: [ { \u0026#34;action\u0026#34;: \u0026#34;delay\u0026#34;, \u0026#34;resStatuses\u0026#34;: [ { \u0026#34;id\u0026#34;: \u0026#34;33c2ed6fec6fe8cc\u0026#34;, \u0026#34;kind\u0026#34;: \u0026#34;node\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;docker20\u0026#34;, \u0026#34;nodeName\u0026#34;: \u0026#34;docker20\u0026#34;, \u0026#34;state\u0026#34;: \u0026#34;Success\u0026#34;, \u0026#34;success\u0026#34;: true, \u0026#34;uid\u0026#34;: \u0026#34;51d4553b-8da2-46ab-9b3d-51a11ae6d06f\u0026#34; } ], \u0026#34;scope\u0026#34;: \u0026#34;node\u0026#34;, \u0026#34;state\u0026#34;: \u0026#34;Success\u0026#34;, \u0026#34;success\u0026#34;: true, \u0026#34;target\u0026#34;: \u0026#34;network\u0026#34; } ], \u0026#34;phase\u0026#34;: \u0026#34;Running\u0026#34; } } 观测结果 # 从实验节点访问 Guestbook $ time echo \u0026#34;\u0026#34; | telnet 192.168.1.129 32436 Trying 192.168.1.129... Connected to 192.168.1.129. Escape character is \u0026#39;^]\u0026#39;. Connection closed by foreign host. echo \u0026#34;\u0026#34; 0.00s user 0.00s system 35% cpu 0.003 total telnet 192.168.1.129 32436 0.01s user 0.00s system 0% cpu 3.248 total 停止实验 执行命令：kubectl delete -f delay_node_network_by_names.yaml\n或者直接删除 blade 资源：kubectl delete blade delay-node-network-by-names\n","excerpt":"实验前，请先登录 node 节点，使用 ifconfig 命令查看网卡信息，不是所有系统默认的网卡名称都是 eth0。\n docker20 节点的本地 32436 端口添加 3000 毫秒访问延迟，延 …","ref":"/docs/operator/node/node-network/delay_node_network/","title":"网络延迟场景"},{"body":"在 chaosblade 命名空间中，对 redis-master-68857cd57c-dzbs9 Pod 的本地 6379 端口添加 3000 毫秒访问延迟，延迟时间上下浮动 1000 毫秒。\n参数    参数 类型 说明     destination-ip string 目标 IP. 支持通过子网掩码来指定一个网段的IP地址, 例如 192.168.1.0/24. 则 192.168.1.0~192.168.1.255 都生效。你也可以指定固定的 IP，如 192.168.1.1 或者 192.168.1.1/32，也可以通过都号分隔多个参数，例如 192.168.1.1,192.168.2.1。   exclude-port string 排除掉的端口，默认会忽略掉通信的对端端口，目的是保留通信可用。可以指定多个，使用逗号分隔或者连接符表示范围，例如 22,8000 或者 8000-8010。 这个参数不能与 \u0026ndash;local-port 或者 \u0026ndash;remote-port 参数一起使用。   exclude-ip string 排除受影响的 IP，支持通过子网掩码来指定一个网段的IP地址, 例如 192.168.1.0/24. 则 192.168.1.0~192.168.1.255 都生效。你也可以指定固定的 IP，如 192.168.1.1 或者 192.168.1.1/32，也可以通过都号分隔多个参数，例如 192.168.1.1,192.168.2.1。   interface string 网卡设备，例如 eth0 (必要参数)。   local-port string 本地端口，一般是本机暴露服务的端口。可以指定多个，使用逗号分隔或者连接符表示范围，例如 80,8000-8080。   offset string 延迟时间上下浮动的值, 单位是毫秒。   remote-port string 远程端口，一般是要访问的外部暴露服务的端口。可以指定多个，使用逗号分隔或者连接符表示范围，例如 80,8000-8080。   time string 延迟时间，单位是毫秒 (必要参数)。   force  强制覆盖已有的 tc 规则，请务必在明确之前的规则可覆盖的情况下使用。   ignore-peer-port  针对添加 \u0026ndash;exclude-port 参数，报 ss 命令找不到的情况下使用，忽略排除端口。   timeout string 设定运行时长，单位是秒，通用参数。    配置文件 实验配置文件：delay_pod_network_by_names.yaml\napiVersion:chaosblade.io/v1alpha1kind:ChaosBlademetadata:name:delay-pod-network-by-namesspec:experiments:- scope:podtarget:networkaction:delaydesc:\u0026#34;delay pod network by names\u0026#34;matchers:- name:namesvalue:- \u0026#34;redis-master-68857cd57c-dzbs9\u0026#34;- name:namespacevalue:- \u0026#34;chaosblade\u0026#34;- name:local-portvalue:[\u0026#34;6379\u0026#34;]- name:interfacevalue:[\u0026#34;eth0\u0026#34;]- name:timevalue:[\u0026#34;3000\u0026#34;]- name:offsetvalue:[\u0026#34;1000\u0026#34;]开始实验 获取 Pod 名称：\n$ kubectl get pod -l app=redis,role=master -o jsonpath={.items..metadata.name} 修改 delay_pod_network_by_names.yaml 中的 spec-\u0026gt;experiments-\u0026gt;scope-\u0026gt;matchers-\u0026gt;name-\u0026gt;value\n执行命令，开始实验：\n$ kubectl apply -f delay_pod_network_by_names.yaml 查看实验状态 执行 kubectl get blade delay-pod-network-by-names -o json 命令，查看实验状态：\n{ \u0026#34;apiVersion\u0026#34;: \u0026#34;chaosblade.io/v1alpha1\u0026#34;, \u0026#34;kind\u0026#34;: \u0026#34;ChaosBlade\u0026#34;, \u0026#34;metadata\u0026#34;: { \u0026#34;annotations\u0026#34;: { \u0026#34;kubectl.kubernetes.io/last-applied-configuration\u0026#34;: \u0026#34;{\\\u0026#34;apiVersion\\\u0026#34;:\\\u0026#34;chaosblade.io/v1alpha1\\\u0026#34;,\\\u0026#34;kind\\\u0026#34;:\\\u0026#34;ChaosBlade\\\u0026#34;,\\\u0026#34;metadata\\\u0026#34;:{\\\u0026#34;annotations\\\u0026#34;:{},\\\u0026#34;name\\\u0026#34;:\\\u0026#34;delay-pod-network-by-names\\\u0026#34;},\\\u0026#34;spec\\\u0026#34;:{\\\u0026#34;experiments\\\u0026#34;:[{\\\u0026#34;action\\\u0026#34;:\\\u0026#34;delay\\\u0026#34;,\\\u0026#34;desc\\\u0026#34;:\\\u0026#34;delay pod network by names\\\u0026#34;,\\\u0026#34;matchers\\\u0026#34;:[{\\\u0026#34;name\\\u0026#34;:\\\u0026#34;names\\\u0026#34;,\\\u0026#34;value\\\u0026#34;:[\\\u0026#34;redis-master-68857cd57c-dzbs9\\\u0026#34;]},{\\\u0026#34;name\\\u0026#34;:\\\u0026#34;namespace\\\u0026#34;,\\\u0026#34;value\\\u0026#34;:[\\\u0026#34;chaosblade\\\u0026#34;]},{\\\u0026#34;name\\\u0026#34;:\\\u0026#34;local-port\\\u0026#34;,\\\u0026#34;value\\\u0026#34;:[\\\u0026#34;6379\\\u0026#34;]},{\\\u0026#34;name\\\u0026#34;:\\\u0026#34;interface\\\u0026#34;,\\\u0026#34;value\\\u0026#34;:[\\\u0026#34;eth0\\\u0026#34;]},{\\\u0026#34;name\\\u0026#34;:\\\u0026#34;time\\\u0026#34;,\\\u0026#34;value\\\u0026#34;:[\\\u0026#34;3000\\\u0026#34;]},{\\\u0026#34;name\\\u0026#34;:\\\u0026#34;offset\\\u0026#34;,\\\u0026#34;value\\\u0026#34;:[\\\u0026#34;1000\\\u0026#34;]}],\\\u0026#34;scope\\\u0026#34;:\\\u0026#34;pod\\\u0026#34;,\\\u0026#34;target\\\u0026#34;:\\\u0026#34;network\\\u0026#34;}]}}\\n\u0026#34; }, \u0026#34;creationTimestamp\u0026#34;: \u0026#34;2020-06-02T05:57:50Z\u0026#34;, \u0026#34;finalizers\u0026#34;: [ \u0026#34;finalizer.chaosblade.io\u0026#34; ], \u0026#34;generation\u0026#34;: 1, \u0026#34;name\u0026#34;: \u0026#34;delay-pod-network-by-names\u0026#34;, \u0026#34;resourceVersion\u0026#34;: \u0026#34;7710394\u0026#34;, \u0026#34;selfLink\u0026#34;: \u0026#34;/apis/chaosblade.io/v1alpha1/chaosblades/delay-pod-network-by-names\u0026#34;, \u0026#34;uid\u0026#34;: \u0026#34;1235ff55-8256-4caa-a371-e1abf6c9e7b7\u0026#34; }, \u0026#34;spec\u0026#34;: { \u0026#34;experiments\u0026#34;: [ { \u0026#34;action\u0026#34;: \u0026#34;delay\u0026#34;, \u0026#34;desc\u0026#34;: \u0026#34;delay pod network by names\u0026#34;, \u0026#34;matchers\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;names\u0026#34;, \u0026#34;value\u0026#34;: [ \u0026#34;redis-master-68857cd57c-dzbs9\u0026#34; ] }, { \u0026#34;name\u0026#34;: \u0026#34;namespace\u0026#34;, \u0026#34;value\u0026#34;: [ \u0026#34;chaosblade\u0026#34; ] }, { \u0026#34;name\u0026#34;: \u0026#34;local-port\u0026#34;, \u0026#34;value\u0026#34;: [ \u0026#34;6379\u0026#34; ] }, { \u0026#34;name\u0026#34;: \u0026#34;interface\u0026#34;, \u0026#34;value\u0026#34;: [ \u0026#34;eth0\u0026#34; ] }, { \u0026#34;name\u0026#34;: \u0026#34;time\u0026#34;, \u0026#34;value\u0026#34;: [ \u0026#34;3000\u0026#34; ] }, { \u0026#34;name\u0026#34;: \u0026#34;offset\u0026#34;, \u0026#34;value\u0026#34;: [ \u0026#34;1000\u0026#34; ] } ], \u0026#34;scope\u0026#34;: \u0026#34;pod\u0026#34;, \u0026#34;target\u0026#34;: \u0026#34;network\u0026#34; } ] }, \u0026#34;status\u0026#34;: { \u0026#34;expStatuses\u0026#34;: [ { \u0026#34;action\u0026#34;: \u0026#34;delay\u0026#34;, \u0026#34;resStatuses\u0026#34;: [ { \u0026#34;id\u0026#34;: \u0026#34;a86f8cf8b68ace98\u0026#34;, \u0026#34;kind\u0026#34;: \u0026#34;pod\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;redis-master\u0026#34;, \u0026#34;nodeName\u0026#34;: \u0026#34;keking\u0026#34;, \u0026#34;state\u0026#34;: \u0026#34;Success\u0026#34;, \u0026#34;success\u0026#34;: true, \u0026#34;uid\u0026#34;: \u0026#34;619a19ceb213f9b6152159bd868e88de2ddbf9a8aac606dc274b34bec6510c60\u0026#34; } ], \u0026#34;scope\u0026#34;: \u0026#34;pod\u0026#34;, \u0026#34;state\u0026#34;: \u0026#34;Success\u0026#34;, \u0026#34;success\u0026#34;: true, \u0026#34;target\u0026#34;: \u0026#34;network\u0026#34; } ], \u0026#34;phase\u0026#34;: \u0026#34;Running\u0026#34; } } 观测结果 # 获取实验 pod ip $ kubectl get pod -l app=redis,role=master -o jsonpath={.items..status.podIP} 10.42.69.44 # 进入观测 pod $ kubectl exec -it redis-slave-6dd975d4c8-2zrkb bash # 在 pod 中安装 telnet $ apt-get update \u0026amp;\u0026amp; apt-get install -y telnet # 测试时间 $ time echo \u0026#34;\u0026#34; | telnet 10.42.69.44 6379 Trying 10.42.69.44... Connected to 10.42.69.44. Escape character is \u0026#39;^]\u0026#39;. Connection closed by foreign host. real 0m3.790s user 0m0.007s sys 0m0.001s 可以看到结果符合预期。\n停止实验 执行命令：kubectl delete -f delay_pod_network_by_names.yaml\n或者直接删除 blade 资源：kubectl delete blade delay-pod-network-by-names\n","excerpt":"在 chaosblade 命名空间中，对 redis-master-68857cd57c-dzbs9 Pod 的本地 6379 端口添加 3000 毫秒访问延迟，延迟时间上下浮动 1000 毫秒。\n参 …","ref":"/docs/operator/pod/pod-network/delay_pod_network/","title":"网络延迟场景"},{"body":"介绍 可以指定网卡、本地端口、远程端口、目标 IP 延迟。需要特别注意，如果不指定端口、ip 参数，而是整个网卡延迟，切记要添加 \u0026ndash;timeout 参数或者 \u0026ndash;exclude-port 参数，前者是指定运行时间，自动停止销毁实验，后者是指定排除掉的延迟端口，两者都是防止因延迟时间设置太长，造成机器无法连接的情况，如果真实发生此问题，重启机器即可恢复。\n本地端口和远程端口之间是或的关系，即这两个端口都会发生延迟，只要指定了本地端口或者远程端口，无需指定需要排除的端口。端口与 IP 之间是与的关系，即指定的 IP:PORT 发生延迟。\n网络延迟场景主要验证网络异常的情况下，系统的自我容错能力。\n参数 --destination-ip string 目标 IP. 支持通过子网掩码来指定一个网段的IP地址, 例如 192.168.1.0/24. 则 192.168.1.0~192.168.1.255 都生效。你也可以指定固定的 IP，如 192.168.1.1 或者 192.168.1.1/32，也可以通过都号分隔多个参数，例如 192.168.1.1,192.168.2.1。 --exclude-port string 排除掉的端口，默认会忽略掉通信的对端端口，目的是保留通信可用。可以指定多个，使用逗号分隔或者连接符表示范围，例如 22,8000 或者 8000-8010。 这个参数不能与 --local-port 或者 --remote-port 参数一起使用 --exclude-ip string 排除受影响的 IP，支持通过子网掩码来指定一个网段的IP地址, 例如 192.168.1.0/24. 则 192.168.1.0~192.168.1.255 都生效。你也可以指定固定的 IP，如 192.168.1.1 或者 192.168.1.1/32，也可以通过都号分隔多个参数，例如 192.168.1.1,192.168.2.1。 --interface string 网卡设备，例如 eth0 (必要参数) --local-port string 本地端口，一般是本机暴露服务的端口。可以指定多个，使用逗号分隔或者连接符表示范围，例如 80,8000-8080 --offset string 延迟时间上下浮动的值, 单位是毫秒 --remote-port string 远程端口，一般是要访问的外部暴露服务的端口。可以指定多个，使用逗号分隔或者连接符表示范围，例如 80,8000-8080 --time string 延迟时间，单位是毫秒 (必要参数) --force 强制覆盖已有的 tc 规则，请务必在明确之前的规则可覆盖的情况下使用 --ignore-peer-port 针对添加 --exclude-port 参数，报 ss 命令找不到的情况下使用，忽略排除端口 --timeout string 设定运行时长，单位是秒，通用参数 案例 # 访问本机 8080 和 8081 端口延迟 3 秒，延迟时间上下浮动 1 秒 blade create network delay --time 3000 --offset 1000 --interface eth0 --local-port 8080,8081 {\u0026#34;code\u0026#34;:200,\u0026#34;success\u0026#34;:true,\u0026#34;result\u0026#34;:\u0026#34;9b4aa9fabe073624\u0026#34;} # 可以在另一台相同网络内的机器通过 telnet 命令验证，即 telnet xxx.xxx.xxx.xxx 8080 # 销毁实验 blade destroy 9b4aa9fabe073624 # 本机访问外部 14.215.177.39 机器（ping www.baidu.com 获取到的 IP）80 端口延迟 3 秒 blade create network delay --time 3000 --interface eth0 --remote-port 80 --destination-ip 14.215.177.39 # 可在本机通过 telnet 14.215.177.39 80 命令验证 # 对整个网卡 eth0 做 5 秒延迟，排除 22 和 8000到8080 端口 blade create network delay --time 5000 --interface eth0 --exclude-port 22,8000-8080 # 会发现 22 端口和 8000 到 8080 端口不受影响，可在另一台相同网络内的机器通过分别 telnet xxx.xxx.xxx.xxx 8080 和 telnet xxx.xxx.xxx.xxx 8081 进行测试 实现原理 tc 实现\n常见问题 Q: {\u0026quot;code\u0026quot;:604,\u0026quot;success\u0026quot;:false,\u0026quot;error\u0026quot;:\u0026quot;RTNETLINK answers: File exists\\n exit status 2 exit status 1\u0026quot;}\nA： 网络相关的场景实验已存在，销毁原有的后再执行。 可以通过 blade status \u0026ndash;type create 命令来查看已执行的实验， success 状态的表示正在执行； 如果查找不到相关实验，比如已经删除了原有的 chaosblade 目录，则可通过以下命令恢复实验，注意 eth0 替换为你机器的网卡设备：\ntc filter del dev eth0 parent 1: prio 4 tc qdisc del dev eth0 root 也可以添加 --force 命令强制覆盖原有规则。\n","excerpt":"介绍 可以指定网卡、本地端口、远程端口、目标 IP 延迟。需要特别注意，如果不指定端口、ip 参数，而是整个网卡延迟，切记要添加 \u0026ndash;timeout …","ref":"/docs/binaries/create/network/network-delay/","title":"网络延迟实验场景"},{"body":"参数 --time string 延迟时间，单位是毫秒（必要参数） --timeout string 设定运行时长，单位是秒，通用参数 --file string 脚本路径（必要参数） --function-name string 脚本中的函数名（必要参数） 案例 # blade create script delay --time 10000 --file test.sh --function-name start0 {\u0026#34;code\u0026#34;:200,\u0026#34;success\u0026#34;:true,\u0026#34;result\u0026#34;:\u0026#34;b6a0f477b7fb1f4c\u0026#34;} # 会在脚本中添加如下命令： start0() { sleep 10.000000 ... } 实现原理 备份原有脚本，根据函数名添加 sleep 命令\n常见问题 Q: {\u0026quot;code\u0026quot;:602,\u0026quot;success\u0026quot;:false,\u0026quot;error\u0026quot;:\u0026quot;get too many lines by the install function name\u0026quot;}\nA：查找到多个函数，不能执行\n","excerpt":"参数 --time string 延迟时间，单位是毫秒（必要参数） --timeout string 设定运行时长，单位是秒，通用参数 --file string 脚本路径（必要参数） …","ref":"/docs/binaries/create/script/script-delay/","title":"脚本函数执行延迟"},{"body":"","excerpt":"","ref":"/docs/binaries/create/resource/","title":"资源场景"},{"body":"命令 支持的场景命令如下：\n blade create k8s pod-pod delete 删除 POD  参数 除了上述基础场景各自所需的参数外，在 kubernetes 环境下，还支持的参数如下：\n--namespace string Pod 所属的命名空间，只能填写一个值，必填项 --evict-count string 限制实验生效的数量 --evict-percent string 限制实验生效数量的百分比，不包含 % --labels string Pod 资源标签，多个标签之前是或的关系 --names string Pod 资源名 --kubeconfig string kubeconfig 文件全路径（仅限使用 blade 命令调用时使用） --waiting-time string 实验结果等待时间，默认为 20s，参数值要包含单位，例如 10s，1m 案例 删除指定 default 命名空间下标签是 app=guestbook 的 pod，删除\nblade 执行方式 blade create k8s pod-pod delete --labels app=guestbook --namespace default --evict-count 2 --kubeconfig config 如果执行失败，会返回详细的错误信息；如果执行成功，会返回实验的 UID：\n{\u0026#34;code\u0026#34;:200,\u0026#34;success\u0026#34;:true,\u0026#34;result\u0026#34;:\u0026#34;4d3caa0a99c3b2dd\u0026#34;} 可通过以下命令查询实验状态：\nblade query k8s create 4d3caa0a99c3b2dd --kubeconfig config {\u0026#34;code\u0026#34;:200,\u0026#34;success\u0026#34;:true,\u0026#34;result\u0026#34;:{\u0026#34;uid\u0026#34;:\u0026#34;4d3caa0a99c3b2dd\u0026#34;,\u0026#34;success\u0026#34;:true,\u0026#34;error\u0026#34;:\u0026#34;\u0026#34;,\u0026#34;statuses\u0026#34;:[{\u0026#34;uid\u0026#34;:\u0026#34;f325d43c-ff71-11e9-8883-00163e0ad0b3\u0026#34;,\u0026#34;name\u0026#34;:\u0026#34;frontend-d89756ff7-5wgg5\u0026#34;,\u0026#34;state\u0026#34;:\u0026#34;Success\u0026#34;,\u0026#34;kind\u0026#34;:\u0026#34;pod\u0026#34;,\u0026#34;success\u0026#34;:true,\u0026#34;nodeName\u0026#34;:\u0026#34;cn-hangzhou.192.168.0.203\u0026#34;},{\u0026#34;uid\u0026#34;:\u0026#34;28af19dd-f987-11e9-bd30-00163e08a39b\u0026#34;,\u0026#34;name\u0026#34;:\u0026#34;frontend-d89756ff7-dpv7h\u0026#34;,\u0026#34;state\u0026#34;:\u0026#34;Success\u0026#34;,\u0026#34;kind\u0026#34;:\u0026#34;pod\u0026#34;,\u0026#34;success\u0026#34;:true,\u0026#34;nodeName\u0026#34;:\u0026#34;cn-hangzhou.192.168.0.205\u0026#34;}]}} 销毁实验 blade destroy 4d3caa0a99c3b2dd 删除 Pod 的停止实验操作，chaosblade 本身不会重新拉起被删除的 Pod，只是去更改实验状态！！\nkubectl 执行方式 yaml 的配置方式见：Kubernetes 删除 Pod\n","excerpt":"命令 支持的场景命令如下：\n blade create k8s pod-pod delete 删除 POD  参数 除了上述基础场景各自所需的参数外，在 kubernetes 环境下，还支持的参数如 …","ref":"/docs/binaries/create/k8s/pod/pod-pod/","title":"Pod 资源自身场景"},{"body":"指定 chaosblade 命名空间下 Pod 名为 guestbook-7b87b7459f-cqkq2，container id 为 2ff814b246f86，使其 CPU 负载为 100%。\n实验准备 由于使用 helm 安装的 guestbook 没有对资源进行限制，进行负载实验的话，会导致整个节点的故障，所以在实验之前需要对资源进行限制。\n$ kubectl patch deployment redis-slave --patch \u0026#39;{\u0026#34;spec\u0026#34;: {\u0026#34;template\u0026#34;: {\u0026#34;spec\u0026#34;: {\u0026#34;containers\u0026#34;: [{\u0026#34;name\u0026#34;: \u0026#34;redis-slave\u0026#34;,\u0026#34;resources\u0026#34;: {\u0026#34;limits\u0026#34;:{\u0026#34;cpu\u0026#34;:\u0026#34;300m\u0026#34;,\u0026#34;memory\u0026#34;:\u0026#34;512Mi\u0026#34;} }}]}}}}\u0026#39; 配置文件 实验配置文件：increase_container_cpu_load_by_id.yaml\napiVersion:chaosblade.io/v1alpha1kind:ChaosBlademetadata:name:increase-container-cpu-load-by-idspec:experiments:- scope:containertarget:cpuaction:fullloaddesc:\u0026#34;increase container cpu load by id\u0026#34;matchers:- name:container-idsvalue:- \u0026#34;5ad91eb49c1c6f8357e8d455fd27dad5d0c01c5cc3df36a3acdb1abc75f68a11\u0026#34;- name:cpu-percentvalue:[\u0026#34;100\u0026#34;]# pod names- name:namesvalue:[\u0026#34;redis-slave-55d8c8ffbd-jd8sm\u0026#34;]- name:namespacevalue:[\u0026#34;chaosblade\u0026#34;]开始实验 获取 container 名称：\n$ kubectl get pod redis-slave-55d8c8ffbd-jd8sm -o custom-columns=CONTAINER:.status.containerStatuses[0].name,ID:.status.containerStatuses[0].containerID 修改 increase_container_cpu_load_by_id.yaml 中的 container-ids 和 names。\n查看实验状态 执行命令：kubectl get blade increase-container-cpu-load-by-id -o json，查看实验状态：\n{ \u0026#34;apiVersion\u0026#34;: \u0026#34;chaosblade.io/v1alpha1\u0026#34;, \u0026#34;kind\u0026#34;: \u0026#34;ChaosBlade\u0026#34;, \u0026#34;metadata\u0026#34;: { \u0026#34;annotations\u0026#34;: { \u0026#34;kubectl.kubernetes.io/last-applied-configuration\u0026#34;: \u0026#34;{\\\u0026#34;apiVersion\\\u0026#34;:\\\u0026#34;chaosblade.io/v1alpha1\\\u0026#34;,\\\u0026#34;kind\\\u0026#34;:\\\u0026#34;ChaosBlade\\\u0026#34;,\\\u0026#34;metadata\\\u0026#34;:{\\\u0026#34;annotations\\\u0026#34;:{},\\\u0026#34;name\\\u0026#34;:\\\u0026#34;increase-container-cpu-load-by-id-new\\\u0026#34;},\\\u0026#34;spec\\\u0026#34;:{\\\u0026#34;experiments\\\u0026#34;:[{\\\u0026#34;action\\\u0026#34;:\\\u0026#34;fullload\\\u0026#34;,\\\u0026#34;desc\\\u0026#34;:\\\u0026#34;increase container cpu load by id\\\u0026#34;,\\\u0026#34;matchers\\\u0026#34;:[{\\\u0026#34;name\\\u0026#34;:\\\u0026#34;container-ids\\\u0026#34;,\\\u0026#34;value\\\u0026#34;:[\\\u0026#34;5ad91eb49c1c6f8357e8d455fd27dad5d0c01c5cc3df36a3acdb1abc75f68a11\\\u0026#34;]},{\\\u0026#34;name\\\u0026#34;:\\\u0026#34;cpu-percent\\\u0026#34;,\\\u0026#34;value\\\u0026#34;:[\\\u0026#34;100\\\u0026#34;]},{\\\u0026#34;name\\\u0026#34;:\\\u0026#34;names\\\u0026#34;,\\\u0026#34;value\\\u0026#34;:[\\\u0026#34;redis-slave-55d8c8ffbd-jd8sm\\\u0026#34;]},{\\\u0026#34;name\\\u0026#34;:\\\u0026#34;namespace\\\u0026#34;,\\\u0026#34;value\\\u0026#34;:[\\\u0026#34;chaosblade\\\u0026#34;]}],\\\u0026#34;scope\\\u0026#34;:\\\u0026#34;container\\\u0026#34;,\\\u0026#34;target\\\u0026#34;:\\\u0026#34;cpu\\\u0026#34;}]}}\\n\u0026#34; }, \u0026#34;creationTimestamp\u0026#34;: \u0026#34;2020-06-04T06:26:44Z\u0026#34;, \u0026#34;deletionGracePeriodSeconds\u0026#34;: 0, \u0026#34;deletionTimestamp\u0026#34;: \u0026#34;2020-06-04T06:28:48Z\u0026#34;, \u0026#34;finalizers\u0026#34;: [ \u0026#34;finalizer.chaosblade.io\u0026#34; ], \u0026#34;generation\u0026#34;: 2, \u0026#34;name\u0026#34;: \u0026#34;increase-container-cpu-load-by-id-new\u0026#34;, \u0026#34;resourceVersion\u0026#34;: \u0026#34;170473\u0026#34;, \u0026#34;selfLink\u0026#34;: \u0026#34;/apis/chaosblade.io/v1alpha1/chaosblades/increase-container-cpu-load-by-id-new\u0026#34;, \u0026#34;uid\u0026#34;: \u0026#34;51955fd7-a6af-403a-915d-dd25bea73699\u0026#34; }, \u0026#34;spec\u0026#34;: { \u0026#34;experiments\u0026#34;: [ { \u0026#34;action\u0026#34;: \u0026#34;fullload\u0026#34;, \u0026#34;desc\u0026#34;: \u0026#34;increase container cpu load by id\u0026#34;, \u0026#34;matchers\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;container-ids\u0026#34;, \u0026#34;value\u0026#34;: [ \u0026#34;5ad91eb49c1c6f8357e8d455fd27dad5d0c01c5cc3df36a3acdb1abc75f68a11\u0026#34; ] }, { \u0026#34;name\u0026#34;: \u0026#34;cpu-percent\u0026#34;, \u0026#34;value\u0026#34;: [ \u0026#34;100\u0026#34; ] }, { \u0026#34;name\u0026#34;: \u0026#34;names\u0026#34;, \u0026#34;value\u0026#34;: [ \u0026#34;redis-slave-55d8c8ffbd-jd8sm\u0026#34; ] }, { \u0026#34;name\u0026#34;: \u0026#34;namespace\u0026#34;, \u0026#34;value\u0026#34;: [ \u0026#34;chaosblade\u0026#34; ] } ], \u0026#34;scope\u0026#34;: \u0026#34;container\u0026#34;, \u0026#34;target\u0026#34;: \u0026#34;cpu\u0026#34; } ] }, \u0026#34;status\u0026#34;: { \u0026#34;expStatuses\u0026#34;: [ { \u0026#34;action\u0026#34;: \u0026#34;fullload\u0026#34;, \u0026#34;resStatuses\u0026#34;: [ { \u0026#34;id\u0026#34;: \u0026#34;28a075b31562ba6f\u0026#34;, \u0026#34;kind\u0026#34;: \u0026#34;container\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;redis-slave\u0026#34;, \u0026#34;nodeName\u0026#34;: \u0026#34;keking\u0026#34;, \u0026#34;state\u0026#34;: \u0026#34;Success\u0026#34;, \u0026#34;success\u0026#34;: true, \u0026#34;uid\u0026#34;: \u0026#34;5ad91eb49c1c6f8357e8d455fd27dad5d0c01c5cc3df36a3acdb1abc75f68a11\u0026#34; } ], \u0026#34;scope\u0026#34;: \u0026#34;container\u0026#34;, \u0026#34;state\u0026#34;: \u0026#34;Success\u0026#34;, \u0026#34;success\u0026#34;: true, \u0026#34;target\u0026#34;: \u0026#34;cpu\u0026#34; } ], \u0026#34;phase\u0026#34;: \u0026#34;Running\u0026#34; } } 观测结果 可从监控系统观测到结果\n停止实验 执行命令：kubectl delete -f increase_container_cpu_load_by_id.yaml\n或者直接删除 blade 资源：kubectl delete blade increase-container-cpu-load-by-id\n","excerpt":"指定 chaosblade 命名空间下 Pod 名为 guestbook-7b87b7459f-cqkq2，container id 为 2ff814b246f86，使其 CPU 负载为 100%。\n …","ref":"/docs/operator/container/container-resource/cpu-load/","title":"Container 内 CPU 负载场景"},{"body":"","excerpt":"","ref":"/docs/operator/container/container-network/","title":"Container 内网络实验场景"},{"body":"","excerpt":"","ref":"/docs/binaries/destroy/","title":"destroy 命令"},{"body":"介绍 此实验会修改本地的 hosts，篡改域名地址映射。\n网络丢包场景主要验证域名解析异常的情况下，系统的自我容错能力。\n参数 --domain string 域名 (必要参数) --ip string 映射的 ip (必要参数) --timeout string 设定运行时长，单位是秒，通用参数 案例 # www.baidu.com 域名不可访问 blade create network dns --domain www.baidu.com --ip 10.0.0.0 {\u0026#34;code\u0026#34;:200,\u0026#34;success\u0026#34;:true,\u0026#34;result\u0026#34;:\u0026#34;9e7a168079c68fad\u0026#34;} # 使用 ping www.baidu.com 来验证，会发现访问不通。 实现原理 修改 /etc/hosts\n常见问题 Q：{\u0026quot;code\u0026quot;:604,\u0026quot;success\u0026quot;:false,\u0026quot;error\u0026quot;:\u0026quot;10.0.0.0 www.baidu.com #chaosblade has been exist exit status 1\u0026quot;}\nA：表示此条映射已存在，销毁之前的实验即可。如果找不到 UID，可以直接修改 /etc/hosts ，删除包含 #chaosblade 注释的项即可\n","excerpt":"介绍 此实验会修改本地的 hosts，篡改域名地址映射。\n网络丢包场景主要验证域名解析异常的情况下，系统的自我容错能力。\n参数 --domain string 域名 (必要参数) --ip …","ref":"/docs/binaries/create/network/network-dns/","title":"DNS 解析异常实验场景"},{"body":" 命令可以简写为 blade c http tce\n 参数 以下是此场景特有参数，通用参数详见：blade create http\n--exception string 异常类，带全包名，必须继承 java.lang.Exception 或 java.lang.Exception 本身 --exception-message string 指定异常类信息，默认值是 chaosblade-mock-exception 案例 http-client 进程的 /httpdemo/hello 接口：内部通过 restTemplate 组件访问 http://127.0.0.1:8801/getName 接口获取返回值。\n指定以上 http 请求抛出 java.lang.Exception 异常，影响 2 条请求：\nblade c http throwCustomException --exception java.lang.Exception --uri http://127.0.0.1:8801/getName --rest --process http-client --effect-count 2 {\u0026#34;code\u0026#34;:200,\u0026#34;success\u0026#34;:true,\u0026#34;result\u0026#34;:\u0026#34;06540c7b4171a7ae\u0026#34;} 验证结果，故障注入前：\n故障注入后：\n查看日志：前两次请求打印了 Match rule 日志，说明匹配成功，故障生效；第 3 次打印了 Limited by，说明匹配成功，但是由于 effect-count 参数的限制，所以此请求没有抛出异常\n2020-05-05 00:48:16 INFO command: create, request: {\u0026#34;headers\u0026#34;:{},\u0026#34;params\u0026#34;:{\u0026#34;exception\u0026#34;:\u0026#34;java.lang.Exception\u0026#34;,\u0026#34;rest\u0026#34;:\u0026#34;true\u0026#34;,\u0026#34;process\u0026#34;:\u0026#34;http-client\u0026#34;,\u0026#34;effect-count\u0026#34;:\u0026#34;2\u0026#34;,\u0026#34;action\u0026#34;:\u0026#34;throwCustomException\u0026#34;,\u0026#34;suid\u0026#34;:\u0026#34;06540c7b4171a7ae\u0026#34;,\u0026#34;uri\u0026#34;:\u0026#34;http://127.0.0.1:8801/getName\u0026#34;,\u0026#34;target\u0026#34;:\u0026#34;http\u0026#34;}} 2020-05-05 00:48:32 INFO Match rule: {\u0026#34;action\u0026#34;:{\u0026#34;name\u0026#34;:\u0026#34;throwCustomException\u0026#34;},\u0026#34;actionName\u0026#34;:\u0026#34;throwCustomException\u0026#34;,\u0026#34;matcher\u0026#34;:{\u0026#34;matchers\u0026#34;:{\u0026#34;rest\u0026#34;:\u0026#34;true\u0026#34;,\u0026#34;effect-count\u0026#34;:\u0026#34;2\u0026#34;,\u0026#34;uri\u0026#34;:\u0026#34;http://127.0.0.1:8801/getName\u0026#34;}},\u0026#34;target\u0026#34;:\u0026#34;http\u0026#34;} 2020-05-05 00:48:32 INFO Match rule: {\u0026#34;action\u0026#34;:{\u0026#34;name\u0026#34;:\u0026#34;throwCustomException\u0026#34;},\u0026#34;actionName\u0026#34;:\u0026#34;throwCustomException\u0026#34;,\u0026#34;matcher\u0026#34;:{\u0026#34;matchers\u0026#34;:{\u0026#34;rest\u0026#34;:\u0026#34;true\u0026#34;,\u0026#34;effect-count\u0026#34;:\u0026#34;2\u0026#34;,\u0026#34;uri\u0026#34;:\u0026#34;http://127.0.0.1:8801/getName\u0026#34;}},\u0026#34;target\u0026#34;:\u0026#34;http\u0026#34;} 2020-05-05 00:48:33 INFO Limited by: {\u0026#34;action\u0026#34;:{\u0026#34;name\u0026#34;:\u0026#34;throwCustomException\u0026#34;},\u0026#34;actionName\u0026#34;:\u0026#34;throwCustomException\u0026#34;,\u0026#34;matcher\u0026#34;:{\u0026#34;matchers\u0026#34;:{\u0026#34;rest\u0026#34;:\u0026#34;true\u0026#34;,\u0026#34;effect-count\u0026#34;:\u0026#34;2\u0026#34;,\u0026#34;uri\u0026#34;:\u0026#34;http://127.0.0.1:8801/getName\u0026#34;}},\u0026#34;target\u0026#34;:\u0026#34;http\u0026#34;} 停止实验：\nblade d 06540c7b4171a7ae ","excerpt":"命令可以简写为 blade c http tce\n 参数 以下是此场景特有参数，通用参数详见：blade create http\n--exception string 异常类，带全包名， …","ref":"/docs/binaries/create/java/http/http-throwcustomexception/","title":"http 请求抛自定义异常"},{"body":"Servlet 是 Java 的 web 的接口规范，Java web 服务器都遵循此规范实现。本场景主要模拟 Java Web 请求延迟、异常场景。\n参数 servlet 通用参数\n--effect-count string 影响的请求条数 --effect-percent string 影响的请求百分比 --method string HTTP 请求类型, 例如： GET, POST, or PUT. --pathinfo string 已废弃 --pid string java进程号 --process string java进程名 --querystring string 请求参数，例如http://localhost:8080/dubbodemo/async?name=friend\u0026amp;timeout=2000 中 querystring的值是 name=friend\u0026amp;timeout=2000 --requestpath string 请求 URI，不包含 Context 部分，例如 http://localhost:8080/dubbodemo/async?name=friend\u0026amp;timeout=2000，则 requestpath 的值是 /async，注意要带 / --servletpath string 已废弃 实验原理 常见问题 Q: 下发规则不生效\nA: 在命令后添加 \u0026ndash;debug，然后触发业务请求，查看应用进程用户目录下 logs/chaosblade/chaosblade.log 日志，如下：\n2019-12-09 21:15:12 DEBUG servlet matchers: {\u0026#34;matchers\u0026#34;:{\u0026#34;querystring\u0026#34;:\u0026#34;name=bobo\u0026#34;,\u0026#34;servletpath\u0026#34;:\u0026#34;/servlet/path\u0026#34;,\u0026#34;method\u0026#34;:\u0026#34;GET\u0026#34;,\u0026#34;requestpath\u0026#34;:\u0026#34;/servlet/path\u0026#34;}} 2019-12-09 21:15:12 INFO Match rule: {\u0026#34;action\u0026#34;:{\u0026#34;name\u0026#34;:\u0026#34;delay\u0026#34;},\u0026#34;actionName\u0026#34;:\u0026#34;delay\u0026#34;,\u0026#34;matcher\u0026#34;:{\u0026#34;matchers\u0026#34;:{}},\u0026#34;target\u0026#34;:\u0026#34;servlet\u0026#34;} servlet matchers 日志表示获取应用的匹配数据，Match rule 表示和下发的命令匹配。\n","excerpt":"Servlet 是 Java 的 web 的接口规范，Java web 服务器都遵循此规范实现。本场景主要模拟 Java Web 请求延迟、异常场景。\n参数 servlet …","ref":"/docs/binaries/create/java/servlet/","title":"Java Servlet 实验场景"},{"body":"参数 以下是此场景特有参数，通用参数详见：blade create servlet\n--exception string 异常类，带全包名，必须继承 java.lang.Exception 或 java.lang.Exception 本身 --exception-message string 指定异常类信息，默认值是 chaosblade-mock-exception 案例 访问 http://localhost:8080/dubbodemo/hello?code=1 请求异常，影响 3 条请求\nblade c servlet throwCustomException --exception org.springframework.beans.BeansException --exception-message mock-beans-exception --requestpath /hello --effect-count 3 {\u0026#34;code\u0026#34;:200,\u0026#34;success\u0026#34;:true,\u0026#34;result\u0026#34;:\u0026#34;d4a63f4f59f76f4a\u0026#34;} 访问请求进行验证。\n查看日志，通过日志也可以看出\n实验原理 常见问题 ","excerpt":"参数 以下是此场景特有参数，通用参数详见：blade create servlet\n--exception string 异常类，带全包名，必须继承 java.lang.Exception …","ref":"/docs/binaries/create/java/servlet/servlet-throwcustomexception/","title":"Java web 请求异常"},{"body":"","excerpt":"","ref":"/docs/operator/node/node-network/","title":"Node 网络相关场景"},{"body":" 值得注意的是：在实验途中，如果被实验的 Pod 被删除了，则会导致实验销毁失败，实验无法被销毁。这样设计的目的是为了在销毁失败的实验时，用户需要去检查是否真正的需要销毁。确认无误后，可以强制销毁该实验，详见 https://github.com/chaosblade-io/chaosblade/issues/368。\n 参数\nPod 资源均支持以下参数。\n   参数 类型 说明 默认值     namespace string Pod 所属的命名空间 default   evict-count string 限制实验生效的数量    evict-percent string 限制实验生效数量的百分比，不包含 %    labels string Pod 资源标签，多个标签之间是或的关系    names string Pod 资源名    waiting-time string 实验结果等待时间，参数值要包含单位，例如 10s，1m 20s    ","excerpt":" 值得注意的是：在实验途中，如果被实验的 Pod 被删除了，则会导致实验销毁失败，实验无法被销毁。这样设计的目的是为了在销毁失败的实验时，用户需要去检查是否真正的需要销毁。确认无误后，可以强制销毁该实 …","ref":"/docs/operator/pod/","title":"Pod 场景"},{"body":"","excerpt":"","ref":"/docs/binaries/create/k8s/pod/","title":"Pod 实验场景"},{"body":"","excerpt":"","ref":"/docs/operator/pod/pod-network/","title":"Pod 网络相关场景"},{"body":"命令 支持的网络场景命令如下：\n blade create docker network delay 容器网络延迟，同 blade create network delay blade create docker network loss 容器网络丢包，同 blade create network loss blade create docker network dns 容器内域名访问异常，同 blade create network dns  参数 除了上述基础场景各自所需的参数外，在 docker 环境下，还支持的参数如下：\n--container-id string 目标容器 ID --docker-endpoint string Docker server 地址，默认为本地的 /var/run/docker.sock --image-repo string chaosblade-tool 镜像仓库地址，默认是从 `registry.cn-hangzhou.aliyuncs.com/chaosblade` 案例 对 nginx 容器 80 端口做访问延迟 3 秒，执行命令如下：\nblade create docker network delay --time 3000 --interface eth0 --local-port 80 --container-id 5239e26f6329 第一次会拉取 chaosblade-tool 镜像，可能会慢一些。返回 {\u0026quot;code\u0026quot;:200,\u0026quot;success\u0026quot;:true,\u0026quot;result\u0026quot;:\u0026quot;fc3a1b0b4295e47f\u0026quot;} 表示执行成功，可以看到新启动了一个名字为 5239e26f6329-delay 的容器，通过 sidecar 方式，复用目标容器网络，执行实验。\n在本机访问该容器映射出的端口服务，比如映射的端口为 0.0.0.0:32768-\u0026gt;80/tcp，可以看出发生延迟：\n[root@izbp11rrxxxx ~]# time curl localhost:32768 real\t0m9.001s user\t0m0.004s sys\t0m0.002s 此处延迟 9 秒的原因是涉及到多次 80 端口访问。\n也可以在同一网段下的另外一台容器内访问目标容器的 80 服务，同样能验证效果：\nbash-4.4# time curl 172.17.0.2:80 real\t0m9.005s user\t0m0.004s sys 0m0.001s 执行以下命令可销毁实验：\nblade destroy fc3a1b0b4295e47f 启动的 sidecar 容器会被销毁，网络恢复。可以通过上述方法再次验证。\n[root@izbp11rr7oumxxxxx ~]# time curl localhost:32768 real\t0m0.011s user\t0m0.003s sys\t0m0.002s 常见问题 Q：执行命令报错： {\u0026quot;code\u0026quot;:604,\u0026quot;success\u0026quot;:false,\u0026quot;error\u0026quot;:\u0026quot;RTNETLINK answers: File exists\\n exit status 2 exit status 1\u0026quot;}\nA：网络演练场景已存在，可以使用 docker ps | grep chaosblade 来查看正在运行的 sidecar 容器\n","excerpt":"命令 支持的网络场景命令如下：\n blade create docker network delay 容器网络延迟，同 blade create network delay blade create …","ref":"/docs/binaries/create/docker/docker-network/","title":"容器内网络实验场景"},{"body":"命令 支持的网络场景命令如下：\n blade create k8s container-network delay container 网络延迟场景，同 blade create network delay blade create k8s container-network loss container 网络丢包场景，同 blade create network loss blade create k8s container-network dns container 域名访问异常场景，同 blade create network dns  参数 除了上述基础场景各自所需的参数外，在 kubernetes 环境下，还支持的参数如下：\n--container-ids string 容器ID，支持配置多个 --container-names string 容器名称，支持配置多个 --docker-endpoint string Docker server 地址，默认为本地的 /var/run/docker.sock --namespace string Pod 所属的命名空间，只能填写一个值，必填项 --evict-count string 限制实验生效的数量 --evict-percent string 限制实验生效数量的百分比，不包含 % --labels string Pod 资源标签，多个标签之前是或的关系 --names string Pod 资源名 --kubeconfig string kubeconfig 文件全路径（仅限使用 blade 命令调用时使用） --waiting-time string 实验结果等待时间，默认为 20s，参数值要包含单位，例如 10s，1m 案例 指定 default 命名空间下 Pod 名为 frontend-d89756ff7-pbnnc，容器 id 为 2ff814b246f86，做访问 www.baidu.com 域名异常实验举例。\nblade 命令执行方式 blade create k8s container-network dns --domain www.baidu.com --ip 10.0.0.1 --names frontend-d89756ff7-trsxf --namespace default --container-ids 4b25f66580c4 --kubeconfig config 如果执行失败，会返回详细的错误信息；如果执行成功，会返回实验的 UID：\n{\u0026#34;code\u0026#34;:200,\u0026#34;success\u0026#34;:true,\u0026#34;result\u0026#34;:\u0026#34;6e46a5df94e0b065\u0026#34;} 可通过以下命令查询实验状态：\nblade query k8s create 6e46a5df94e0b065 --kubeconfig config {\u0026#34;code\u0026#34;:200,\u0026#34;success\u0026#34;:true,\u0026#34;result\u0026#34;:{\u0026#34;uid\u0026#34;:\u0026#34;6e46a5df94e0b065\u0026#34;,\u0026#34;success\u0026#34;:true,\u0026#34;error\u0026#34;:\u0026#34;\u0026#34;,\u0026#34;statuses\u0026#34;:[{\u0026#34;id\u0026#34;:\u0026#34;90304950e52d679e\u0026#34;,\u0026#34;uid\u0026#34;:\u0026#34;4b25f66580c4dbf465a1b167c4c6967e987773442e5d47f0bee5db0a5e27a12d\u0026#34;,\u0026#34;name\u0026#34;:\u0026#34;php-redis\u0026#34;,\u0026#34;state\u0026#34;:\u0026#34;Success\u0026#34;,\u0026#34;kind\u0026#34;:\u0026#34;container\u0026#34;,\u0026#34;success\u0026#34;:true,\u0026#34;nodeName\u0026#34;:\u0026#34;cn-hangzhou.192.168.0.203\u0026#34;}]}} 可以登录容器访问 www.baidu.com 域名进行验证。\n销毁实验 blade destroy 6e46a5df94e0b065 常见问题 Q: {\u0026quot;code\u0026quot;:504,\u0026quot;success\u0026quot;:false,\u0026quot;error\u0026quot;:\u0026quot;unexpected status, the real value is Error\u0026quot;,\u0026quot;result\u0026quot;:{\u0026quot;uid\u0026quot;:\u0026quot;623841684347c05f\u0026quot;,\u0026quot;success\u0026quot;:false,\u0026quot;error\u0026quot;:\u0026quot;unexpected status, the real value is Error\u0026quot;,\u0026quot;statuses\u0026quot;:[{\u0026quot;uid\u0026quot;:\u0026quot;4b25f66580c4dbf465a1b167c4c6967e987773442e5d47f0bee5db0a5e27a12d\u0026quot;,\u0026quot;name\u0026quot;:\u0026quot;php-redis\u0026quot;,\u0026quot;state\u0026quot;:\u0026quot;Error\u0026quot;,\u0026quot;kind\u0026quot;:\u0026quot;container\u0026quot;,\u0026quot;error\u0026quot;:\u0026quot;10.0.0.1 www.baidu.com #chaosblade has been exist exit status 1\u0026quot;,\u0026quot;success\u0026quot;:false,\u0026quot;nodeName\u0026quot;:\u0026quot;cn-hangzhou.192.168.0.203\u0026quot;}]}}\nA: 所以实验已经存在\nkubectl 执行方式 yaml 的配置方式见：Kubernetes Container 域名访问异常场景\n","excerpt":"命令 支持的网络场景命令如下：\n blade create k8s container-network delay container 网络延迟场景，同 blade create network …","ref":"/docs/binaries/create/k8s/container/container-network/","title":"容器内网络实验场景"},{"body":"编译 此项目采用 golang 语言编写，所以需要先安装最新的 golang 版本，最低支持的版本是 1.11。Clone 工程后进入项目目录执行以下命令进行编译：\nmake 如果在 mac 系统上，编译当前系统的版本，请执行：\nmake build_darwin 如果想在 mac 系统上，编译 linux 系统版本，请执行：\nmake build_linux 也可以选择性编译，比如只需要编译 cli、os 场景，则执行：\nmake build_with cli os # 如果是 mac 系统，执行 make build_with cli os_darwin # 如果是 mac 系统，想选择性的编译 linux 版本的 cli，os，则执行： ARGS=\u0026#34;cli os\u0026#34; make build_with_linux ","excerpt":"编译 此项目采用 golang 语言编写，所以需要先安装最新的 golang 版本，最低支持的版本是 1.11。Clone 工程后进入项目目录执行以下命令进行编译：\nmake 如果在 mac 系统上， …","ref":"/contributing/dev/","title":"开发者人员指南"},{"body":"如果想不下载 chaosblade 工具包，快速体验 chaosblade，可以拉取 docker 镜像并运行，在容器内体验。\n操作步骤如下： 下载镜像：\ndocker pull chaosbladeio/chaosblade-demo 启动镜像：\ndocker run -it --privileged chaosbladeio/chaosblade-demo 进入镜像之后，可阅读 README.txt 文件实施混沌实验，Enjoy it。\n","excerpt":"如果想不下载 chaosblade 工具包，快速体验 chaosblade，可以拉取 docker 镜像并运行，在容器内体验。\n操作步骤如下： 下载镜像：\ndocker pull …","ref":"/docs/quickstart/demo/","title":"快速体验"},{"body":"","excerpt":"","ref":"/docs/quickstart/","title":"快速开始"},{"body":"此实验会挂起指定容器中的 redis-server 进程。\n参数    参数 类型 说明     process string 进程关键词，会在整个命令行中查找   process-cmd string 进程命令，只会在命令中查找   timeout string 设定运行时长，单位是秒，通用参数    配置文件 实验配置文件：stop_container_process_by_names.yaml\napiVersion:chaosblade.io/v1alpha1kind:ChaosBlademetadata:name:stop-container-process-by-idspec:experiments:- scope:containertarget:processaction:stopdesc:\u0026#34;kill container process by id\u0026#34;matchers:- name:container-idsvalue:- \u0026#34;bfc9ca01fac33f60d300485f96549644b634f274351df1d4897526451f49e3fb\u0026#34;- name:processvalue:[\u0026#34;redis-server\u0026#34;]- name:namesvalue:[\u0026#34;redis-slave-55d8c8ffbd-4pz8m\u0026#34;]- name:namespacevalue:[\u0026#34;chaosblade\u0026#34;]开始实验 选择一个节点，修改 stop_container_process_by_names.yaml 中的 names 值。\n执行命令，开始实验：\n$ kubectl apply -f stop_container_process_by_names.yaml 查看实验状态 执行 kubectl get blade stop-container-process-by-names -o json 命令，查看实验状态：\n{ \u0026#34;apiVersion\u0026#34;: \u0026#34;chaosblade.io/v1alpha1\u0026#34;, \u0026#34;kind\u0026#34;: \u0026#34;ChaosBlade\u0026#34;, \u0026#34;metadata\u0026#34;: { \u0026#34;annotations\u0026#34;: { \u0026#34;kubectl.kubernetes.io/last-applied-configuration\u0026#34;: \u0026#34;{\\\u0026#34;apiVersion\\\u0026#34;:\\\u0026#34;chaosblade.io/v1alpha1\\\u0026#34;,\\\u0026#34;kind\\\u0026#34;:\\\u0026#34;ChaosBlade\\\u0026#34;,\\\u0026#34;metadata\\\u0026#34;:{\\\u0026#34;annotations\\\u0026#34;:{},\\\u0026#34;name\\\u0026#34;:\\\u0026#34;kill-container-process-by-id\\\u0026#34;},\\\u0026#34;spec\\\u0026#34;:{\\\u0026#34;experiments\\\u0026#34;:[{\\\u0026#34;action\\\u0026#34;:\\\u0026#34;stop\\\u0026#34;,\\\u0026#34;desc\\\u0026#34;:\\\u0026#34;kill container process by id\\\u0026#34;,\\\u0026#34;matchers\\\u0026#34;:[{\\\u0026#34;name\\\u0026#34;:\\\u0026#34;container-ids\\\u0026#34;,\\\u0026#34;value\\\u0026#34;:[\\\u0026#34;bfc9ca01fac33f60d300485f96549644b634f274351df1d4897526451f49e3fb\\\u0026#34;]},{\\\u0026#34;name\\\u0026#34;:\\\u0026#34;process\\\u0026#34;,\\\u0026#34;value\\\u0026#34;:[\\\u0026#34;redis-server\\\u0026#34;]},{\\\u0026#34;name\\\u0026#34;:\\\u0026#34;names\\\u0026#34;,\\\u0026#34;value\\\u0026#34;:[\\\u0026#34;redis-slave-55d8c8ffbd-4pz8m\\\u0026#34;]},{\\\u0026#34;name\\\u0026#34;:\\\u0026#34;namespace\\\u0026#34;,\\\u0026#34;value\\\u0026#34;:[\\\u0026#34;chaosblade\\\u0026#34;]}],\\\u0026#34;scope\\\u0026#34;:\\\u0026#34;container\\\u0026#34;,\\\u0026#34;target\\\u0026#34;:\\\u0026#34;process\\\u0026#34;}]}}\\n\u0026#34; }, \u0026#34;creationTimestamp\u0026#34;: \u0026#34;2020-06-08T08:42:21Z\u0026#34;, \u0026#34;finalizers\u0026#34;: [ \u0026#34;finalizer.chaosblade.io\u0026#34; ], \u0026#34;generation\u0026#34;: 1, \u0026#34;name\u0026#34;: \u0026#34;kill-container-process-by-id\u0026#34;, \u0026#34;resourceVersion\u0026#34;: \u0026#34;1031383\u0026#34;, \u0026#34;selfLink\u0026#34;: \u0026#34;/apis/chaosblade.io/v1alpha1/chaosblades/kill-container-process-by-id\u0026#34;, \u0026#34;uid\u0026#34;: \u0026#34;39c45a2f-d0d1-4d01-affe-078ca08e9f82\u0026#34; }, \u0026#34;spec\u0026#34;: { \u0026#34;experiments\u0026#34;: [ { \u0026#34;action\u0026#34;: \u0026#34;stop\u0026#34;, \u0026#34;desc\u0026#34;: \u0026#34;kill container process by id\u0026#34;, \u0026#34;matchers\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;container-ids\u0026#34;, \u0026#34;value\u0026#34;: [ \u0026#34;bfc9ca01fac33f60d300485f96549644b634f274351df1d4897526451f49e3fb\u0026#34; ] }, { \u0026#34;name\u0026#34;: \u0026#34;process\u0026#34;, \u0026#34;value\u0026#34;: [ \u0026#34;redis-server\u0026#34; ] }, { \u0026#34;name\u0026#34;: \u0026#34;names\u0026#34;, \u0026#34;value\u0026#34;: [ \u0026#34;redis-slave-55d8c8ffbd-4pz8m\u0026#34; ] }, { \u0026#34;name\u0026#34;: \u0026#34;namespace\u0026#34;, \u0026#34;value\u0026#34;: [ \u0026#34;chaosblade\u0026#34; ] } ], \u0026#34;scope\u0026#34;: \u0026#34;container\u0026#34;, \u0026#34;target\u0026#34;: \u0026#34;process\u0026#34; } ] }, \u0026#34;status\u0026#34;: { \u0026#34;expStatuses\u0026#34;: [ { \u0026#34;action\u0026#34;: \u0026#34;stop\u0026#34;, \u0026#34;resStatuses\u0026#34;: [ { \u0026#34;id\u0026#34;: \u0026#34;19f8d915dce8c254\u0026#34;, \u0026#34;kind\u0026#34;: \u0026#34;container\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;redis-slave\u0026#34;, \u0026#34;nodeName\u0026#34;: \u0026#34;docker20\u0026#34;, \u0026#34;state\u0026#34;: \u0026#34;Success\u0026#34;, \u0026#34;success\u0026#34;: true, \u0026#34;uid\u0026#34;: \u0026#34;bfc9ca01fac33f60d300485f96549644b634f274351df1d4897526451f49e3fb\u0026#34; } ], \u0026#34;scope\u0026#34;: \u0026#34;container\u0026#34;, \u0026#34;state\u0026#34;: \u0026#34;Success\u0026#34;, \u0026#34;success\u0026#34;: true, \u0026#34;target\u0026#34;: \u0026#34;process\u0026#34; } ], \u0026#34;phase\u0026#34;: \u0026#34;Running\u0026#34; } } 观测结果 # 进入实验 pod $ kubectl exec -it redis-slave-55d8c8ffbd-4pz8m bash # 查看 redis-server 进程号 $ ps aux| grep redis-server root 5632 0.0 0.0 41520 4168 ? Tl 06:28 0:06 redis-server *:6379 可以看到 redis-server 此刻进程处于暂停状态了（T）。\n停止实验 执行命令：kubectl delete -f stop_container_process_by_names.yaml\n或者直接删除 blade 资源：kubectl delete blade stop-container-process-by-names\n","excerpt":"此实验会挂起指定容器中的 redis-server 进程。\n参数    参数 类型 说明     process string 进程关键词，会在整个命令行中查找   process-cmd …","ref":"/docs/operator/container/container-process/stop_container_process/","title":"挂起指定进程场景"},{"body":"此实验会挂起指定节点上的 redis-server 进程。\n参数    参数 类型 说明     process string 进程关键词，会在整个命令行中查找   process-cmd string 进程命令，只会在命令中查找   timeout string 设定运行时长，单位是秒，通用参数    配置文件 实验配置文件：stop_node_process_by_names.yaml\napiVersion:chaosblade.io/v1alpha1kind:ChaosBlademetadata:name:stop-node-process-by-namesspec:experiments:- scope:nodetarget:processaction:stopdesc:\u0026#34;kill node process by names\u0026#34;matchers:- name:namesvalue:[\u0026#34;docker20\u0026#34;]- name:processvalue:[\u0026#34;redis-server\u0026#34;]开始实验 选择一个节点，修改 stop_node_process_by_names.yaml 中的 names 值。\n执行命令，开始实验：\n$ kubectl apply -f stop_node_process_by_names.yaml 查看实验状态 执行 kubectl get blade stop-node-process-by-names -o json 命令，查看实验状态：\n{ \u0026#34;apiVersion\u0026#34;: \u0026#34;chaosblade.io/v1alpha1\u0026#34;, \u0026#34;kind\u0026#34;: \u0026#34;ChaosBlade\u0026#34;, \u0026#34;metadata\u0026#34;: { \u0026#34;annotations\u0026#34;: { \u0026#34;kubectl.kubernetes.io/last-applied-configuration\u0026#34;: \u0026#34;{\\\u0026#34;apiVersion\\\u0026#34;:\\\u0026#34;chaosblade.io/v1alpha1\\\u0026#34;,\\\u0026#34;kind\\\u0026#34;:\\\u0026#34;ChaosBlade\\\u0026#34;,\\\u0026#34;metadata\\\u0026#34;:{\\\u0026#34;annotations\\\u0026#34;:{},\\\u0026#34;name\\\u0026#34;:\\\u0026#34;stop-node-process-by-names\\\u0026#34;},\\\u0026#34;spec\\\u0026#34;:{\\\u0026#34;experiments\\\u0026#34;:[{\\\u0026#34;action\\\u0026#34;:\\\u0026#34;stop\\\u0026#34;,\\\u0026#34;desc\\\u0026#34;:\\\u0026#34;kill node process by names\\\u0026#34;,\\\u0026#34;matchers\\\u0026#34;:[{\\\u0026#34;name\\\u0026#34;:\\\u0026#34;names\\\u0026#34;,\\\u0026#34;value\\\u0026#34;:[\\\u0026#34;docker20\\\u0026#34;]},{\\\u0026#34;name\\\u0026#34;:\\\u0026#34;process\\\u0026#34;,\\\u0026#34;value\\\u0026#34;:[\\\u0026#34;redis-server\\\u0026#34;]}],\\\u0026#34;scope\\\u0026#34;:\\\u0026#34;node\\\u0026#34;,\\\u0026#34;target\\\u0026#34;:\\\u0026#34;process\\\u0026#34;}]}}\\n\u0026#34; }, \u0026#34;creationTimestamp\u0026#34;: \u0026#34;2020-06-08T08:20:36Z\u0026#34;, \u0026#34;finalizers\u0026#34;: [ \u0026#34;finalizer.chaosblade.io\u0026#34; ], \u0026#34;generation\u0026#34;: 1, \u0026#34;name\u0026#34;: \u0026#34;stop-node-process-by-names\u0026#34;, \u0026#34;resourceVersion\u0026#34;: \u0026#34;1028075\u0026#34;, \u0026#34;selfLink\u0026#34;: \u0026#34;/apis/chaosblade.io/v1alpha1/chaosblades/stop-node-process-by-names\u0026#34;, \u0026#34;uid\u0026#34;: \u0026#34;40ebc6e6-4e2f-45dc-9a62-dc60527a1f4f\u0026#34; }, \u0026#34;spec\u0026#34;: { \u0026#34;experiments\u0026#34;: [ { \u0026#34;action\u0026#34;: \u0026#34;stop\u0026#34;, \u0026#34;desc\u0026#34;: \u0026#34;kill node process by names\u0026#34;, \u0026#34;matchers\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;names\u0026#34;, \u0026#34;value\u0026#34;: [ \u0026#34;docker20\u0026#34; ] }, { \u0026#34;name\u0026#34;: \u0026#34;process\u0026#34;, \u0026#34;value\u0026#34;: [ \u0026#34;redis-server\u0026#34; ] } ], \u0026#34;scope\u0026#34;: \u0026#34;node\u0026#34;, \u0026#34;target\u0026#34;: \u0026#34;process\u0026#34; } ] }, \u0026#34;status\u0026#34;: { \u0026#34;expStatuses\u0026#34;: [ { \u0026#34;action\u0026#34;: \u0026#34;stop\u0026#34;, \u0026#34;resStatuses\u0026#34;: [ { \u0026#34;id\u0026#34;: \u0026#34;e71f0902c13f2de1\u0026#34;, \u0026#34;kind\u0026#34;: \u0026#34;node\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;docker20\u0026#34;, \u0026#34;nodeName\u0026#34;: \u0026#34;docker20\u0026#34;, \u0026#34;state\u0026#34;: \u0026#34;Success\u0026#34;, \u0026#34;success\u0026#34;: true, \u0026#34;uid\u0026#34;: \u0026#34;51d4553b-8da2-46ab-9b3d-51a11ae6d06f\u0026#34; } ], \u0026#34;scope\u0026#34;: \u0026#34;node\u0026#34;, \u0026#34;state\u0026#34;: \u0026#34;Success\u0026#34;, \u0026#34;success\u0026#34;: true, \u0026#34;target\u0026#34;: \u0026#34;process\u0026#34; } ], \u0026#34;phase\u0026#34;: \u0026#34;Running\u0026#34; } } 观测结果 # 进入实验 node $ ssh kk@192.168.1.129 # 查看 redis-server 进程号 $ ps aux| grep redis-server root 5632 0.0 0.0 41520 4168 ? Tl 06:28 0:06 redis-server *:6379 可以看到 redis-server 此刻进程处于暂停状态了（T）。\n停止实验 执行命令：kubectl delete -f stop_node_process_by_names.yaml\n或者直接删除 blade 资源：kubectl delete blade stop-node-process-by-names\n","excerpt":"此实验会挂起指定节点上的 redis-server 进程。\n参数    参数 类型 说明     process string 进程关键词，会在整个命令行中查找   process-cmd …","ref":"/docs/operator/node/node-process/stop_node_process/","title":"挂起点上指定进程"},{"body":"参数 以下是此场景特有参数，通用参数详见：blade create jvm\n--effect-count string 影响的请求条数 --effect-percent string 影响的请求百分比 --value string 返回指定值，仅支持基本类型和字符串类型，如果想返回 null，可以设置为 --value null 。必选项 案例 指定 com.example.controller.DubboController 类，下面业务方法返回 \u0026ldquo;hello-chaosblade\u0026rdquo;\n@RequestMapping(value = \u0026#34;hello\u0026#34;) @ResponseBody public String hello(String name, int code) { if (name == null) { name = \u0026#34;friend\u0026#34;; } StringBuilder result = null; try { result = new StringBuilder(sayHello(name)); } catch (Exception e) { return e.getMessage() + \u0026#34;\\n\u0026#34;; } return result.toString() + \u0026#34;\\n\u0026#34;; } 故障注入命令如下：\nblade c jvm return --value hello-chaosblade --classname com.example.controller.DubboController --methodname hello --process tomcat 故障注入之前：\n故障注入之后：\n停止实验：\nblade d d31e24dea782a275 上述代码调用 sayHello 方法，我们对 sayHello 方法注入返回 null 故障，sayHello 方法如下：\nprivate String sayHello(String name) throws BeansException { demoService = (DemoService)SpringContextUtil.getBean(\u0026#34;demoService\u0026#34;); StringBuilder result = new StringBuilder(); result.append(demoService.sayHello(name)); return result.toString(); } 执行以下命令：\nblade c jvm return --value null --classname com.example.controller.DubboController --methodname sayHello --process tomcat 故障注入之后：\n","excerpt":"参数 以下是此场景特有参数，通用参数详见：blade create jvm\n--effect-count string 影响的请求条数 --effect-percent string …","ref":"/docs/binaries/create/java/jvm/jvm-return/","title":"指定类方法的返回值"},{"body":"","excerpt":"","ref":"/docs/","title":"文档"},{"body":"介绍 此实验会暂停进程。支持命令行或者命令中进程匹配。\n此实验可以验证程序 Hang 时，系统的容错能力。\n参数 --process string 进程关键词，会在整个命令行中查找 --process-cmd string 进程命令，只会在命令中查找 --timeout string 设定运行时长，单位是秒，通用参数 案例 # 暂停包含 SimpleHTTPServer 关键词的进程 blade create process stop --process SimpleHTTPServer # 暂停 java 进程 blade create process stop --process-cmd java 实现原理 --process 内部使用 ps -ef | grep KEY 查找；--process-cmd 内部使用 pgrep 命令查找。\n使用 kill -STOP PIDS 暂停进程，使用 kill -CONT PIDS 恢复进程。\n常见错误 Q：查找不到 UID，无法恢复暂停的进程\nA：手动执行 kill -CONT PIDS\n","excerpt":"介绍 此实验会暂停进程。支持命令行或者命令中进程匹配。\n此实验可以验证程序 Hang 时，系统的容错能力。\n参数 --process string 进程关键词， …","ref":"/docs/binaries/create/process/process-stop/","title":"暂停进程"},{"body":"","excerpt":"","ref":"/docs/binaries/create/disk/","title":"磁盘场景"},{"body":"介绍 提升磁盘读写 io 负载，可以指定受影响的目录，也可以通过调整读写的块大小提升 io 负载，默认值是 10，单位是 M，块的数量固定为 100，即在默认情况下，写会占用 1G 的磁盘空间，读会固定占用 600M 的空间，因为读操作会先创建一个 600M 的固定大小文件，预计 3s之内，在创建时写 io 会升高。\n验证磁盘 io 高负载下对系统服务的影响，比如监控告警、服务稳定性等。\n参数 --path string 指定提升磁盘 io 的目录，会作用于其所在的磁盘上，默认值是 / --read 触发提升磁盘读 IO 负载，会创建 600M 的文件用于读，销毁实验会自动删除 --size string 块大小, 单位是 M, 默认值是 10，一般不需要修改，除非想更大的提高 io 负载 --timeout string 设定运行时长，单位是秒，通用参数 --write 触发提升磁盘写 IO 负载，会根据块大小的值来写入一个文件，比如块大小是 10，则固定的块的数量是 100，则会创建 1000M 的文件，销毁实验会自动删除 案例 # 在执行实验之前可先观察磁盘 io 读写负载 iostat -x -t 2 # 上述命令会 2 秒刷新一次读写负载数据，截取结果如下 Device: rrqm/s wrqm/s r/s w/s rkB/s wkB/s avgrq-sz avgqu-sz await r_await w_await svctm %util vda 0.00 2.50 0.00 2.00 0.00 18.00 18.00 0.00 1.25 0.00 1.25 1.25 0.25 # 主要观察 rkB/s、wkB/s、%util 数据。执行磁盘读 IO 负载高场景 blade create disk burn --read --path /home # 执行 iostat 命令可以看到读负载增大，使用率达 99.9%。执行 blade destroy UID(上述执行实验返回的 result 值)可销毁实验。 Device: rrqm/s wrqm/s r/s w/s rkB/s wkB/s avgrq-sz avgqu-sz await r_await w_await svctm %util vda 0.00 3.00 223.00 2.00 108512.00 20.00 964.73 11.45 50.82 51.19 10.00 4.44 99.90 # 销毁上述实验后，执行磁盘写 IO 负载高场景 blade create disk burn --write --path /home # 执行 iostat 命令可以看到写负载增大，使用率达 90.10%。 Device: rrqm/s wrqm/s r/s w/s rkB/s wkB/s avgrq-sz avgqu-sz await r_await w_await svctm %util vda 0.00 43.00 0.00 260.00 0.00 111572.00 858.25 15.36 59.71 0.00 59.71 3.47 90.10 # 可同时执行读写 IO 负载场景，不指定 path，默认值是 / blade create disk burn --read --write # 通过 iostat 命令可以看到，整个磁盘的 io 使用率达到了 100% Device: rrqm/s wrqm/s r/s w/s rkB/s wkB/s avgrq-sz avgqu-sz await r_await w_await svctm %util vda 0.00 36.00 229.50 252.50 108512.00 107750.00 897.35 30.09 62.70 53.49 71.07 2.07 100.00 实现原理 使用 dd 命令实现\n常见问题 ","excerpt":"介绍 提升磁盘读写 io 负载，可以指定受影响的目录，也可以通过调整读写的块大小提升 io 负载，默认值是 10，单位是 M，块的数量固定为 100，即在默认情况下，写会占用 1G 的磁盘空间，读会固 …","ref":"/docs/binaries/create/disk/disk-burn/","title":"磁盘读写 io 负载实验"},{"body":"对 chaosblade 命名空间中，对 redis-master-68857cd57c-hknb6 Pod 中 container id 是 02655dfdd9f0f712a10d63fdc6721f4dcee0a390e37717fff068bf3f85abf85e 的容器注入丢包率 100% 的故障，只针对 IP 为 10.42.0.26 的 pod 生效，也就是除 10.42.0.26 以外的 pod 都能正常访问 redis-master-68857cd57c-hknb6。\n实验参数    参数 类型 说明     destination-ip string 目标 IP. 支持通过子网掩码来指定一个网段的IP地址, 例如 192.168.1.0/24. 则 192.168.1.0~192.168.1.255 都生效。你也可以指定固定的 IP，如 192.168.1.1 或者 192.168.1.1/32，也可以通过都号分隔多个参数，例如 192.168.1.1,192.168.2.1。   exclude-port string 排除掉的端口，默认会忽略掉通信的对端端口，目的是保留通信可用。可以指定多个，使用逗号分隔或者连接符表示范围，例如 22,8000 或者 8000-8010。 这个参数不能与 \u0026ndash;local-port 或者 \u0026ndash;remote-port 参数一起使用。   exclude-ip string 排除受影响的 IP，支持通过子网掩码来指定一个网段的IP地址, 例如 192.168.1.0/24. 则 192.168.1.0~192.168.1.255 都生效。你也可以指定固定的 IP，如 192.168.1.1 或者 192.168.1.1/32，也可以通过都号分隔多个参数，例如 192.168.1.1,192.168.2.1。   interface string 网卡设备，例如 eth0 (必要参数)。   local-port string 本地端口，一般是本机暴露服务的端口。可以指定多个，使用逗号分隔或者连接符表示范围，例如 80,8000-8080。   percent string 丢包百分比，取值在[0, 100]的正整数 (必要参数)。   remote-port string 远程端口，一般是要访问的外部暴露服务的端口。可以指定多个，使用逗号分隔或者连接符表示范围，例如 80,8000-8080。   force  强制覆盖已有的 tc 规则，请务必在明确之前的规则可覆盖的情况下使用。   ignore-peer-port  针对添加 \u0026ndash;exclude-port 参数，报 ss 命令找不到的情况下使用，忽略排除端口。   timeout string 设定运行时长，单位是秒，通用参数。    配置文件 实验配置文件：loss_container_network_by_id.yaml\napiVersion:chaosblade.io/v1alpha1kind:ChaosBlademetadata:name:loss-container-network-by-idspec:experiments:- scope:containertarget:networkaction:lossdesc:\u0026#34;loss container network by container id\u0026#34;matchers:- name:container-idsvalue:- \u0026#34;02655dfdd9f0f712a10d63fdc6721f4dcee0a390e37717fff068bf3f85abf85e\u0026#34;- name:namesvalue:- \u0026#34;redis-master-68857cd57c-hknb6\u0026#34;- name:namespacevalue:- \u0026#34;chaosblade\u0026#34;- name:interfacevalue:[\u0026#34;eth0\u0026#34;]- name:percentvalue:[\u0026#34;100\u0026#34;]- name:timeoutvalue:[\u0026#34;60\u0026#34;]- name:destination-ipvalue:[\u0026#34;10.42.0.26\u0026#34;]开始实验 获取 pod 名称和 container id 内容同上。\n执行命令，开始实验：\n$ kubectl apply -f loss_container_network_by_id.yaml 查看实验状态 执行 kubectl get blade loss-container-network-by-id -o json 命令，查看实验状态：\n{ \u0026#34;apiVersion\u0026#34;: \u0026#34;chaosblade.io/v1alpha1\u0026#34;, \u0026#34;kind\u0026#34;: \u0026#34;ChaosBlade\u0026#34;, \u0026#34;metadata\u0026#34;: { \u0026#34;annotations\u0026#34;: { \u0026#34;kubectl.kubernetes.io/last-applied-configuration\u0026#34;: \u0026#34;{\\\u0026#34;apiVersion\\\u0026#34;:\\\u0026#34;chaosblade.io/v1alpha1\\\u0026#34;,\\\u0026#34;kind\\\u0026#34;:\\\u0026#34;ChaosBlade\\\u0026#34;,\\\u0026#34;metadata\\\u0026#34;:{\\\u0026#34;annotations\\\u0026#34;:{},\\\u0026#34;name\\\u0026#34;:\\\u0026#34;loss-container-network-by-id\\\u0026#34;},\\\u0026#34;spec\\\u0026#34;:{\\\u0026#34;experiments\\\u0026#34;:[{\\\u0026#34;action\\\u0026#34;:\\\u0026#34;loss\\\u0026#34;,\\\u0026#34;desc\\\u0026#34;:\\\u0026#34;loss container network by container id\\\u0026#34;,\\\u0026#34;matchers\\\u0026#34;:[{\\\u0026#34;name\\\u0026#34;:\\\u0026#34;container-ids\\\u0026#34;,\\\u0026#34;value\\\u0026#34;:[\\\u0026#34;02655dfdd9f0f712a10d63fdc6721f4dcee0a390e37717fff068bf3f85abf85e\\\u0026#34;]},{\\\u0026#34;name\\\u0026#34;:\\\u0026#34;names\\\u0026#34;,\\\u0026#34;value\\\u0026#34;:[\\\u0026#34;redis-master-68857cd57c-hknb6\\\u0026#34;]},{\\\u0026#34;name\\\u0026#34;:\\\u0026#34;namespace\\\u0026#34;,\\\u0026#34;value\\\u0026#34;:[\\\u0026#34;chaosblade\\\u0026#34;]},{\\\u0026#34;name\\\u0026#34;:\\\u0026#34;interface\\\u0026#34;,\\\u0026#34;value\\\u0026#34;:[\\\u0026#34;eth0\\\u0026#34;]},{\\\u0026#34;name\\\u0026#34;:\\\u0026#34;percent\\\u0026#34;,\\\u0026#34;value\\\u0026#34;:[\\\u0026#34;100\\\u0026#34;]},{\\\u0026#34;name\\\u0026#34;:\\\u0026#34;timeout\\\u0026#34;,\\\u0026#34;value\\\u0026#34;:[\\\u0026#34;60\\\u0026#34;]},{\\\u0026#34;name\\\u0026#34;:\\\u0026#34;destination-ip\\\u0026#34;,\\\u0026#34;value\\\u0026#34;:[\\\u0026#34;10.42.0.26\\\u0026#34;]}],\\\u0026#34;scope\\\u0026#34;:\\\u0026#34;container\\\u0026#34;,\\\u0026#34;target\\\u0026#34;:\\\u0026#34;network\\\u0026#34;}]}}\\n\u0026#34; }, \u0026#34;creationTimestamp\u0026#34;: \u0026#34;2020-06-04T07:41:37Z\u0026#34;, \u0026#34;deletionGracePeriodSeconds\u0026#34;: 0, \u0026#34;deletionTimestamp\u0026#34;: \u0026#34;2020-06-04T07:42:50Z\u0026#34;, \u0026#34;finalizers\u0026#34;: [ \u0026#34;finalizer.chaosblade.io\u0026#34; ], \u0026#34;generation\u0026#34;: 2, \u0026#34;name\u0026#34;: \u0026#34;loss-container-network-by-id\u0026#34;, \u0026#34;resourceVersion\u0026#34;: \u0026#34;180856\u0026#34;, \u0026#34;selfLink\u0026#34;: \u0026#34;/apis/chaosblade.io/v1alpha1/chaosblades/loss-container-network-by-id\u0026#34;, \u0026#34;uid\u0026#34;: \u0026#34;d64873ae-3956-4660-9e35-27241bd48fa4\u0026#34; }, \u0026#34;spec\u0026#34;: { \u0026#34;experiments\u0026#34;: [ { \u0026#34;action\u0026#34;: \u0026#34;loss\u0026#34;, \u0026#34;desc\u0026#34;: \u0026#34;loss container network by container id\u0026#34;, \u0026#34;matchers\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;container-ids\u0026#34;, \u0026#34;value\u0026#34;: [ \u0026#34;02655dfdd9f0f712a10d63fdc6721f4dcee0a390e37717fff068bf3f85abf85e\u0026#34; ] }, { \u0026#34;name\u0026#34;: \u0026#34;names\u0026#34;, \u0026#34;value\u0026#34;: [ \u0026#34;redis-master-68857cd57c-hknb6\u0026#34; ] }, { \u0026#34;name\u0026#34;: \u0026#34;namespace\u0026#34;, \u0026#34;value\u0026#34;: [ \u0026#34;chaosblade\u0026#34; ] }, { \u0026#34;name\u0026#34;: \u0026#34;interface\u0026#34;, \u0026#34;value\u0026#34;: [ \u0026#34;eth0\u0026#34; ] }, { \u0026#34;name\u0026#34;: \u0026#34;percent\u0026#34;, \u0026#34;value\u0026#34;: [ \u0026#34;100\u0026#34; ] }, { \u0026#34;name\u0026#34;: \u0026#34;timeout\u0026#34;, \u0026#34;value\u0026#34;: [ \u0026#34;60\u0026#34; ] }, { \u0026#34;name\u0026#34;: \u0026#34;destination-ip\u0026#34;, \u0026#34;value\u0026#34;: [ \u0026#34;10.42.0.26\u0026#34; ] } ], \u0026#34;scope\u0026#34;: \u0026#34;container\u0026#34;, \u0026#34;target\u0026#34;: \u0026#34;network\u0026#34; } ] }, \u0026#34;status\u0026#34;: { \u0026#34;expStatuses\u0026#34;: [ { \u0026#34;action\u0026#34;: \u0026#34;loss\u0026#34;, \u0026#34;resStatuses\u0026#34;: [ { \u0026#34;id\u0026#34;: \u0026#34;8ad94f6be81dec80\u0026#34;, \u0026#34;kind\u0026#34;: \u0026#34;container\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;redis-master\u0026#34;, \u0026#34;nodeName\u0026#34;: \u0026#34;keking\u0026#34;, \u0026#34;state\u0026#34;: \u0026#34;Success\u0026#34;, \u0026#34;success\u0026#34;: true, \u0026#34;uid\u0026#34;: \u0026#34;02655dfdd9f0f712a10d63fdc6721f4dcee0a390e37717fff068bf3f85abf85e\u0026#34; } ], \u0026#34;scope\u0026#34;: \u0026#34;container\u0026#34;, \u0026#34;state\u0026#34;: \u0026#34;Success\u0026#34;, \u0026#34;success\u0026#34;: true, \u0026#34;target\u0026#34;: \u0026#34;network\u0026#34; } ], \u0026#34;phase\u0026#34;: \u0026#34;Running\u0026#34; } } 观测结果 # 获取实验 pod ip $ kubectl get pod -l app=redis,role=master -o jsonpath={.items..status.podIP} 10.42.0.19 # 进入观测 pod，IP为：10.42.0.26（被设置丢包率 100%） $ kubectl exec -it redis-slave-55d8c8ffbd-jd8sm bash # Ping 实验Pod ip $ ping 10.42.0.19 PING 10.42.0.19 (10.42.0.19) 56(84) bytes of data. # 无响应 # 进入观测 pod，该 pod 未被指定丢包 $ kubectl exec -it redis-slave-55d8c8ffbd-22tsc bash # Ping 实验Pod ip $ ping 10.42.0.19 PING 10.42.0.19 (10.42.0.19) 56(84) bytes of data. 64 bytes from 10.42.0.19: icmp_seq=1 ttl=64 time=0.065 ms 64 bytes from 10.42.0.19: icmp_seq=2 ttl=64 time=0.051 ms 64 bytes from 10.42.0.19: icmp_seq=3 ttl=64 time=0.078 ms ... # 响应正常 这里在配置中还将 timeout 设置为 60 秒，60 秒后 100% 丢包的情况将会消失，这个配置是为了防止因丢包率设置太高，造成机器无法连接的情况。与其有相似功能的还有 exclude-port，该配置用来指定排除掉的丢包端口。\n 停止实验 执行命令：kubectl apply -f loss_container_network_by_id.yaml\n或者直接删除 blade 资源：kubectl delete blade loss-container-network-by-id\n","excerpt":"对 chaosblade 命名空间中，对 redis-master-68857cd57c-hknb6 Pod 中 container id …","ref":"/docs/operator/container/container-network/loss_container_network/","title":"网络丢包场景"},{"body":" 实验前，请先登录 node 节点，使用 ifconfig 命令查看网卡信息，不是所有系统默认的网卡名称都是 eth0。\n docker20 节点的 32436 端口注入丢包率 100% 的故障。\n参数    参数 类型 说明     destination-ip string 目标 IP. 支持通过子网掩码来指定一个网段的IP地址, 例如 192.168.1.0/24. 则 192.168.1.0~192.168.1.255 都生效。你也可以指定固定的 IP，如 192.168.1.1 或者 192.168.1.1/32，也可以通过都号分隔多个参数，例如 192.168.1.1,192.168.2.1。   exclude-port string 排除掉的端口，默认会忽略掉通信的对端端口，目的是保留通信可用。可以指定多个，使用逗号分隔或者连接符表示范围，例如 22,8000 或者 8000-8010。 这个参数不能与 \u0026ndash;local-port 或者 \u0026ndash;remote-port 参数一起使用。   exclude-ip string 排除受影响的 IP，支持通过子网掩码来指定一个网段的IP地址, 例如 192.168.1.0/24. 则 192.168.1.0~192.168.1.255 都生效。你也可以指定固定的 IP，如 192.168.1.1 或者 192.168.1.1/32，也可以通过都号分隔多个参数，例如 192.168.1.1,192.168.2.1。   interface string 网卡设备，例如 eth0 (必要参数)。   local-port string 本地端口，一般是本机暴露服务的端口。可以指定多个，使用逗号分隔或者连接符表示范围，例如 80,8000-8080。   percent string 丢包百分比，取值在[0, 100]的正整数 (必要参数)。   remote-port string 远程端口，一般是要访问的外部暴露服务的端口。可以指定多个，使用逗号分隔或者连接符表示范围，例如 80,8000-8080。   force  强制覆盖已有的 tc 规则，请务必在明确之前的规则可覆盖的情况下使用。   ignore-peer-port  针对添加 \u0026ndash;exclude-port 参数，报 ss 命令找不到的情况下使用，忽略排除端口。   timeout string 设定运行时长，单位是秒，通用参数。    配置文件 实验配置文件：loss_node_network_by_names.yaml\napiVersion:chaosblade.io/v1alpha1kind:ChaosBlademetadata:name:loss-node-network-by-namesspec:experiments:- scope:nodetarget:networkaction:lossdesc:\u0026#34;node network loss\u0026#34;matchers:- name:namesvalue:[\u0026#34;docker20\u0026#34;]- name:percentvalue:[\u0026#34;100\u0026#34;]- name:interfacevalue:[\u0026#34;ens33\u0026#34;]- name:local-portvalue:[\u0026#34;32436\u0026#34;]开始实验 选择一个节点，修改 loss_node_network_by_names.yaml 中的 names 值。\n执行命令，开始实验：\n$ kubectl apply -f loss_node_network_by_names.yaml 查看实验状态 执行 kubectl get blade loss-node-network-by-names -o json 命令，查看实验状态：\n{ \u0026#34;apiVersion\u0026#34;: \u0026#34;chaosblade.io/v1alpha1\u0026#34;, \u0026#34;kind\u0026#34;: \u0026#34;ChaosBlade\u0026#34;, \u0026#34;metadata\u0026#34;: { \u0026#34;annotations\u0026#34;: { \u0026#34;kubectl.kubernetes.io/last-applied-configuration\u0026#34;: \u0026#34;{\\\u0026#34;apiVersion\\\u0026#34;:\\\u0026#34;chaosblade.io/v1alpha1\\\u0026#34;,\\\u0026#34;kind\\\u0026#34;:\\\u0026#34;ChaosBlade\\\u0026#34;,\\\u0026#34;metadata\\\u0026#34;:{\\\u0026#34;annotations\\\u0026#34;:{},\\\u0026#34;name\\\u0026#34;:\\\u0026#34;loss-node-network-by-names\\\u0026#34;},\\\u0026#34;spec\\\u0026#34;:{\\\u0026#34;experiments\\\u0026#34;:[{\\\u0026#34;action\\\u0026#34;:\\\u0026#34;loss\\\u0026#34;,\\\u0026#34;desc\\\u0026#34;:\\\u0026#34;node network loss\\\u0026#34;,\\\u0026#34;matchers\\\u0026#34;:[{\\\u0026#34;name\\\u0026#34;:\\\u0026#34;names\\\u0026#34;,\\\u0026#34;value\\\u0026#34;:[\\\u0026#34;docker20\\\u0026#34;]},{\\\u0026#34;name\\\u0026#34;:\\\u0026#34;percent\\\u0026#34;,\\\u0026#34;value\\\u0026#34;:[\\\u0026#34;100\\\u0026#34;]},{\\\u0026#34;name\\\u0026#34;:\\\u0026#34;interface\\\u0026#34;,\\\u0026#34;value\\\u0026#34;:[\\\u0026#34;ens33\\\u0026#34;]},{\\\u0026#34;name\\\u0026#34;:\\\u0026#34;local-port\\\u0026#34;,\\\u0026#34;value\\\u0026#34;:[\\\u0026#34;32436\\\u0026#34;]}],\\\u0026#34;scope\\\u0026#34;:\\\u0026#34;node\\\u0026#34;,\\\u0026#34;target\\\u0026#34;:\\\u0026#34;network\\\u0026#34;}]}}\\n\u0026#34; }, \u0026#34;creationTimestamp\u0026#34;: \u0026#34;2020-06-08T02:41:56Z\u0026#34;, \u0026#34;finalizers\u0026#34;: [ \u0026#34;finalizer.chaosblade.io\u0026#34; ], \u0026#34;generation\u0026#34;: 1, \u0026#34;name\u0026#34;: \u0026#34;loss-node-network-by-names\u0026#34;, \u0026#34;resourceVersion\u0026#34;: \u0026#34;978403\u0026#34;, \u0026#34;selfLink\u0026#34;: \u0026#34;/apis/chaosblade.io/v1alpha1/chaosblades/loss-node-network-by-names\u0026#34;, \u0026#34;uid\u0026#34;: \u0026#34;5322e39a-a0ab-4521-a931-e57040344076\u0026#34; }, \u0026#34;spec\u0026#34;: { \u0026#34;experiments\u0026#34;: [ { \u0026#34;action\u0026#34;: \u0026#34;loss\u0026#34;, \u0026#34;desc\u0026#34;: \u0026#34;node network loss\u0026#34;, \u0026#34;matchers\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;names\u0026#34;, \u0026#34;value\u0026#34;: [ \u0026#34;docker20\u0026#34; ] }, { \u0026#34;name\u0026#34;: \u0026#34;percent\u0026#34;, \u0026#34;value\u0026#34;: [ \u0026#34;100\u0026#34; ] }, { \u0026#34;name\u0026#34;: \u0026#34;interface\u0026#34;, \u0026#34;value\u0026#34;: [ \u0026#34;ens33\u0026#34; ] }, { \u0026#34;name\u0026#34;: \u0026#34;local-port\u0026#34;, \u0026#34;value\u0026#34;: [ \u0026#34;32436\u0026#34; ] } ], \u0026#34;scope\u0026#34;: \u0026#34;node\u0026#34;, \u0026#34;target\u0026#34;: \u0026#34;network\u0026#34; } ] }, \u0026#34;status\u0026#34;: { \u0026#34;expStatuses\u0026#34;: [ { \u0026#34;action\u0026#34;: \u0026#34;loss\u0026#34;, \u0026#34;resStatuses\u0026#34;: [ { \u0026#34;id\u0026#34;: \u0026#34;b93929d018091e18\u0026#34;, \u0026#34;kind\u0026#34;: \u0026#34;node\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;docker20\u0026#34;, \u0026#34;nodeName\u0026#34;: \u0026#34;docker20\u0026#34;, \u0026#34;state\u0026#34;: \u0026#34;Success\u0026#34;, \u0026#34;success\u0026#34;: true, \u0026#34;uid\u0026#34;: \u0026#34;51d4553b-8da2-46ab-9b3d-51a11ae6d06f\u0026#34; } ], \u0026#34;scope\u0026#34;: \u0026#34;node\u0026#34;, \u0026#34;state\u0026#34;: \u0026#34;Success\u0026#34;, \u0026#34;success\u0026#34;: true, \u0026#34;target\u0026#34;: \u0026#34;network\u0026#34; } ], \u0026#34;phase\u0026#34;: \u0026#34;Running\u0026#34; } } 观测结果 该端口为 Guestbook nodeport 的端口，访问实验端口无响应，但是访问未开启实验的端口可以正常使用\n# 获取节点 IP $ kubectl get node -o wide NAME STATUS ROLES AGE VERSION INTERNAL-IP EXTERNAL-IP OS-IMAGE KERNEL-VERSION CONTAINER-RUNTIME docker20 Ready worker 3d16h v1.17.6 192.168.1.129 \u0026lt;none\u0026gt; Ubuntu 18.04.4 LTS 4.15.0-101-generic docker://19.3.11 kk Ready controlplane,etcd,worker 4d16h v1.17.6 192.168.4.210 \u0026lt;none\u0026gt; Ubuntu 18.04.4 LTS 4.15.0-101-generic docker://19.3.11 # 从实验节点访问 Guestbook - 无法访问 $ telnet 192.168.1.129 32436 Trying 192.168.1.129... telnet: connect to address 192.168.1.129: Operation timed out telnet: Unable to connect to remote host # 从非实验节点访问 Guestbook - 正常访问 $ telnet 192.168.4.210 32436 Trying 192.168.4.210... Connected to 192.168.4.210. Escape character is \u0026#39;^]\u0026#39;. 同样也可以直接从浏览器访问地址，验证实验。\n停止实验 执行命令：kubectl delete -f loss_node_network_by_names.yaml\n或者直接删除 blade 资源：kubectl delete blade loss-node-network-by-names\n","excerpt":"实验前，请先登录 node 节点，使用 ifconfig 命令查看网卡信息，不是所有系统默认的网卡名称都是 eth0。\n docker20 节点的 32436 端口注入丢包率 100% 的故障。 …","ref":"/docs/operator/node/node-network/loss_node_network/","title":"网络丢包场景"},{"body":"在 chaosblade 命名空间中，对 redis-master-68857cd57c-dzbs9 Pod 注入丢包率 100% 的故障，只针对 IP 为 10.42.69.42 的 pod 生效，也就是除 10.42.69.42 以外的 pod 都能正常访问 redis-master-68857cd57c-dzbs9。\n参数    参数 类型 说明     destination-ip string 目标 IP. 支持通过子网掩码来指定一个网段的IP地址, 例如 192.168.1.0/24. 则 192.168.1.0~192.168.1.255 都生效。你也可以指定固定的 IP，如 192.168.1.1 或者 192.168.1.1/32，也可以通过都号分隔多个参数，例如 192.168.1.1,192.168.2.1。   exclude-port string 排除掉的端口，默认会忽略掉通信的对端端口，目的是保留通信可用。可以指定多个，使用逗号分隔或者连接符表示范围，例如 22,8000 或者 8000-8010。 这个参数不能与 \u0026ndash;local-port 或者 \u0026ndash;remote-port 参数一起使用。   exclude-ip string 排除受影响的 IP，支持通过子网掩码来指定一个网段的IP地址, 例如 192.168.1.0/24. 则 192.168.1.0~192.168.1.255 都生效。你也可以指定固定的 IP，如 192.168.1.1 或者 192.168.1.1/32，也可以通过都号分隔多个参数，例如 192.168.1.1,192.168.2.1。   interface string 网卡设备，例如 eth0 (必要参数)。   local-port string 本地端口，一般是本机暴露服务的端口。可以指定多个，使用逗号分隔或者连接符表示范围，例如 80,8000-8080。   percent string 丢包百分比，取值在[0, 100]的正整数 (必要参数)。   remote-port string 远程端口，一般是要访问的外部暴露服务的端口。可以指定多个，使用逗号分隔或者连接符表示范围，例如 80,8000-8080。   force  强制覆盖已有的 tc 规则，请务必在明确之前的规则可覆盖的情况下使用。   ignore-peer-port  针对添加 \u0026ndash;exclude-port 参数，报 ss 命令找不到的情况下使用，忽略排除端口。   timeout string 设定运行时长，单位是秒，通用参数。    配置文件 实验配置文件：loss_pod_network_by_names.yaml\napiVersion:chaosblade.io/v1alpha1kind:ChaosBlademetadata:name:loss-pod-network-by-namesspec:experiments:- scope:podtarget:networkaction:lossdesc:\u0026#34;loss pod network by names\u0026#34;matchers:- name:namesvalue:- \u0026#34;redis-master-68857cd57c-dzbs9\u0026#34;- name:namespacevalue:- \u0026#34;chaosblade\u0026#34;- name:interfacevalue:[\u0026#34;eth0\u0026#34;]- name:percentvalue:[\u0026#34;100\u0026#34;]- name:timeoutvalue:[\u0026#34;60\u0026#34;]- name:destination-ipvalue:[\u0026#34;10.42.69.42\u0026#34;]开始实验 获取 pod 名称内容同上。\n执行命令，开始实验：\n$ kubectl apply -f loss_pod_network_by_names.yaml 查看实验状态 执行 kubectl get blade loss-pod-network-by-names -o json 命令，查看实验状态：\n{ \u0026#34;apiVersion\u0026#34;: \u0026#34;chaosblade.io/v1alpha1\u0026#34;, \u0026#34;kind\u0026#34;: \u0026#34;ChaosBlade\u0026#34;, \u0026#34;metadata\u0026#34;: { \u0026#34;annotations\u0026#34;: { \u0026#34;kubectl.kubernetes.io/last-applied-configuration\u0026#34;: \u0026#34;{\\\u0026#34;apiVersion\\\u0026#34;:\\\u0026#34;chaosblade.io/v1alpha1\\\u0026#34;,\\\u0026#34;kind\\\u0026#34;:\\\u0026#34;ChaosBlade\\\u0026#34;,\\\u0026#34;metadata\\\u0026#34;:{\\\u0026#34;annotations\\\u0026#34;:{},\\\u0026#34;name\\\u0026#34;:\\\u0026#34;loss-pod-network-by-names\\\u0026#34;},\\\u0026#34;spec\\\u0026#34;:{\\\u0026#34;experiments\\\u0026#34;:[{\\\u0026#34;action\\\u0026#34;:\\\u0026#34;loss\\\u0026#34;,\\\u0026#34;desc\\\u0026#34;:\\\u0026#34;loss pod network by names\\\u0026#34;,\\\u0026#34;matchers\\\u0026#34;:[{\\\u0026#34;name\\\u0026#34;:\\\u0026#34;names\\\u0026#34;,\\\u0026#34;value\\\u0026#34;:[\\\u0026#34;redis-master-68857cd57c-dzbs9\\\u0026#34;]},{\\\u0026#34;name\\\u0026#34;:\\\u0026#34;namespace\\\u0026#34;,\\\u0026#34;value\\\u0026#34;:[\\\u0026#34;chaosblade\\\u0026#34;]},{\\\u0026#34;name\\\u0026#34;:\\\u0026#34;interface\\\u0026#34;,\\\u0026#34;value\\\u0026#34;:[\\\u0026#34;eth0\\\u0026#34;]},{\\\u0026#34;name\\\u0026#34;:\\\u0026#34;percent\\\u0026#34;,\\\u0026#34;value\\\u0026#34;:[\\\u0026#34;100\\\u0026#34;]},{\\\u0026#34;name\\\u0026#34;:\\\u0026#34;timeout\\\u0026#34;,\\\u0026#34;value\\\u0026#34;:[\\\u0026#34;60\\\u0026#34;]},{\\\u0026#34;name\\\u0026#34;:\\\u0026#34;destination-ip\\\u0026#34;,\\\u0026#34;value\\\u0026#34;:[\\\u0026#34;10.42.69.42\\\u0026#34;]}],\\\u0026#34;scope\\\u0026#34;:\\\u0026#34;pod\\\u0026#34;,\\\u0026#34;target\\\u0026#34;:\\\u0026#34;network\\\u0026#34;}]}}\\n\u0026#34; }, \u0026#34;creationTimestamp\u0026#34;: \u0026#34;2020-06-02T06:32:25Z\u0026#34;, \u0026#34;finalizers\u0026#34;: [ \u0026#34;finalizer.chaosblade.io\u0026#34; ], \u0026#34;generation\u0026#34;: 1, \u0026#34;name\u0026#34;: \u0026#34;loss-pod-network-by-names\u0026#34;, \u0026#34;resourceVersion\u0026#34;: \u0026#34;7715130\u0026#34;, \u0026#34;selfLink\u0026#34;: \u0026#34;/apis/chaosblade.io/v1alpha1/chaosblades/loss-pod-network-by-names\u0026#34;, \u0026#34;uid\u0026#34;: \u0026#34;3a75bc03-ca88-4ad2-bc06-d0b8998b92f2\u0026#34; }, \u0026#34;spec\u0026#34;: { \u0026#34;experiments\u0026#34;: [ { \u0026#34;action\u0026#34;: \u0026#34;loss\u0026#34;, \u0026#34;desc\u0026#34;: \u0026#34;loss pod network by names\u0026#34;, \u0026#34;matchers\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;names\u0026#34;, \u0026#34;value\u0026#34;: [ \u0026#34;redis-master-68857cd57c-dzbs9\u0026#34; ] }, { \u0026#34;name\u0026#34;: \u0026#34;namespace\u0026#34;, \u0026#34;value\u0026#34;: [ \u0026#34;chaosblade\u0026#34; ] }, { \u0026#34;name\u0026#34;: \u0026#34;interface\u0026#34;, \u0026#34;value\u0026#34;: [ \u0026#34;eth0\u0026#34; ] }, { \u0026#34;name\u0026#34;: \u0026#34;percent\u0026#34;, \u0026#34;value\u0026#34;: [ \u0026#34;100\u0026#34; ] }, { \u0026#34;name\u0026#34;: \u0026#34;timeout\u0026#34;, \u0026#34;value\u0026#34;: [ \u0026#34;60\u0026#34; ] }, { \u0026#34;name\u0026#34;: \u0026#34;destination-ip\u0026#34;, \u0026#34;value\u0026#34;: [ \u0026#34;10.42.69.42\u0026#34; ] } ], \u0026#34;scope\u0026#34;: \u0026#34;pod\u0026#34;, \u0026#34;target\u0026#34;: \u0026#34;network\u0026#34; } ] }, \u0026#34;status\u0026#34;: { \u0026#34;expStatuses\u0026#34;: [ { \u0026#34;action\u0026#34;: \u0026#34;loss\u0026#34;, \u0026#34;resStatuses\u0026#34;: [ { \u0026#34;id\u0026#34;: \u0026#34;c1a540c8b29022fd\u0026#34;, \u0026#34;kind\u0026#34;: \u0026#34;pod\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;redis-master\u0026#34;, \u0026#34;nodeName\u0026#34;: \u0026#34;keking\u0026#34;, \u0026#34;state\u0026#34;: \u0026#34;Success\u0026#34;, \u0026#34;success\u0026#34;: true, \u0026#34;uid\u0026#34;: \u0026#34;619a19ceb213f9b6152159bd868e88de2ddbf9a8aac606dc274b34bec6510c60\u0026#34; } ], \u0026#34;scope\u0026#34;: \u0026#34;pod\u0026#34;, \u0026#34;state\u0026#34;: \u0026#34;Success\u0026#34;, \u0026#34;success\u0026#34;: true, \u0026#34;target\u0026#34;: \u0026#34;network\u0026#34; } ], \u0026#34;phase\u0026#34;: \u0026#34;Running\u0026#34; } } 观测结果 # 获取实验 pod ip $ kubectl get pod -l app=redis,role=master -o jsonpath={.items..status.podIP} 10.42.69.44 # 进入观测 pod，IP为：10.42.69.42（被设置丢包率 100%） $ kubectl exec -it redis-slave-6dd975d4c8-lm8jz bash # Ping 实验Pod ip $ ping 10.42.69.44 PING 10.42.69.44 (10.42.69.44) 56(84) bytes of data. # 无响应 # 进入观测 pod，该 pod 未被指定丢包 $ kubectl exec -it redis-slave-6dd975d4c8-2zrkb bash # Ping 实验Pod ip $ ping 10.42.69.44 PING 10.42.69.44 (10.42.69.44) 56(84) bytes of data. 64 bytes from 10.42.69.44: icmp_seq=1 ttl=63 time=0.128 ms 64 bytes from 10.42.69.44: icmp_seq=2 ttl=63 time=0.128 ms 64 bytes from 10.42.69.44: icmp_seq=3 ttl=63 time=0.092 ms ... # 响应正常 这里在配置中将 timeout 设置为 60 秒，60 秒后 100% 丢包的情况将会消失，这个配置是为了防止因丢包率设置太高，造成机器无法连接的情况。与其有相似功能的还有 exclude-port，该配置指定一些端口不会丢包，以免该 pod 失联。\n停止实验 执行命令：kubectl delete -f loss_pod_network_by_names.yaml\n或者直接删除 blade 资源：kubectl delete blade loss-pod-network-by-names\n","excerpt":"在 chaosblade 命名空间中，对 redis-master-68857cd57c-dzbs9 Pod 注入丢包率 100% 的故障，只针对 IP 为 10.42.69.42 的 pod 生效， …","ref":"/docs/operator/pod/pod-network/loss_pod_network/","title":"网络丢包场景"},{"body":"命令 支持的网络场景命令如下：\n blade create k8s node-network delay 节点网络延迟场景，同 blade create network delay blade create k8s node-network loss 节点网络丢包场景，同 blade create network loss blade create k8s node-network dns 节点域名访问异常场景，同 blade create network dns  参数 除了上述场景各自所需的参数外，在 kubernetes 环境下，还支持的参数如下：\n--evict-count string 限制实验生效的数量 --evict-percent string 限制实验生效数量的百分比，不包含 % --labels string 节点资源标签 --names string 节点资源名，多个资源名之间使用逗号分隔 --kubeconfig string kubeconfig 文件全路径（仅限使用 blade 命令调用时使用） --waiting-time string 实验结果等待时间，默认为 20s，参数值要包含单位，例如 10s，1m 案例 对 cn-hangzhou.192.168.0.205 节点本地端口 40690 访问丢包率 60%\nblade 执行方式 blade create k8s node-network loss --percent 60 --interface eth0 --local-port 40690 --kubeconfig config --names cn-hangzhou.192.168.0.205 如果执行失败，会返回详细的错误信息；如果执行成功，会返回实验的 UID：\n{\u0026#34;code\u0026#34;:200,\u0026#34;success\u0026#34;:true,\u0026#34;result\u0026#34;:\u0026#34;e647064f5f20953c\u0026#34;} 可通过以下命令查询实验状态：\nblade query k8s create e647064f5f20953c --kubeconfig config {\u0026#34;code\u0026#34;:200,\u0026#34;success\u0026#34;:true,\u0026#34;result\u0026#34;:{\u0026#34;uid\u0026#34;:\u0026#34;e647064f5f20953c\u0026#34;,\u0026#34;success\u0026#34;:true,\u0026#34;error\u0026#34;:\u0026#34;\u0026#34;,\u0026#34;statuses\u0026#34;:[{\u0026#34;id\u0026#34;:\u0026#34;fa471a6285ec45f5\u0026#34;,\u0026#34;uid\u0026#34;:\u0026#34;e179b30d-df77-11e9-b3be-00163e136d88\u0026#34;,\u0026#34;name\u0026#34;:\u0026#34;cn-hangzhou.192.168.0.205\u0026#34;,\u0026#34;state\u0026#34;:\u0026#34;Success\u0026#34;,\u0026#34;kind\u0026#34;:\u0026#34;node\u0026#34;,\u0026#34;success\u0026#34;:true,\u0026#34;nodeName\u0026#34;:\u0026#34;cn-hangzhou.192.168.0.205\u0026#34;}]}} 销毁实验 blade destroy e647064f5f20953c kubectl 执行方式 yaml 的配置方式见：Kubernetes Node 网络丢包场景\n","excerpt":"命令 支持的网络场景命令如下：\n blade create k8s node-network delay 节点网络延迟场景，同 blade create network delay blade …","ref":"/docs/binaries/create/k8s/node/node-network/","title":"节点网络相关场景"},{"body":"命令 支持的网络场景命令如下：\n blade create k8s pod-network delay Pod 网络延迟场景，同 blade create network delay blade create k8s pod-network loss Pod 网络丢包场景，同 blade create network loss blade create k8s pod-network dns Pod 域名访问异常场景，同 blade create network dns  参数 除了上述场景各自所需的参数外，在 kubernetes 环境下，还支持的参数如下：\n--namespace string Pod 所属的命名空间，只能填写一个值，必填项 --evict-count string 限制实验生效的数量 --evict-percent string 限制实验生效数量的百分比，不包含 % --labels string Pod 资源标签，多个标签之前是或的关系 --names string Pod 资源名 --kubeconfig string kubeconfig 文件全路径（仅限使用 blade 命令调用时使用） --waiting-time string 实验结果等待时间，默认为 20s，参数值要包含单位，例如 10s，1m 案例 对 default 命名空间下，指定名为 redis-slave-674d68586-jnf7f Pod 本地端口 6379 访问延迟 3000 毫秒，延迟时间上下浮动 1000 毫秒\nblade 执行方式 blade create k8s pod-network delay --time 3000 --offset 1000 --interface eth0 --local-port 6379 --names redis-slave-674d68586-jnf7f --namespace default --kubeconfig config 如果执行失败，会返回详细的错误信息；如果执行成功，会返回实验的 UID：\n{\u0026#34;code\u0026#34;:200,\u0026#34;success\u0026#34;:true,\u0026#34;result\u0026#34;:\u0026#34;127f1ee0afcd4798\u0026#34;} 可通过以下命令查询实验状态：\nblade query k8s create 127f1ee0afcd4798 --kubeconfig config {\u0026#34;code\u0026#34;:200,\u0026#34;success\u0026#34;:true,\u0026#34;result\u0026#34;:{\u0026#34;uid\u0026#34;:\u0026#34;127f1ee0afcd4798\u0026#34;,\u0026#34;success\u0026#34;:true,\u0026#34;error\u0026#34;:\u0026#34;\u0026#34;,\u0026#34;statuses\u0026#34;:[{\u0026#34;id\u0026#34;:\u0026#34;b5a216dddeb3389f\u0026#34;,\u0026#34;uid\u0026#34;:\u0026#34;4f1a28a1-fee6-11e9-8883-00163e0ad0b3\u0026#34;,\u0026#34;name\u0026#34;:\u0026#34;chaosblade-tool-vv49t\u0026#34;,\u0026#34;state\u0026#34;:\u0026#34;Success\u0026#34;,\u0026#34;kind\u0026#34;:\u0026#34;pod\u0026#34;,\u0026#34;success\u0026#34;:true,\u0026#34;nodeName\u0026#34;:\u0026#34;cn-hangzhou.192.168.0.204\u0026#34;}]}} 可通过访问服务，或者 telnet 命令验证实验效果\n销毁实验 blade destroy 127f1ee0afcd4798 kubectl 执行方式 yaml 的配置方式见：Kubernetes Pod 网络延迟场景\n","excerpt":"命令 支持的网络场景命令如下：\n blade create k8s pod-network delay Pod 网络延迟场景，同 blade create network delay blade …","ref":"/docs/binaries/create/k8s/pod/pod-network/","title":"Pod 网络相关场景"},{"body":"参数 --exit-code string 退出码，默认值是 1 --exit-message string 退出信息 --timeout string 设定运行时长，单位是秒，通用参数 --file string 脚本路径（必要参数） --function-name string 脚本中的函数名（必要参数） 案例 # blade create script exit --exit-code 1 --exit-message this-is-error-message --file test.sh --function-name start0 {\u0026#34;code\u0026#34;:200,\u0026#34;success\u0026#34;:true,\u0026#34;result\u0026#34;:\u0026#34;d8a016b96380d7f3\u0026#34;} # 执行脚本会触发场景。查看脚本修改如下: start0() { echo this-is-error-message;exit 1 ... } 实现原理 备份原有脚本，根据函数名添加 echo 和 exit 命令。回复时还原脚本。\n常见问题 Q: {\u0026quot;code\u0026quot;:602,\u0026quot;success\u0026quot;:false,\u0026quot;error\u0026quot;:\u0026quot;get too many lines by the install function name\u0026quot;}\nA：查找到多个函数，不能执行\n","excerpt":"参数 --exit-code string 退出码，默认值是 1 --exit-message string 退出信息 --timeout string 设定运行时长，单位是秒，通用参数 --file …","ref":"/docs/binaries/create/script/script-exit/","title":"脚本函数执行退出"},{"body":"","excerpt":"","ref":"/docs/binaries/","title":"CLI 工具"},{"body":"","excerpt":"","ref":"/docs/operator/container/container-process/","title":"Container 内进程实验场景"},{"body":"","excerpt":"","ref":"/docs/binaries/create/k8s/container/","title":"Container 实验场景"},{"body":"参数 此处列举 http 支持的通用参数：\n--effect-count string 影响的请求条数 --effect-percent string 影响的请求百分比 --pid string 指定 java 进程号 --process string 指定 java 进程名 --timeout string 设定运行时长，单位是秒，通用参数 --httpclient3 作用 httpclient3 组件，即 Apache HttpClient 3.x --httpclient4 作用 httpclient4 组件，即 Apache HttpClient 4.x --rest 作用 rest 组件，即 Spring Web 模块中的 RestTemplate --uri 请求 URL，不包含 querystring 部分，例如：http://127.0.0.1:8801/getName 各场景还有自身所独有的参数，可以在每个场景文档中查看\n实验原理 常见问题 Q: 下发规则不生效\nA: 在命令后添加 \u0026ndash;debug，然后触发业务请求，查看应用进程用户目录下 ~/logs/chaosblade/chaosblade.log 日志，如下：\n2020-05-04 23:01:00 INFO command: create, request: {\u0026#34;headers\u0026#34;:{},\u0026#34;params\u0026#34;:{\u0026#34;rest\u0026#34;:\u0026#34;true\u0026#34;,\u0026#34;process\u0026#34;:\u0026#34;http-client\u0026#34;,\u0026#34;debug\u0026#34;:\u0026#34;true\u0026#34;,\u0026#34;action\u0026#34;:\u0026#34;delay\u0026#34;,\u0026#34;suid\u0026#34;:\u0026#34;d7ab31c151a045aa\u0026#34;,\u0026#34;time\u0026#34;:\u0026#34;3000\u0026#34;,\u0026#34;uri\u0026#34;:\u0026#34;http://127.0.0.1:8801/getName\u0026#34;,\u0026#34;target\u0026#34;:\u0026#34;http\u0026#34;}} 2020-05-04 23:01:00 INFO change log level to debug 2020-05-04 23:01:13 DEBUG http matchers: {\u0026#34;matchers\u0026#34;:{\u0026#34;uri\u0026#34;:\u0026#34;http://127.0.0.1:8801/getName\u0026#34;}} 2020-05-04 23:01:13 INFO Match rule: {\u0026#34;action\u0026#34;:{\u0026#34;name\u0026#34;:\u0026#34;delay\u0026#34;},\u0026#34;actionName\u0026#34;:\u0026#34;delay\u0026#34;,\u0026#34;matcher\u0026#34;:{\u0026#34;matchers\u0026#34;:{\u0026#34;rest\u0026#34;:\u0026#34;true\u0026#34;,\u0026#34;uri\u0026#34;:\u0026#34;http://127.0.0.1:8801/getName\u0026#34;}},\u0026#34;target\u0026#34;:\u0026#34;http\u0026#34;} command create 表示下发了 create 指令并开启 debug 日志，http matchers 表示获取请求的匹配数据，Match rule 表示请求和下发的命令匹配成功，延迟故障生效\n","excerpt":"参数 此处列举 http 支持的通用参数：\n--effect-count string 影响的请求条数 --effect-percent string 影响的请求百分比 --pid string …","ref":"/docs/binaries/create/java/http/","title":"http 接口调用场景"},{"body":"参数\nnode 资源均支持以下参数。\n   参数 类型 说明 默认值     evict-count string 限制实验生效的数量    evict-percent string 限制实验生效数量的百分比，不包含 %    labels string Pod 资源标签，多个标签之间是或的关系    names string Pod 资源名    waiting-time string 实验结果等待时间，参数值要包含单位，例如 10s，1m 20s    ","excerpt":"参数\nnode 资源均支持以下参数。\n   参数 类型 说明 默认值     evict-count string 限制实验生效的数量    evict-percent string 限制实验生效数量 …","ref":"/docs/operator/node/","title":"Node 场景"},{"body":"","excerpt":"","ref":"/docs/operator/node/node-disk/","title":"Node 磁盘相关场景"},{"body":"","excerpt":"","ref":"/docs/operator/pod/pod-io/","title":"Pod 文件系统相关场景"},{"body":"","excerpt":"","ref":"/docs/binaries/prepare/","title":"prepare 命令"},{"body":"欢迎提交缺陷、问题、建议和新功能，所有项目（包含其他子项目）的问题都可以提交到 Github Issues\n每双周社区会举行一次社区会议，在钉钉群举行，会议记录。\n你也可以通过以下方式联系我们：\n 钉钉群（推荐）：23177705 Gitter room: https://gitter.im/chaosblade-io/community 邮箱：chaosblade.io.01@gmail.com Twitter: chaosblade.io  ","excerpt":"欢迎提交缺陷、问题、建议和新功能，所有项目（包含其他子项目）的问题都可以提交到 Github Issues\n每双周社区会举行一次社区会议，在钉钉群举行，会议记录。\n你也可以通过以下方式联系我们：\n 钉 …","ref":"/contributing/community/","title":"参与社区"},{"body":"本实验通过修改本地的 hosts，篡改域名地址映射，模拟 container 内域名访问异常场景。\n实验参数    参数 类型 说明     domain string 域名 (必要参数)   ip string 映射的 ip (必要参数)   timeout string 设定运行时长，单位是秒，通用参数。    配置文件 实验配置文件：tamper_container_dns_by_id.yaml\napiVersion:chaosblade.io/v1alpha1kind:ChaosBlademetadata:name:tamper-container-dns-by-idspec:experiments:- scope:containertarget:networkaction:dnsdesc:\u0026#34;tamper container dns by id\u0026#34;matchers:- name:container-idsvalue:- \u0026#34;02655dfdd9f0f712a10d63fdc6721f4dcee0a390e37717fff068bf3f85abf85e\u0026#34;- name:domainvalue:[\u0026#34;www.baidu.com\u0026#34;]- name:ipvalue:[\u0026#34;10.0.0.1\u0026#34;]# pod names- name:namesvalue:[\u0026#34;redis-master-68857cd57c-hknb6\u0026#34;]# or use pod labels- name:namespacevalue:[\u0026#34;chaosblade\u0026#34;]开始实验 获取 pod 名称和 container id 内容同上。\n执行命令，开始实验：\n$ kubectl apply -f tamper_container_dns_by_id.yaml 查看实验状态 执行 kubectl get blade tamper-container-dns-by-id -o json 命令，查看实验状态：\n{ \u0026#34;apiVersion\u0026#34;: \u0026#34;chaosblade.io/v1alpha1\u0026#34;, \u0026#34;kind\u0026#34;: \u0026#34;ChaosBlade\u0026#34;, \u0026#34;metadata\u0026#34;: { \u0026#34;annotations\u0026#34;: { \u0026#34;kubectl.kubernetes.io/last-applied-configuration\u0026#34;: \u0026#34;{\\\u0026#34;apiVersion\\\u0026#34;:\\\u0026#34;chaosblade.io/v1alpha1\\\u0026#34;,\\\u0026#34;kind\\\u0026#34;:\\\u0026#34;ChaosBlade\\\u0026#34;,\\\u0026#34;metadata\\\u0026#34;:{\\\u0026#34;annotations\\\u0026#34;:{},\\\u0026#34;name\\\u0026#34;:\\\u0026#34;tamper-container-dns-by-id\\\u0026#34;},\\\u0026#34;spec\\\u0026#34;:{\\\u0026#34;experiments\\\u0026#34;:[{\\\u0026#34;action\\\u0026#34;:\\\u0026#34;dns\\\u0026#34;,\\\u0026#34;desc\\\u0026#34;:\\\u0026#34;tamper container dns by id\\\u0026#34;,\\\u0026#34;matchers\\\u0026#34;:[{\\\u0026#34;name\\\u0026#34;:\\\u0026#34;container-ids\\\u0026#34;,\\\u0026#34;value\\\u0026#34;:[\\\u0026#34;02655dfdd9f0f712a10d63fdc6721f4dcee0a390e37717fff068bf3f85abf85e\\\u0026#34;]},{\\\u0026#34;name\\\u0026#34;:\\\u0026#34;domain\\\u0026#34;,\\\u0026#34;value\\\u0026#34;:[\\\u0026#34;www.baidu.com\\\u0026#34;]},{\\\u0026#34;name\\\u0026#34;:\\\u0026#34;ip\\\u0026#34;,\\\u0026#34;value\\\u0026#34;:[\\\u0026#34;10.0.0.1\\\u0026#34;]},{\\\u0026#34;name\\\u0026#34;:\\\u0026#34;names\\\u0026#34;,\\\u0026#34;value\\\u0026#34;:[\\\u0026#34;redis-master-68857cd57c-hknb6\\\u0026#34;]},{\\\u0026#34;name\\\u0026#34;:\\\u0026#34;namespace\\\u0026#34;,\\\u0026#34;value\\\u0026#34;:[\\\u0026#34;chaosblade\\\u0026#34;]}],\\\u0026#34;scope\\\u0026#34;:\\\u0026#34;container\\\u0026#34;,\\\u0026#34;target\\\u0026#34;:\\\u0026#34;network\\\u0026#34;}]}}\\n\u0026#34; }, \u0026#34;creationTimestamp\u0026#34;: \u0026#34;2020-06-04T08:13:20Z\u0026#34;, \u0026#34;finalizers\u0026#34;: [ \u0026#34;finalizer.chaosblade.io\u0026#34; ], \u0026#34;generation\u0026#34;: 1, \u0026#34;name\u0026#34;: \u0026#34;tamper-container-dns-by-id\u0026#34;, \u0026#34;resourceVersion\u0026#34;: \u0026#34;185452\u0026#34;, \u0026#34;selfLink\u0026#34;: \u0026#34;/apis/chaosblade.io/v1alpha1/chaosblades/tamper-container-dns-by-id\u0026#34;, \u0026#34;uid\u0026#34;: \u0026#34;72ad4e2a-7c92-436d-b477-61f088191f8b\u0026#34; }, \u0026#34;spec\u0026#34;: { \u0026#34;experiments\u0026#34;: [ { \u0026#34;action\u0026#34;: \u0026#34;dns\u0026#34;, \u0026#34;desc\u0026#34;: \u0026#34;tamper container dns by id\u0026#34;, \u0026#34;matchers\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;container-ids\u0026#34;, \u0026#34;value\u0026#34;: [ \u0026#34;02655dfdd9f0f712a10d63fdc6721f4dcee0a390e37717fff068bf3f85abf85e\u0026#34; ] }, { \u0026#34;name\u0026#34;: \u0026#34;domain\u0026#34;, \u0026#34;value\u0026#34;: [ \u0026#34;www.baidu.com\u0026#34; ] }, { \u0026#34;name\u0026#34;: \u0026#34;ip\u0026#34;, \u0026#34;value\u0026#34;: [ \u0026#34;10.0.0.1\u0026#34; ] }, { \u0026#34;name\u0026#34;: \u0026#34;names\u0026#34;, \u0026#34;value\u0026#34;: [ \u0026#34;redis-master-68857cd57c-hknb6\u0026#34; ] }, { \u0026#34;name\u0026#34;: \u0026#34;namespace\u0026#34;, \u0026#34;value\u0026#34;: [ \u0026#34;chaosblade\u0026#34; ] } ], \u0026#34;scope\u0026#34;: \u0026#34;container\u0026#34;, \u0026#34;target\u0026#34;: \u0026#34;network\u0026#34; } ] }, \u0026#34;status\u0026#34;: { \u0026#34;expStatuses\u0026#34;: [ { \u0026#34;action\u0026#34;: \u0026#34;dns\u0026#34;, \u0026#34;resStatuses\u0026#34;: [ { \u0026#34;id\u0026#34;: \u0026#34;e352348f9b0477b7\u0026#34;, \u0026#34;kind\u0026#34;: \u0026#34;container\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;redis-master\u0026#34;, \u0026#34;nodeName\u0026#34;: \u0026#34;keking\u0026#34;, \u0026#34;state\u0026#34;: \u0026#34;Success\u0026#34;, \u0026#34;success\u0026#34;: true, \u0026#34;uid\u0026#34;: \u0026#34;02655dfdd9f0f712a10d63fdc6721f4dcee0a390e37717fff068bf3f85abf85e\u0026#34; } ], \u0026#34;scope\u0026#34;: \u0026#34;container\u0026#34;, \u0026#34;state\u0026#34;: \u0026#34;Success\u0026#34;, \u0026#34;success\u0026#34;: true, \u0026#34;target\u0026#34;: \u0026#34;network\u0026#34; } ], \u0026#34;phase\u0026#34;: \u0026#34;Running\u0026#34; } } 观测结果 # 进入实验 pod $ kubectl exec -it redis-master-68857cd57c-hknb6 bash # Ping www.baidu.com $ ping www.baidu.com # 无响应 可以看到 Pod 的 /etc/hosts 文件被修改，模拟了 dns 解析异常的场景。\n","excerpt":"本实验通过修改本地的 hosts，篡改域名地址映射，模拟 container 内域名访问异常场景。\n实验参数    参数 类型 说明     domain string 域名 (必要参数)   ip …","ref":"/docs/operator/container/container-network/tamper_container_dns/","title":"域名访问异常场景"},{"body":"本实验通过修改 Node 的 hosts，篡改域名地址映射，模拟 Pod 内域名访问异常场景。\n参数    参数 类型 说明     domain string 域名 (必要参数)   ip string 映射的 ip (必要参数)   timeout string 设定运行时长，单位是秒，通用参数。    配置文件 实验配置文件：dns_node_network_by_names.yaml\napiVersion:chaosblade.io/v1alpha1kind:ChaosBlademetadata:name:dns-node-network-by-namesspec:experiments:- scope:nodetarget:networkaction:dnsdesc:\u0026#34;dns node network by names\u0026#34;matchers:- name:namesvalue:- \u0026#34;docker20\u0026#34;- name:domainvalue:[\u0026#34;www.baidu.com\u0026#34;]- name:ipvalue:[\u0026#34;10.0.0.1\u0026#34;]开始实验 选择一个节点，修改 dns_node_network_by_names.yaml 中的 names 值。\n执行命令，开始实验：\n$ kubectl apply -f dns_node_network_by_names.yaml 查看实验状态 执行 kubectl get blade dns-node-network-by-names -o json 命令，查看实验状态：\n{ \u0026#34;apiVersion\u0026#34;: \u0026#34;chaosblade.io/v1alpha1\u0026#34;, \u0026#34;kind\u0026#34;: \u0026#34;ChaosBlade\u0026#34;, \u0026#34;metadata\u0026#34;: { \u0026#34;annotations\u0026#34;: { \u0026#34;kubectl.kubernetes.io/last-applied-configuration\u0026#34;: \u0026#34;{\\\u0026#34;apiVersion\\\u0026#34;:\\\u0026#34;chaosblade.io/v1alpha1\\\u0026#34;,\\\u0026#34;kind\\\u0026#34;:\\\u0026#34;ChaosBlade\\\u0026#34;,\\\u0026#34;metadata\\\u0026#34;:{\\\u0026#34;annotations\\\u0026#34;:{},\\\u0026#34;name\\\u0026#34;:\\\u0026#34;dns-node-network-by-names\\\u0026#34;},\\\u0026#34;spec\\\u0026#34;:{\\\u0026#34;experiments\\\u0026#34;:[{\\\u0026#34;action\\\u0026#34;:\\\u0026#34;dns\\\u0026#34;,\\\u0026#34;desc\\\u0026#34;:\\\u0026#34;dns node network by names\\\u0026#34;,\\\u0026#34;matchers\\\u0026#34;:[{\\\u0026#34;name\\\u0026#34;:\\\u0026#34;names\\\u0026#34;,\\\u0026#34;value\\\u0026#34;:[\\\u0026#34;docker20\\\u0026#34;]},{\\\u0026#34;name\\\u0026#34;:\\\u0026#34;domain\\\u0026#34;,\\\u0026#34;value\\\u0026#34;:[\\\u0026#34;www.baidu.com\\\u0026#34;]},{\\\u0026#34;name\\\u0026#34;:\\\u0026#34;ip\\\u0026#34;,\\\u0026#34;value\\\u0026#34;:[\\\u0026#34;10.0.0.1\\\u0026#34;]}],\\\u0026#34;scope\\\u0026#34;:\\\u0026#34;node\\\u0026#34;,\\\u0026#34;target\\\u0026#34;:\\\u0026#34;network\\\u0026#34;}]}}\\n\u0026#34; }, \u0026#34;creationTimestamp\u0026#34;: \u0026#34;2020-06-08T03:39:54Z\u0026#34;, \u0026#34;finalizers\u0026#34;: [ \u0026#34;finalizer.chaosblade.io\u0026#34; ], \u0026#34;generation\u0026#34;: 1, \u0026#34;name\u0026#34;: \u0026#34;dns-node-network-by-names\u0026#34;, \u0026#34;resourceVersion\u0026#34;: \u0026#34;986912\u0026#34;, \u0026#34;selfLink\u0026#34;: \u0026#34;/apis/chaosblade.io/v1alpha1/chaosblades/dns-node-network-by-names\u0026#34;, \u0026#34;uid\u0026#34;: \u0026#34;dd6fa6bc-e04a-4566-b949-4630ed94b1c2\u0026#34; }, \u0026#34;spec\u0026#34;: { \u0026#34;experiments\u0026#34;: [ { \u0026#34;action\u0026#34;: \u0026#34;dns\u0026#34;, \u0026#34;desc\u0026#34;: \u0026#34;dns node network by names\u0026#34;, \u0026#34;matchers\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;names\u0026#34;, \u0026#34;value\u0026#34;: [ \u0026#34;docker20\u0026#34; ] }, { \u0026#34;name\u0026#34;: \u0026#34;domain\u0026#34;, \u0026#34;value\u0026#34;: [ \u0026#34;www.baidu.com\u0026#34; ] }, { \u0026#34;name\u0026#34;: \u0026#34;ip\u0026#34;, \u0026#34;value\u0026#34;: [ \u0026#34;10.0.0.1\u0026#34; ] } ], \u0026#34;scope\u0026#34;: \u0026#34;node\u0026#34;, \u0026#34;target\u0026#34;: \u0026#34;network\u0026#34; } ] }, \u0026#34;status\u0026#34;: { \u0026#34;expStatuses\u0026#34;: [ { \u0026#34;action\u0026#34;: \u0026#34;dns\u0026#34;, \u0026#34;resStatuses\u0026#34;: [ { \u0026#34;id\u0026#34;: \u0026#34;626da6fac3f157a5\u0026#34;, \u0026#34;kind\u0026#34;: \u0026#34;node\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;docker20\u0026#34;, \u0026#34;nodeName\u0026#34;: \u0026#34;docker20\u0026#34;, \u0026#34;state\u0026#34;: \u0026#34;Success\u0026#34;, \u0026#34;success\u0026#34;: true, \u0026#34;uid\u0026#34;: \u0026#34;51d4553b-8da2-46ab-9b3d-51a11ae6d06f\u0026#34; } ], \u0026#34;scope\u0026#34;: \u0026#34;node\u0026#34;, \u0026#34;state\u0026#34;: \u0026#34;Success\u0026#34;, \u0026#34;success\u0026#34;: true, \u0026#34;target\u0026#34;: \u0026#34;network\u0026#34; } ], \u0026#34;phase\u0026#34;: \u0026#34;Running\u0026#34; } } 观测结果 # 进入实验 node $ ssh kk@192.168.1.129 # Ping www.baidu.com $ ping www.baidu.com # 无响应 可以看到 Node 的 /etc/hosts 文件被修改，模拟了 dns 解析异常的场景。\n停止实验 执行命令：kubectl delete -f dns_node_network_by_names.yaml\n或者直接删除 blade 资源：kubectl delete blade dns-node-network-by-names\n","excerpt":"本实验通过修改 Node 的 hosts，篡改域名地址映射，模拟 Pod 内域名访问异常场景。\n参数    参数 类型 说明     domain string 域名 (必要参数)   ip …","ref":"/docs/operator/node/node-network/dns_node_network/","title":"域名访问异常场景"},{"body":"本实验通过修改本地的 hosts，篡改域名地址映射，模拟 Pod 内域名访问异常场景。\n参数    参数 类型 说明     domain string 域名 (必要参数)   ip string 映射的 ip (必要参数)   timeout string 设定运行时长，单位是秒，通用参数。    配置文件 实验配置文件：dns_pod_network_by_names.yaml\napiVersion:chaosblade.io/v1alpha1kind:ChaosBlademetadata:name:dns-pod-network-by-namesspec:experiments:- scope:podtarget:networkaction:dnsdesc:\u0026#34;dns pod network by names\u0026#34;matchers:- name:namesvalue:- \u0026#34;redis-slave-6dd975d4c8-lm8jz\u0026#34;- name:namespacevalue:- \u0026#34;chaosblade\u0026#34;- name:domainvalue:[\u0026#34;www.baidu.com\u0026#34;]- name:ipvalue:[\u0026#34;10.0.0.1\u0026#34;]开始实验 获取 pod 名称内容同上。\n执行命令，开始实验：\n$ kubectl apply -f dns_pod_network_by_names.yaml 查看实验状态 执行 kubectl get blade dns-pod-network-by-names -o json  命令，查看实验状态：\n{ \u0026#34;apiVersion\u0026#34;: \u0026#34;chaosblade.io/v1alpha1\u0026#34;, \u0026#34;kind\u0026#34;: \u0026#34;ChaosBlade\u0026#34;, \u0026#34;metadata\u0026#34;: { \u0026#34;annotations\u0026#34;: { \u0026#34;kubectl.kubernetes.io/last-applied-configuration\u0026#34;: \u0026#34;{\\\u0026#34;apiVersion\\\u0026#34;:\\\u0026#34;chaosblade.io/v1alpha1\\\u0026#34;,\\\u0026#34;kind\\\u0026#34;:\\\u0026#34;ChaosBlade\\\u0026#34;,\\\u0026#34;metadata\\\u0026#34;:{\\\u0026#34;annotations\\\u0026#34;:{},\\\u0026#34;name\\\u0026#34;:\\\u0026#34;dns-pod-network-by-names\\\u0026#34;},\\\u0026#34;spec\\\u0026#34;:{\\\u0026#34;experiments\\\u0026#34;:[{\\\u0026#34;action\\\u0026#34;:\\\u0026#34;dns\\\u0026#34;,\\\u0026#34;desc\\\u0026#34;:\\\u0026#34;dns pod network by names\\\u0026#34;,\\\u0026#34;matchers\\\u0026#34;:[{\\\u0026#34;name\\\u0026#34;:\\\u0026#34;names\\\u0026#34;,\\\u0026#34;value\\\u0026#34;:[\\\u0026#34;redis-slave-6dd975d4c8-lm8jz\\\u0026#34;]},{\\\u0026#34;name\\\u0026#34;:\\\u0026#34;namespace\\\u0026#34;,\\\u0026#34;value\\\u0026#34;:[\\\u0026#34;chaosblade\\\u0026#34;]},{\\\u0026#34;name\\\u0026#34;:\\\u0026#34;domain\\\u0026#34;,\\\u0026#34;value\\\u0026#34;:[\\\u0026#34;www.baidu.com\\\u0026#34;]},{\\\u0026#34;name\\\u0026#34;:\\\u0026#34;ip\\\u0026#34;,\\\u0026#34;value\\\u0026#34;:[\\\u0026#34;10.0.0.1\\\u0026#34;]}],\\\u0026#34;scope\\\u0026#34;:\\\u0026#34;pod\\\u0026#34;,\\\u0026#34;target\\\u0026#34;:\\\u0026#34;network\\\u0026#34;}]}}\\n\u0026#34; }, \u0026#34;creationTimestamp\u0026#34;: \u0026#34;2020-06-02T07:03:32Z\u0026#34;, \u0026#34;finalizers\u0026#34;: [ \u0026#34;finalizer.chaosblade.io\u0026#34; ], \u0026#34;generation\u0026#34;: 1, \u0026#34;name\u0026#34;: \u0026#34;dns-pod-network-by-names\u0026#34;, \u0026#34;resourceVersion\u0026#34;: \u0026#34;7719397\u0026#34;, \u0026#34;selfLink\u0026#34;: \u0026#34;/apis/chaosblade.io/v1alpha1/chaosblades/dns-pod-network-by-names\u0026#34;, \u0026#34;uid\u0026#34;: \u0026#34;08f25964-a73a-4b2c-9cea-0ad491c68345\u0026#34; }, \u0026#34;spec\u0026#34;: { \u0026#34;experiments\u0026#34;: [ { \u0026#34;action\u0026#34;: \u0026#34;dns\u0026#34;, \u0026#34;desc\u0026#34;: \u0026#34;dns pod network by names\u0026#34;, \u0026#34;matchers\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;names\u0026#34;, \u0026#34;value\u0026#34;: [ \u0026#34;redis-slave-6dd975d4c8-lm8jz\u0026#34; ] }, { \u0026#34;name\u0026#34;: \u0026#34;namespace\u0026#34;, \u0026#34;value\u0026#34;: [ \u0026#34;chaosblade\u0026#34; ] }, { \u0026#34;name\u0026#34;: \u0026#34;domain\u0026#34;, \u0026#34;value\u0026#34;: [ \u0026#34;www.baidu.com\u0026#34; ] }, { \u0026#34;name\u0026#34;: \u0026#34;ip\u0026#34;, \u0026#34;value\u0026#34;: [ \u0026#34;10.0.0.1\u0026#34; ] } ], \u0026#34;scope\u0026#34;: \u0026#34;pod\u0026#34;, \u0026#34;target\u0026#34;: \u0026#34;network\u0026#34; } ] }, \u0026#34;status\u0026#34;: { \u0026#34;expStatuses\u0026#34;: [ { \u0026#34;action\u0026#34;: \u0026#34;dns\u0026#34;, \u0026#34;resStatuses\u0026#34;: [ { \u0026#34;id\u0026#34;: \u0026#34;470d7c22418e87c1\u0026#34;, \u0026#34;kind\u0026#34;: \u0026#34;pod\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;redis-slave\u0026#34;, \u0026#34;nodeName\u0026#34;: \u0026#34;keking\u0026#34;, \u0026#34;state\u0026#34;: \u0026#34;Success\u0026#34;, \u0026#34;success\u0026#34;: true, \u0026#34;uid\u0026#34;: \u0026#34;a5996d866566fa7788d69b6f611769e3da3c81401cd20ecb0b53aebdb508e14c\u0026#34; } ], \u0026#34;scope\u0026#34;: \u0026#34;pod\u0026#34;, \u0026#34;state\u0026#34;: \u0026#34;Success\u0026#34;, \u0026#34;success\u0026#34;: true, \u0026#34;target\u0026#34;: \u0026#34;network\u0026#34; } ], \u0026#34;phase\u0026#34;: \u0026#34;Running\u0026#34; } } 观测结果 # 进入实验 pod $ kubectl exec -it redis-slave-6dd975d4c8-lm8jz bash # Ping www.baidu.com $ ping www.baidu.com # 无响应 可以看到 Pod 的 /etc/hosts 文件被修改，模拟了 dns 解析异常的场景。\n停止实验 执行命令：kubectl delete -f dns_pod_network_by_names.yaml\n或者直接删除 blade 资源：kubectl delete blade dns-pod-network-by-names\n","excerpt":"本实验通过修改本地的 hosts，篡改域名地址映射，模拟 Pod 内域名访问异常场景。\n参数    参数 类型 说明     domain string 域名 (必要参数)   ip string 映 …","ref":"/docs/operator/pod/pod-network/dns_pod_network/","title":"域名访问异常场景"},{"body":"命令 支持的进程场景如下：\n blade create docker process kill， 杀容器内指定的进程，同 blade create process kill blade create docker process stop，挂起容器内指定的进程，同 blade create process stop  参数 除了上述基础场景各自所需的参数外，在 docker 实验场景下还支持的参数是：\n--blade-override 是否覆盖容器内已有的 chaosblade 工具，默认是 false，表示不覆盖，chaosblade 在容器内的部署路径为 /opt/chaosblade --blade-tar-file string 指定本地 chaosblade-VERSION.tar.gz 工具包全路径，用于拷贝到容器内执行 --container-id string 目标容器 ID --docker-endpoint string Docker server 地址，默认为本地的 /var/run/docker.sock 案例 杀掉容器内 nginx 进程，命令执行如下：\nblade create docker process kill --process nginx --blade-tar-file /root/chaosblade-0.4.0.tar.gz --container-id ee54f1e61c08 常见问题 Q: {\u0026quot;code\u0026quot;:801,\u0026quot;success\u0026quot;:false,\u0026quot;error\u0026quot;:\u0026quot;open : no such file or directory\u0026quot;}\nA: 没有指定 --blade-tar-file 参数\nQ：{\u0026quot;code\u0026quot;:801,\u0026quot;success\u0026quot;:false,\u0026quot;error\u0026quot;:\u0026quot;\\u0001\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0002\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\u0026quot;}\nA：重试即可\nQ: {\u0026quot;code\u0026quot;:503,\u0026quot;success\u0026quot;:false,\u0026quot;error\u0026quot;:\u0026quot;ps command not found\u0026quot;}\nA: 目标容器内没有 ps 命令\n","excerpt":"命令 支持的进程场景如下：\n blade create docker process kill， 杀容器内指定的进程，同 blade create process kill blade create …","ref":"/docs/binaries/create/docker/docker-process/","title":"容器内进程场景"},{"body":"命令 支持的进程场景命令如下：\n blade create k8s container-process kill 杀容器内指定进程，同 blade create process kill blade create k8s container-process stop 挂起容器内指定进程，同 blade create process stop  参数 除了上述基础场景各自所需的参数外，在 kubernetes 环境下，还支持的参数如下：\n--container-ids string 容器ID，支持配置多个 --container-names string 容器名称，支持配置多个 --docker-endpoint string Docker server 地址，默认为本地的 /var/run/docker.sock --namespace string Pod 所属的命名空间，只能填写一个值，必填项 --evict-count string 限制实验生效的数量 --evict-percent string 限制实验生效数量的百分比，不包含 % --labels string Pod 资源标签，多个标签之前是或的关系 --names string Pod 资源名 --kubeconfig string kubeconfig 文件全路径（仅限使用 blade 命令调用时使用） --waiting-time string 实验结果等待时间，默认为 20s，参数值要包含单位，例如 10s，1m 案例 指定 default 命名空间下 Pod 名是 frontend-d89756ff7-tl4xl，容器 id 为 f1de335b4eeaf，进程名为 top 的进程。\nblade 命令执行方式 blade create k8s container-process kill --process top --names frontend-d89756ff7-tl4xl --container-ids f1de335b4eeaf --namespace default --kubeconfig config 如果执行失败，会返回详细的错误信息；如果执行成功，会返回实验的 UID：\n{\u0026#34;code\u0026#34;:200,\u0026#34;success\u0026#34;:true,\u0026#34;result\u0026#34;:\u0026#34;06d5ebae60e8fe3f\u0026#34;} 可通过以下命令查询实验状态：\nblade query k8s create 06d5ebae60e8fe3f --kubeconfig config {\u0026#34;code\u0026#34;:200,\u0026#34;success\u0026#34;:true,\u0026#34;result\u0026#34;:{\u0026#34;uid\u0026#34;:\u0026#34;06d5ebae60e8fe3f\u0026#34;,\u0026#34;success\u0026#34;:true,\u0026#34;error\u0026#34;:\u0026#34;\u0026#34;,\u0026#34;statuses\u0026#34;:[{\u0026#34;id\u0026#34;:\u0026#34;1000cbd2018e2c90\u0026#34;,\u0026#34;uid\u0026#34;:\u0026#34;f1de335b4eeaf035b8d23a87080f3d24cebc803cbb6ad15e5fe0d8567e2e8939\u0026#34;,\u0026#34;name\u0026#34;:\u0026#34;php-redis\u0026#34;,\u0026#34;state\u0026#34;:\u0026#34;Success\u0026#34;,\u0026#34;kind\u0026#34;:\u0026#34;container\u0026#34;,\u0026#34;success\u0026#34;:true,\u0026#34;nodeName\u0026#34;:\u0026#34;cn-hangzhou.192.168.0.204\u0026#34;}]}}  Warning 注意，停止实验不会恢复已杀掉的进程！！  销毁实验 blade destroy 06d5ebae60e8fe3f kubectl 执行方式 yaml 的配置方式见：Kubernetes Container 杀指定进程场景\n常见问题 Q: 如果状态如下：\n\u0026#34;status\u0026#34;: { \u0026#34;expStatuses\u0026#34;: [ { \u0026#34;action\u0026#34;: \u0026#34;kill\u0026#34;, \u0026#34;error\u0026#34;: \u0026#34;see resStatus for the error details\u0026#34;, \u0026#34;resStatuses\u0026#34;: [ { \u0026#34;kind\u0026#34;: \u0026#34;container\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;slave\u0026#34;, \u0026#34;nodeName\u0026#34;: \u0026#34;cn-hangzhou.192.168.0.204\u0026#34;, \u0026#34;state\u0026#34;: \u0026#34;Error\u0026#34;, \u0026#34;success\u0026#34;: false, \u0026#34;uid\u0026#34;: \u0026#34;c3175f916e87fe06c339712427758f3d51dcb38d3e71cfae168bbbdfeab86710\u0026#34; } ], \u0026#34;scope\u0026#34;: \u0026#34;container\u0026#34;, \u0026#34;state\u0026#34;: \u0026#34;Error\u0026#34;, \u0026#34;success\u0026#34;: false, \u0026#34;target\u0026#34;: \u0026#34;process\u0026#34; } ], \u0026#34;phase\u0026#34;: \u0026#34;Error\u0026#34; } A: 其实已经执行，只是返回结果有乱码；删除实验，重新执行实验即可\nQ:\n\u0026#34;status\u0026#34;: { \u0026#34;expStatuses\u0026#34;: [ { \u0026#34;action\u0026#34;: \u0026#34;kill\u0026#34;, \u0026#34;error\u0026#34;: \u0026#34;the resources not found\u0026#34;, \u0026#34;scope\u0026#34;: \u0026#34;container\u0026#34;, \u0026#34;state\u0026#34;: \u0026#34;Error\u0026#34;, \u0026#34;success\u0026#34;: false, \u0026#34;target\u0026#34;: \u0026#34;process\u0026#34; } ], \u0026#34;phase\u0026#34;: \u0026#34;Error\u0026#34; } A: container 没有找到\nQ:\n\u0026#34;status\u0026#34;: { \u0026#34;expStatuses\u0026#34;: [ { \u0026#34;action\u0026#34;: \u0026#34;kill\u0026#34;, \u0026#34;error\u0026#34;: \u0026#34;see resStatus for the error details\u0026#34;, \u0026#34;resStatuses\u0026#34;: [ { \u0026#34;error\u0026#34;: \u0026#34;top process not found exit status 1\u0026#34;, \u0026#34;kind\u0026#34;: \u0026#34;container\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;php-redis\u0026#34;, \u0026#34;nodeName\u0026#34;: \u0026#34;cn-hangzhou.192.168.0.204\u0026#34;, \u0026#34;state\u0026#34;: \u0026#34;Error\u0026#34;, \u0026#34;success\u0026#34;: false, \u0026#34;uid\u0026#34;: \u0026#34;f1de335b4eeaf035b8d23a87080f3d24cebc803cbb6ad15e5fe0d8567e2e8939\u0026#34; } ], \u0026#34;scope\u0026#34;: \u0026#34;container\u0026#34;, \u0026#34;state\u0026#34;: \u0026#34;Error\u0026#34;, \u0026#34;success\u0026#34;: false, \u0026#34;target\u0026#34;: \u0026#34;process\u0026#34; } ], \u0026#34;phase\u0026#34;: \u0026#34;Error\u0026#34; } A：目标进程找不到\n","excerpt":"命令 支持的进程场景命令如下：\n blade create k8s container-process kill 杀容器内指定进程，同 blade create process kill blade …","ref":"/docs/binaries/create/k8s/container/container-process/","title":"容器内进程场景"},{"body":"执行你的第一个混沌实验 我们拿 CPU 满载(CPU 使用率 100%) 演练场景举例（！！注意，在不清楚影响面的情况下，切勿在生产系统机器上执行），执行以下命令实施实验：\n开始实验 ./blade create cpu fullload 执行结果返回：\n{\u0026#34;code\u0026#34;:200,\u0026#34;success\u0026#34;:true,\u0026#34;result\u0026#34;:\u0026#34;7c1f7afc281482c8\u0026#34;} 查看故障 通过 top 命令查看 CPU 使用率\nCPU usage: 93.79% user, 6.20% sys, 0.0% idle 停止实验 此时命令已经生效，停止混沌实验，执行：\n./blade destroy 7c1f7afc281482c8 返回以下结果，表示停止实验成功\n{\u0026#34;code\u0026#34;:200,\u0026#34;success\u0026#34;:true,\u0026#34;result\u0026#34;:\u0026#34;command: cpu fullload --debug false --help false\u0026#34;} 再去观察 CPU 情况，CPU 负载已回到正常状态：\nCPU usage: 6.36% user, 4.74% sys, 88.88% idle 一次 CPU 满载演练完成。\n你的第二个混沌实验 下载 demo 这次实验，我们演练 Dubbo 应用，我们的需求是 consumer 调用 com.alibaba.demo.HelloService 服务下的 hello 接口延迟 3 秒。接下来我们下载所需要的 Dubbo Demo：\ndubbo-provider\ndubbo-consumer\n下载完成后，执行以下命令启动应用，注意必须先启动 dubbo-provider，然后再启动 dubbo-consumer:\n# 启动 dubbo-provider nohup java -Djava.net.preferIPv4Stack=true -Dproject.name=dubbo-provider -jar dubbo-provider-1.0-SNAPSHOT.jar \u0026gt; provider.nohup.log 2\u0026gt;\u0026amp;1 \u0026amp; # 稍等 2 秒，然后启动 dubbo-consumer nohup java -Dserver.port=8080 -Djava.net.preferIPv4Stack=true -Dproject.name=dubbo-consumer -jar dubbo-consumer-1.0-SNAPSHOT.jar \u0026gt; consumer.nohup.log 2\u0026gt;\u0026amp;1 \u0026amp; 访问 http://localhost:8080/hello?msg=world，返回以下信息，表示启动成功：\n{ msg: \u0026#34;Dubbo Service: Hello world\u0026#34; } 实验准备 接下来我们要使用 blade 工具进行混沌实验，在执行实验前，我们需要先执行 prepare 命令，挂载所需要的 java agent：\n./blade prepare jvm --process dubbo-consumer 返回以下结果，表示实验准备成功：\n{\u0026#34;code\u0026#34;:200,\u0026#34;success\u0026#34;:true,\u0026#34;result\u0026#34;:\u0026#34;e669d57f079a00cc\u0026#34;} 接口延迟实验 我们开始实施混沌实验，我们的需求是 consumer 调用 com.alibaba.demo.HelloService 服务下的 hello 接口延迟 3 秒。 我们执行 ./blade create dubbo delay -h 命令查看 dubbo 调用延迟的命令用法：\nUsage: blade create dubbo delay Flags: --appname string The consumer or provider application name --consumer To tag consumer role experiment. -h, --help help for delay --methodname string The method name in service interface --offset string delay offset for the time --process string Application process name --provider To tag provider experiment --service string The service interface --time string delay time (required) --version string the service version Global Flags: -d, --debug Set client to DEBUG mode 调用 com.alibaba.demo.HelloService 服务下的 hello 接口延迟 3 秒，我们执行以下命令：\n./blade create dubbo delay --time 3000 --service com.alibaba.demo.HelloService --methodname hello --consumer --process dubbo.consumer 查看故障 返回以下结果，表示执行成功；访问 http://localhost:8080/hello?msg=world 验证是否延迟 3 秒\n{\u0026#34;code\u0026#34;:200,\u0026#34;success\u0026#34;:true,\u0026#34;result\u0026#34;:\u0026#34;ec695fee1e458fc6\u0026#34;} 对实施实验的命令进行解析：\n --time: 3000，表示延迟 3000 ms；单位是 ms --service: com.alibaba.demo.HelloService， 表示调用的服务 --methodname: hello，表示服务接口方法 --consumer: 表示演练的是 dubbo consumer --process: dubbo.consumer，表示对哪个应用进程实施混沌实验  停止实验 停止当前延迟的混沌实验，再次访问 url 验证是否恢复正常：\n./blade destroy ec695fee1e458fc6 不尽兴的话，我们再实施调用刚才那个服务抛异常，执行 ./blade create dubbo throwCustomException -h 命令查看帮助：\nThrow custom exception with --exception option Usage: blade create dubbo throwCustomException Aliases: throwCustomException, tce Flags: --appname string The consumer or provider application name --consumer To tag consumer role experiment. --exception string Exception class inherit java.lang.Exception (required) -h, --help help for throwCustomException --methodname string The method name in service interface --process string Application process name --provider To tag provider experiment --service string The service interface --version string the service version Global Flags: -d, --debug Set client to DEBUG mode 抛出异常实验 和刚才延迟命令参数差不多，因为相同的参数是演练 dubbo 所需要的，不同的是没有了 --time，多了个 --exception 参数。 我们模拟调用刚才的服务抛 java.lang.Exception 异常：\n./blade create dubbo throwCustomException --exception java.lang.Exception --service com.alibaba.demo.HelloService --methodname hello --consumer --process dubbo.consumer 查看故障 返回以下结果，访问 http://localhost:8080/hello?msg=world 验证是否异常\n{\u0026#34;code\u0026#34;:200,\u0026#34;success\u0026#34;:true,\u0026#34;result\u0026#34;:\u0026#34;09dd96f4c062df69\u0026#34;} 停止实验 停止此次试验，再次访问请求，验证是否恢复：\n./blade destroy 09dd96f4c062df69 销毁实验 最后，我们撤销刚才的实验准备，即卸载 Java Agent：\n./blade revoke e669d57f079a00cc 如果找不到之前执行 prepare 返回的 UID 的话，执行 ./blade status --type prepare 命令查询：\n{ \u0026#34;code\u0026#34;: 200, \u0026#34;success\u0026#34;: true, \u0026#34;result\u0026#34;: [ { \u0026#34;Uid\u0026#34;: \u0026#34;e669d57f079a00cc\u0026#34;, \u0026#34;ProgramType\u0026#34;: \u0026#34;jvm\u0026#34;, \u0026#34;Process\u0026#34;: \u0026#34;dubbo.consumer\u0026#34;, \u0026#34;Port\u0026#34;: \u0026#34;59688\u0026#34;, \u0026#34;Status\u0026#34;: \u0026#34;Running\u0026#34;, \u0026#34;Error\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;CreateTime\u0026#34;: \u0026#34;2019-03-29T16:19:37.284579975+08:00\u0026#34;, \u0026#34;UpdateTime\u0026#34;: \u0026#34;2019-03-29T17:05:14.183382945+08:00\u0026#34; } ] } ","excerpt":"执行你的第一个混沌实验 我们拿 CPU 满载(CPU 使用率 100%) 演练场景举例（！！注意，在不清楚影响面的情况下，切勿在生产系统机器上执行），执行以下命令实施实验：\n开始实验 ./blade …","ref":"/docs/quickstart/first-exp/","title":"开始混沌实验"},{"body":"介绍 模拟磁盘填充，可以指定填充的目录和填充大小。\n验证磁盘满下对系统服务的影响，比如监控告警、服务稳定性等。\n参数 --path string 需要填充的目录，默认值是 / --size string 需要填充的文件大小，单位是 M，取值是整数，例如 --size 1024 --reserve string 保留磁盘大小，单位是MB。取值是不包含单位的正整数，例如 --reserve 1024。如果 size、percent、reserve 参数都存在，优先级是 percent \u0026gt; reserve \u0026gt; size --percent string 指定磁盘使用率，取值是不带%号的正整数，例如 --percent 80 --retain-handle 是否保留填充 --timeout string 设定运行时长，单位是秒，通用参数 案例 # 执行实验之前，先看下 /home 所在磁盘的大小 df -h /home Filesystem Size Used Avail Use% Mounted on /dev/vda1 40G 4.0G 34G 11% / # 执行磁盘填充，填充 40G，即达到磁盘满的效果（可用34G） blade create disk fill --path /home --size 40000 # 返回结果 {\u0026#34;code\u0026#34;:200,\u0026#34;success\u0026#34;:true,\u0026#34;result\u0026#34;:\u0026#34;7a3d53b0e91680d9\u0026#34;} # 查看磁盘大小 df -h /home Filesystem Size Used Avail Use% Mounted on /dev/vda1 40G 40G 0 100% / # 销毁实验 blade destroy 7a3d53b0e91680d9 {\u0026#34;code\u0026#34;:200,\u0026#34;success\u0026#34;:true,\u0026#34;result\u0026#34;:\u0026#34;command: disk fill --debug false --help false --path /home --size 40000\u0026#34;} # 查看磁盘大小 df -h /home Filesystem Size Used Avail Use% Mounted on /dev/vda1 40G 4.0G 34G 11% / # 执行按百分比填充磁盘，并且保留填充磁盘的文件句柄 blade c disk fill --path /home --percent 80 --retain-handle {\u0026#34;code\u0026#34;:200,\u0026#34;success\u0026#34;:true,\u0026#34;result\u0026#34;:\u0026#34;f1fa65e70950d0eb\u0026#34;} df -h /dev/vda1 40G 30G 8.1G 79% / # 查看文件句柄 lsof /home/chaos_filldisk.log.dat COMMAND PID USER FD TYPE DEVICE SIZE/OFF NODE NAME chaos_fil 19297 root 3r REG 253,1 17697865728 394174 /home/chaos_filldisk.log.dat # 执行保留固定大小实验场景 blade c disk fill --path /home --reserve 1024 df -h Filesystem Size Used Avail Use% Mounted on /dev/vda1 40G 37G 1.1G 98% / 实验原理 使用 fallocate、dd 命令实现\n场景问题 ","excerpt":"介绍 模拟磁盘填充，可以指定填充的目录和填充大小。\n验证磁盘满下对系统服务的影响，比如监控告警、服务稳定性等。\n参数 --path string 需要填充的目录，默认值是 / --size …","ref":"/docs/binaries/create/disk/disk-fill/","title":"磁盘填充混沌实验"},{"body":"介绍 可以指定网卡、本地端口、远程端口、目标 IP 丢包。需要特别注意，如果不指定端口、ip 参数，而是整个网卡丢包，切记要添加 \u0026ndash;timeout 参数或者 \u0026ndash;exclude-port 参数，前者是指定运行时间，自动停止销毁实验，后者是指定排除掉的丢包端口，两者都是防止因丢包率设置太高，造成机器无法连接的情况，如果真实发生此问题，重启机器即可恢复。\n本地端口和远程端口之间是或的关系，即这两个端口都会发生丢包，只要指定了本地端口或者远程端口，无需指定需要排除的端口。端口与 IP 之间是与的关系，即指定的 IP:PORT 发生丢包。\n网络丢包场景主要验证网络异常的情况下，系统的自我容错能力。\n参数 --destination-ip string 目标 IP. 支持通过子网掩码来指定一个网段的IP地址, 例如 192.168.1.0/24. 则 192.168.1.0~192.168.1.255 都生效。你也可以指定固定的 IP，如 192.168.1.1 或者 192.168.1.1/32，也可以通过都号分隔多个参数，例如 192.168.1.1,192.168.2.1。 --exclude-port string 排除掉的端口，默认会忽略掉通信的对端端口，目的是保留通信可用。可以指定多个，使用逗号分隔或者连接符表示范围，例如 22,8000 或者 8000-8010。 这个参数不能与 --local-port 或者 --remote-port 参数一起使用 --exclude-ip string 排除受影响的 IP，支持通过子网掩码来指定一个网段的IP地址, 例如 192.168.1.0/24. 则 192.168.1.0~192.168.1.255 都生效。你也可以指定固定的 IP，如 192.168.1.1 或者 192.168.1.1/32，也可以通过都号分隔多个参数，例如 192.168.1.1,192.168.2.1。 --interface string 网卡设备，例如 eth0 (必要参数) --local-port string 本地端口，一般是本机暴露服务的端口。可以指定多个，使用逗号分隔或者连接符表示范围，例如 80,8000-8080 --percent string 丢包百分比，取值在[0, 100]的正整数 (必要参数) --remote-port string 远程端口，一般是要访问的外部暴露服务的端口。可以指定多个，使用逗号分隔或者连接符表示范围，例如 80,8000-8080 --force 强制覆盖已有的 tc 规则，请务必在明确之前的规则可覆盖的情况下使用 --ignore-peer-port 针对添加 --exclude-port 参数，报 ss 命令找不到的情况下使用，忽略排除端口 --timeout string 设定运行时长，单位是秒，通用参数 案例 # 访问本机 8080 和 8081 端口丢包率 70% blade create network loss --percent 70 --interface eth0 --local-port 8080,8081 {\u0026#34;code\u0026#34;:200,\u0026#34;success\u0026#34;:true,\u0026#34;result\u0026#34;:\u0026#34;b1cea124e2383848\u0026#34;} # 可以在另一台相同网络内的机器通过 curl 命令验证，即 curl xxx.xxx.xxx.xxx:8080，不使用 telnet 的原因是 telnet 内部有重试机制，影响实验验证。如果将 percent 的值设置为 100，可以使用 telnet 验证。 # 销毁实验 blade destroy b1cea124e2383848 # 本机访问外部 14.215.177.39 机器（ping www.baidu.com 获取到的 IP）80 端口丢包率 100% blade create network loss --percent 100 --interface eth0 --remote-port 80 --destination-ip 14.215.177.39 # 可在本机通过 curl 14.215.177.39 命令验证，会发现访问不通。执行 curl 14.215.177.38 是通的。 # 对整个网卡 eth0 做 60% 的丢包，排除 22 和 8000到8080 端口 blade create network loss --percent 60 --interface eth0 --exclude-port 22,8000-8080 # 会发现 22 端口和 8000 到 8080 端口不受影响，可在另一台相同网络内的机器通过分别执行多次 curl xxx.xxx.xxx.xxx:8080 和 telnet xxx.xxx.xxx.xxx:8081 进行测试 # 实现整个网卡不可访问，不可访问时间 20 秒。执行完成下面命令后，当前的网络会中断掉，20 秒后恢复。切记！！勿忘 --timeout 参数 blade create network loss --percent 100 --interface eth0 --timeout 20 实现原理 待补充\n常见问题 Q: {\u0026quot;code\u0026quot;:604,\u0026quot;success\u0026quot;:false,\u0026quot;error\u0026quot;:\u0026quot;RTNETLINK answers: File exists\\n exit status 2 exit status 1\u0026quot;}\nA： 网络相关的场景实验已存在，销毁原有的后再执行。 可以通过 blade status \u0026ndash;type create 命令来查看已执行的实验， success 状态的表示正在执行； 如果查找不到相关实验，比如已经删除了原有的 chaosblade 目录，则可通过以下命令恢复实验，注意 eth0 替换为你机器的网卡设备：\ntc filter del dev eth0 parent 1: prio 4 tc qdisc del dev eth0 root 也可以添加 --force 命令强制覆盖原有规则。\n","excerpt":"介绍 可以指定网卡、本地端口、远程端口、目标 IP 丢包。需要特别注意，如果不指定端口、ip 参数，而是整个网卡丢包，切记要添加 \u0026ndash;timeout …","ref":"/docs/binaries/create/network/network-loss/","title":"网络丢包实验场景"},{"body":"","excerpt":"","ref":"/docs/binaries/create/network/","title":"网络场景"},{"body":"参数 以下是此场景特有参数，通用参数详见：blade create jvm\n--effect-count string 影响的请求条数 --effect-percent string 影响的请求百分比 --script-content string 脚本内容，是 Base64 编码后的内容，相关工具类 [Base64Util](https://github.com/chaosblade-io/chaosblade-exec-jvm/blob/master/chaosblade-exec-plugin/chaosblade-exec-plugin-jvm/src/main/java/com/alibaba/chaosblade/exec/plugin/jvm/Base64Util.java)。注意，不能和 script-file 同时使用。 --script-file string 脚本文件，文件绝对路径 --script-name string 脚本名称，日志记录用，可不填写。 --script-type string 脚本类型，取值为 java 或 groovy，默认为 java。 使用 script-content 指定演练脚本内容，不添加 script-type 参数，默认为 java 脚本，将调用 java 引擎解析器。\nblade c jvm script --classname com.example.controller.DubboController --methodname call --script-content aW1wb3J0IGphdmEudXRpbC5NYXA7CgppbXBvcnQgY29tLmV4YW1wbGUuY29udHJvbGxlci5DdXN0b21FeGNlcHRpb247CgovKioKICogQGF1dGhvciBDaGFuZ2p1biBYaWFvCiAqLwpwdWJsaWMgY2xhc3MgRXhjZXB0aW9uU2NyaXB0IHsKICAgIHB1YmxpYyBPYmplY3QgcnVuKE1hcDxTdHJpbmcsIE9iamVjdD4gcGFyYW1zKSB0aHJvd3MgQ3VzdG9tRXhjZXB0aW9uIHsKICAgICAgICBwYXJhbXMucHV0KCIxIiwgMTExTCk7CiAgICAgICAgLy9yZXR1cm4gIk1vY2sgVmFsdWUiOwogICAgICAgIC8vdGhyb3cgbmV3IEN1c3RvbUV4Y2VwdGlvbigiaGVsbG8iKTsKICAgICAgICByZXR1cm4gbnVsbDsKICAgIH0KfQo= --script-name exception 使用 script-file 参数指定文件演练：\nblade c jvm script --classname com.example.controller.DubboController --methodname call --script-file /Users/Shared/IdeaProjects/Workspace_WebApp/dubbodemo/src/main/java/com/example/controller/ExceptionScript.java --script-name exception 执行 groovy 脚本实验场景，参数同上，但必须添加 --script-type groovy 参数。如\nblade c jvm script --classname com.example.controller.DubboController --methodname call --script-file /Users/Shared/IdeaProjects/Workspace_WebApp/dubbodemo/src/main/java/com/example/controller/GroovyScript.groovy --script-name exception --script-type groovy 脚本规范  必须创建一个类，对类名和包名没有要求，其中所依赖的类，必须是目标应用所具备的类。 同包下的类引用，必须写全包名，比如故障脚本类是 com.example.controller.ExceptionScript，类中引入了同包下的 DubboController 类，则 DubboController 必须添加 com.example.controller.DubboController。引入非同包下的类，无需写全包名。 必须添加 public Object run(Map\u0026lt;String, Object\u0026gt; params) 方法，其中 params 对象中包含目标方法参数，key 是参数索引下标，从 0 开始，比如目标方法是 public String call(Object obj1, Object obj2){}，则 params.get(\u0026quot;0\u0026quot;) 则返回的是 obj1 对象，可以执行 params.put(\u0026quot;0\u0026quot;, \u0026lt;NEW OBJECT\u0026gt;) 来修改目标方法参数（目标方法及 --classname 和 --methodname 所指定的类方法）。 上述方法返回的对象如果不为空，则会根据脚本中返回的对象来修改目标方法返回值，注意类型必须和目标方法返回值一致。如果上述方法返回 null，则不会修改目标方法返回值。  案例 对以下业务类做修改返回值实验场景：\n@RestController @RequestMapping(\u0026#34;/pet\u0026#34;) public class PetController { @GetMapping(\u0026#34;/list\u0026#34;) public Result\u0026lt;List\u0026lt;PetVO\u0026gt;\u0026gt; getPets() { Map\u0026lt;Long, Discount\u0026gt; petDiscount = discountManager .getPetDiscounts() .stream() .filter(discount -\u0026gt; discount.getExpired() == 0) .collect(Collectors.toMap( Discount::getPetId, Function.identity() )); List\u0026lt;PetVO\u0026gt; pets = petManager .getPets() .stream() .map(pet -\u0026gt; { PetVO petVO = PetVO.from(pet); Discount discount = petDiscount.get(pet.getId()); if (null != discount \u0026amp;\u0026amp; null != discount.getDiscountPrice() \u0026amp;\u0026amp; discount.getDiscountPrice() \u0026gt; 0L) { petVO.setDiscountPrice(discount.getDiscountPrice()); } return petVO; }) .collect(Collectors.toList()); return Result.success(pets); } 则编写 Java 脚本，实现对 getPets 方法做返回值修改：\npackage com.alibaba.csp.monkeyking.controller; import java.util.ArrayList; import java.util.List; import java.util.Map; import com.alibaba.csp.monkeyking.demo.model.Pet; import com.alibaba.csp.monkeyking.model.PetVO; import com.alibaba.csp.monkeyking.model.Result; public class ChaosController { public Object run(Map\u0026lt;String, Object\u0026gt; params) { ArrayList\u0026lt;PetVO\u0026gt; petVOS = new ArrayList\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; 3; i++) { Pet pet = new Pet(); pet.setName(\u0026#34;test_\u0026#34; + i); PetVO petVO = PetVO.from(pet); petVOS.add(petVO); } Result\u0026lt;List\u0026lt;PetVO\u0026gt;\u0026gt; results = Result.success(petVOS); return results; } } 保存文件后，通过上面 使用方式 部分的命令来调用，也可以将其进行 Base64 编码，通过指定 script-content 参数来指定编码后的内容。\nblade c jvm script --classname com.alibaba.csp.monkeyking.controller.PetController --methodname getPets --script-file /Users/Shared/IdeaProjects/Workspace_WebApp/dubbodemo/src/main/java/com/alibaba/csp/monkeyking/controller/ChaosController --script-name specifyReturnObj 未执行实验之前页面：\n执行实验之后：\n常见问题 Java 实验场景的日志在 进程用户下 logs/chaosblade/chaosblade.log 中。执行脚本成功，但不生效，原因可能是脚本编译错误（因为脚本编译方法调用时触发，所以下发脚本，不会进行编译），可查看此日志进行排查。\n","excerpt":"参数 以下是此场景特有参数，通用参数详见：blade create jvm\n--effect-count string 影响的请求条数 --effect-percent string …","ref":"/docs/binaries/create/java/jvm/jvm-script/","title":"脚本实现复杂的故障场景"},{"body":"命令 支持的进程场景命令如下：\n blade create k8s node-process kill 杀节点上指定进程，同 blade create process kill blade create k8s node-process stop 挂起节点上指定进程，同 blade create process stop  参数 除了上述基础场景各自所需的参数外，在 kubernetes 环境下，还支持的参数如下：\n--evict-count string 限制实验生效的数量 --evict-percent string 限制实验生效数量的百分比，不包含 % --labels string 节点资源标签 --names string 节点资源名，多个资源名之间使用逗号分隔 --kubeconfig string kubeconfig 文件全路径（仅限使用 blade 命令调用时使用） --waiting-time string 实验结果等待时间，默认为 20s，参数值要包含单位，例如 10s，1m 案例 杀指定 cn-hangzhou.192.168.0.205 节点上 kubelet 进程\nblade 执行方式 blade create k8s node-process kill --process redis-server --names cn-hangzhou.192.168.0.205 --kubeconfig config 如果执行失败，会返回详细的错误信息；如果执行成功，会返回实验的 UID：\n{\u0026#34;code\u0026#34;:200,\u0026#34;success\u0026#34;:true,\u0026#34;result\u0026#34;:\u0026#34;fc93e5bbe4827d4b\u0026#34;} 可通过以下命令查询实验状态：\nblade query k8s create fc93e5bbe4827d4b --kubeconfig config {\u0026#34;code\u0026#34;:200,\u0026#34;success\u0026#34;:true,\u0026#34;result\u0026#34;:{\u0026#34;uid\u0026#34;:\u0026#34;fc93e5bbe4827d4b\u0026#34;,\u0026#34;success\u0026#34;:true,\u0026#34;error\u0026#34;:\u0026#34;\u0026#34;,\u0026#34;statuses\u0026#34;:[{\u0026#34;id\u0026#34;:\u0026#34;859c56e6850c1c1b\u0026#34;,\u0026#34;uid\u0026#34;:\u0026#34;e179b30d-df77-11e9-b3be-00163e136d88\u0026#34;,\u0026#34;name\u0026#34;:\u0026#34;cn-hangzhou.192.168.0.205\u0026#34;,\u0026#34;state\u0026#34;:\u0026#34;Success\u0026#34;,\u0026#34;kind\u0026#34;:\u0026#34;node\u0026#34;,\u0026#34;success\u0026#34;:true,\u0026#34;nodeName\u0026#34;:\u0026#34;cn-hangzhou.192.168.0.205\u0026#34;}]}} 可以看到执行前后，redis-server 的进程号发生改变，说明被杀掉后，又被重新拉起\n# ps -ef | grep redis-server 19497 root 2:05 redis-server *:6379 # ps -ef | grep redis-server 31855 root 0:00 redis-server *:6379 销毁实验 blade destroy fc93e5bbe4827d4b kubectl 执行方式 yaml 的配置方式见：Kubernetes 杀节点上指定进程\n","excerpt":"命令 支持的进程场景命令如下：\n blade create k8s node-process kill 杀节点上指定进程，同 blade create process kill blade …","ref":"/docs/binaries/create/k8s/node/node-process/","title":"节点进程相关场景"},{"body":"","excerpt":"","ref":"/docs/operator/node/node-process/","title":"Node 进程相关场景"},{"body":"","excerpt":"","ref":"/docs/binaries/revoke/","title":"revoke 命令"},{"body":"面向云原生 chaosblade-operator 项目是针对云原生平台所实现的混沌实验注入工具，遵循混沌实验模型规范化实验场景，把实验定义为 Kubernetes CRD 资源，将实验模型映射为 Kubernetes 资源属性，很友好的将混沌实验模型与 Kubernetes 声明式设计结合在一起，依靠混沌实验模型便捷开发场景的同时，又可以很好的结合 Kubernetes 设计理念，通过 kubectl 或者编写代码直接调用 Kubernetes API 来创建、更新、删除混沌实验，而且资源状态可以非常清晰的表示实验的执行状态，标准化实现 Kubernetes 故障注入。除了使用上述方式执行实验外，还可以使用 chaosblade cli 方式非常方便的执行 kubernetes 实验场景，查询实验状态等。\n具体请阅读：云原生下的混沌工程实践\nGuestbook 文档中的示例实验会用到 guestbook 应用，尝试之前请先安装。\n# helm 3 # add repo $ helm repo add apphub-incubator https://apphub.aliyuncs.com/incubator/ # install $ helm install guestbook apphub-incubator/guestbook --set service.type=NodePort --namespace=chaosblade  默认的 Service 类型为 LoadBalancer，这里为了方便访问设置为了 NodePort。\n ","excerpt":"面向云原生 chaosblade-operator 项目是针对云原生平台所实现的混沌实验注入工具，遵循混沌实验模型规范化实验场景，把实验定义为 Kubernetes CRD 资源， …","ref":"/docs/operator/","title":"云原生场景"},{"body":"介绍 指定内存占用，注意，此场景触发内存占用满，即使指定了 \u0026ndash;timeout 参数，也可能出现通过 blade 工具无法恢复的情况，可通过重启机器解决！！！推荐指定内存百分比！\n由于目前内存大小计算通过 memory.stat 等文件计算，所以和 free 命令计算不一致，同 top 命令一致，验证时请使用 top 命令查看内存使用。后续会针对内存占用场景进行优化。\n参数 --mem-percent string 内存使用率，取值是 0 到 100 的整数 --mode string 内存占用模式，有 ram 和 cache 两种，例如 --mode ram。ram 采用代码实现，可控制占用速率，优先推荐此模式；cache 是通过挂载tmpfs实现；默认值是 --mode cache --reserve string 保留内存的大小，单位是MB，如果 mem-percent 参数存在，则优先使用 mem-percent 参数 --rate string 内存占用速率，单位是 MB/S，仅在 --mode ram 时生效 --timeout string 设定运行时长，单位是秒，通用参数 案例 # 在执行命令之前，先使用 top 命令查看内存使用信息，如下，总内存大小是 8G，使用了 7.6% KiB Mem : 7.6/8010196 # 执行内存占用 50% blade c mem load --mode ram --mem-percent 50 # 查看内存使用 KiB Mem : 50.0/8010196 # 执行内存占用 100% KiB Mem : 99.6/8010196 # 保留 200M 内存，总内存大小 1G blade c mem load --mode ram --reserve 200 --rate 100 KiB Mem : 1014744 total, 78368 free, 663660 used, 272716 buff/cache KiB Swap: 0 total, 0 free, 0 used. 209652 avail Mem KiB Mem : 79.7/1014744 [|||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||| ] 实现原理 ram 模式采用代码申请内存实现 cache 模式采用 dd、mount 命令实现，挂载 tmpfs 并且进行文件填充\n常见错误 Q：如果执行了内存满载，无法恢复，如何处理\nA：重启机器恢复\n","excerpt":"介绍 指定内存占用，注意，此场景触发内存占用满，即使指定了 \u0026ndash;timeout 参数，也可能出现通过 blade 工具无法恢复的情况，可通过重启机器解决！！！推荐指定内存百分比！\n由于目前内 …","ref":"/docs/binaries/create/resource/mem-load/","title":"内存占用"},{"body":"命令 支持场景命令如下\n blade create docker container remove 删除容器  参数 --container-id string 要删除的容器 ID --docker-endpoint string Docker server 地址，默认为本地的 /var/run/docker.sock --force 是否强制删除 删除容器后，执行 blade destroy UID 命令不会恢复容器，需要靠容器自身的管理拉起！\n案例 删除 container id 是 a76d53933d3f 的容器，命令如下：\nblade create docker container remove --container-id a76d53933d3f 如果返回 {\u0026quot;code\u0026quot;:200,\u0026quot;success\u0026quot;:true,\u0026quot;result\u0026quot;:\u0026quot;ed79c686daa88152\u0026quot;} 说明执行成功。如果执行失败，会有详细的错误提升。\n常见问题 ","excerpt":"命令 支持场景命令如下\n blade create docker container remove 删除容器  参数 --container-id string 要删除的容器 ID …","ref":"/docs/binaries/create/docker/docker-container/","title":"容器资源自身的场景"},{"body":"命令 支持场景命令如下\n blade create k8s container-container remove 删除容器  参数 --container-ids string 容器ID，支持配置多个 --container-names string 容器名称，支持配置多个 --docker-endpoint string Docker server 地址，默认为本地的 /var/run/docker.sock --namespace string Pod 所属的命名空间，只能填写一个值，必填项 --evict-count string 限制实验生效的数量 --evict-percent string 限制实验生效数量的百分比，不包含 % --labels string Pod 资源标签，多个标签之前是或的关系 --names string Pod 资源名 --kubeconfig string kubeconfig 文件全路径（仅限使用 blade 命令调用时使用） --waiting-time string 实验结果等待时间，默认为 20s，参数值要包含单位，例如 10s，1m --force 是否强制删除 案例 删除 default 命名空间下，Pod 名为 frontend-d89756ff7-szblb 下的 container id 是 072aa6bbf2e2e2 的容器\nblade 执行方式 blade create k8s container-container remove --container-ids 060833967b0a37 --names frontend-d89756ff7-szblb --namespace default --kubeconfig config 如果执行失败，会返回详细的错误信息；如果执行成功，会返回实验的 UID：\n{\u0026#34;code\u0026#34;:200,\u0026#34;success\u0026#34;:true,\u0026#34;result\u0026#34;:\u0026#34;17d7021c777b76e3\u0026#34;} 可通过以下命令查询实验状态：\nblade query k8s create 17d7021c777b76e3 --kubeconfig config {\u0026#34;code\u0026#34;:200,\u0026#34;success\u0026#34;:true,\u0026#34;result\u0026#34;:{\u0026#34;uid\u0026#34;:\u0026#34;17d7021c777b76e3\u0026#34;,\u0026#34;success\u0026#34;:true,\u0026#34;error\u0026#34;:\u0026#34;\u0026#34;,\u0026#34;statuses\u0026#34;:[{\u0026#34;id\u0026#34;:\u0026#34;205515ad8fcc31da\u0026#34;,\u0026#34;uid\u0026#34;:\u0026#34;060833967b0a3733d10f0e64d3639066b8b7fbcf371e0ace2401af150dbd9b12\u0026#34;,\u0026#34;name\u0026#34;:\u0026#34;php-redis\u0026#34;,\u0026#34;state\u0026#34;:\u0026#34;Success\u0026#34;,\u0026#34;kind\u0026#34;:\u0026#34;container\u0026#34;,\u0026#34;success\u0026#34;:true,\u0026#34;nodeName\u0026#34;:\u0026#34;cn-hangzhou.192.168.0.205\u0026#34;}]}} 执行前后，可以看到 Pod 内容器的变化:\n执行前：\n执行后：\n销毁实验 blade destroy 17d7021c777b76e3  Warning 删除容器后，执行销毁实验命令不会恢复容器，需要靠容器自身的管理拉起！  kubectl 执行方式 yaml 的配置方式见：Kubernetes 删除 Container 场景\n","excerpt":"命令 支持场景命令如下\n blade create k8s container-container remove 删除容器  参数 --container-ids string 容器ID， …","ref":"/docs/binaries/create/k8s/container/container-container/","title":"容器资源自身的场景"},{"body":" 命令可以简写为 blade c jvm cfl\n 参数 以下是此场景特有参数，通用参数详见：blade create jvm\n--cpu-count string 绑定的 CPU 核数，即指定几个核满载 案例 指定全部核满载\nblade c jvm cfl --process tomcat {\u0026#34;code\u0026#34;:200,\u0026#34;success\u0026#34;:true,\u0026#34;result\u0026#34;:\u0026#34;48d70f01e65f68f7\u0026#34;} 查看该进程 CPU 使用率：\n停止实验：\nblade d 48d70f01e65f68f7 指定两个核满载（测试机器是 8 个核）\nblade c jvm cfl --cpu-count 2 --process tomcat {\u0026#34;code\u0026#34;:200,\u0026#34;success\u0026#34;:true,\u0026#34;result\u0026#34;:\u0026#34;a929157644688b15\u0026#34;} 查看进程 CPU 使用率是满核的四分之一：\n","excerpt":"命令可以简写为 blade c jvm cfl\n 参数 以下是此场景特有参数，通用参数详见：blade create jvm\n--cpu-count string 绑定的 CPU 核数，即指定几个核满 …","ref":"/docs/binaries/create/java/jvm/jvm-cpufullload/","title":"指定 java 进程 CPU 满载"},{"body":"命令 支持磁盘场景命令如下：\n blade create k8s node-disk fill，节点磁盘填充，同 blade create disk fill blade create k8s node-disk burn，节点磁盘IO读写负载，同 blade create disk burn  参数 除了上述基础场景各自所需的参数外，在 kubernetes 环境下，还支持的参数如下：\n--evict-count string 限制实验生效的数量 --evict-percent string 限制实验生效数量的百分比，不包含 % --labels string 节点资源标签 --names string 节点资源名，多个资源名之间使用逗号分隔 --kubeconfig string kubeconfig 文件全路径（仅限使用 blade 命令调用时使用） --waiting-time string 实验结果等待时间，默认为 20s，参数值要包含单位，例如 10s，1m 案例 指定节点磁盘占用 80%\nblade 命令执行方式 blade c k8s node-disk fill --names cn-hangzhou.192.168.0.35 --percent 80 --kubeconfig ~/.kube/config {\u0026#34;code\u0026#34;:200,\u0026#34;success\u0026#34;:true,\u0026#34;result\u0026#34;:\u0026#34;ec322fbb977a455c\u0026#34;} df -h Filesystem Size Used Available Use% Mounted on /dev/vda1 118.0G 89.0G 24.0G 79% / # 恢复实验 blade d ec322fbb977a455c {\u0026#34;code\u0026#34;:200,\u0026#34;success\u0026#34;:true,\u0026#34;result\u0026#34;:{\u0026#34;Target\u0026#34;:\u0026#34;node-disk\u0026#34;,\u0026#34;Scope\u0026#34;:\u0026#34;\u0026#34;,\u0026#34;ActionName\u0026#34;:\u0026#34;fill\u0026#34;,\u0026#34;ActionFlags\u0026#34;:{\u0026#34;kubeconfig\u0026#34;:\u0026#34;~/.kube/config\u0026#34;,\u0026#34;names\u0026#34;:\u0026#34;cn-hangzhou.192.168.0.35\u0026#34;,\u0026#34;percent\u0026#34;:\u0026#34;80\u0026#34;}}} df -h Filesystem Size Used Available Use% Mounted on /dev/vda1 118.0G 74.8G 38.1G 66% / 使用 blade 命令执行，如果执行失败，会返回详细的错误信息；如果执行成功，会返回实验的 UID，使用查询命令可以查询详细的实验结果：\nblade query k8s create \u0026lt;UID\u0026gt; kubectl 执行方式 yaml 的配置方式见：Kubernetes Node 磁盘填充场景\n","excerpt":"命令 支持磁盘场景命令如下：\n blade create k8s node-disk fill，节点磁盘填充，同 blade create disk fill blade create k8s …","ref":"/docs/binaries/create/k8s/node/node-disk/","title":"节点磁盘相关场景"},{"body":"介绍 可以指定网卡、本地端口、远程端口、目标 IP 包损坏。需要特别注意，如果不指定端口、ip 参数，而是整个网卡包损坏，切记要添加 \u0026ndash;timeout 参数或者 \u0026ndash;exclude-port 参数，前者是指定运行时间，自动停止销毁实验，后者是指定排除掉的延迟端口，两者都是防止机器无法连接的情况，如果真实发生此问题，重启机器即可恢复。\n本地端口和远程端口之间是或的关系，即这两个端口都会生效，只要指定了本地端口或者远程端口，无需指定需要排除的端口。端口与 IP 之间是与的关系，即指定的 IP:PORT 发生包损坏。\n参数 --destination-ip string 目标 IP. 支持通过子网掩码来指定一个网段的IP地址, 例如 192.168.1.0/24. 则 192.168.1.0~192.168.1.255 都生效。你也可以指定固定的 IP，如 192.168.1.1 或者 192.168.1.1/32，也可以通过都号分隔多个参数，例如 192.168.1.1,192.168.2.1。 --exclude-port string 排除掉的端口，默认会忽略掉通信的对端端口，目的是保留通信可用。可以指定多个，使用逗号分隔或者连接符表示范围，例如 22,8000 或者 8000-8010。 这个参数不能与 --local-port 或者 --remote-port 参数一起使用 --exclude-ip string 排除受影响的 IP，支持通过子网掩码来指定一个网段的IP地址, 例如 192.168.1.0/24. 则 192.168.1.0~192.168.1.255 都生效。你也可以指定固定的 IP，如 192.168.1.1 或者 192.168.1.1/32，也可以通过都号分隔多个参数，例如 192.168.1.1,192.168.2.1。 --interface string 网卡设备，例如 eth0 (必要参数) --local-port string 本地端口，一般是本机暴露服务的端口。可以指定多个，使用逗号分隔或者连接符表示范围，例如 80,8000-8080 --offset string 延迟时间上下浮动的值, 单位是毫秒 --remote-port string 远程端口，一般是要访问的外部暴露服务的端口。可以指定多个，使用逗号分隔或者连接符表示范围，例如 80,8000-8080 --percent 包损坏百分比，取值是不带%号的正整数 --force 强制覆盖已有的 tc 规则，请务必在明确之前的规则可覆盖的情况下使用 --ignore-peer-port 针对添加 --exclude-port 参数，报 ss 命令找不到的情况下使用，忽略排除端口 --timeout string 设定运行时长，单位是秒，通用参数 案例 # 访问指定的 ip 请求包损坏，百分比 80% blade create network corrupt --percent 80 --destination-ip 180.101.49.12 --interface eth0 ping 180.101.49.12 64 bytes from 180.101.49.12: icmp_seq=100 ttl=50 time=9.75 ms 64 bytes from 180.101.49.12: icmp_seq=101 ttl=50 time=9.94 ms 64 bytes from 180.101.49.12: icmp_seq=102 ttl=50 time=9.76 ms 64 bytes from 180.101.49.12: icmp_seq=107 ttl=50 time=9.80 ms 64 bytes from 180.101.49.12: icmp_seq=109 ttl=50 time=9.71 ms 64 bytes from 180.101.49.12: icmp_seq=111 ttl=50 time=10.2 ms 64 bytes from 180.101.49.12: icmp_seq=118 ttl=50 time=9.72 ms 64 bytes from 180.101.49.12: icmp_seq=119 ttl=50 time=9.94 ms 64 bytes from 180.101.49.12: icmp_seq=120 ttl=50 time=10.0 ms 64 bytes from 180.101.49.12: icmp_seq=121 ttl=50 time=9.86 ms 64 bytes from 180.101.49.12: icmp_seq=122 ttl=50 time=9.76 ms 可以看出执行命令后 icmp_seq=102 开始出现包丢失的情况，执行恢复命令后，从 icmp_seq=118 开始正常\n实现原理 tc 实现\n常见问题 ","excerpt":"介绍 可以指定网卡、本地端口、远程端口、目标 IP 包损坏。需要特别注意，如果不指定端口、ip 参数，而是整个网卡包损坏，切记要添加 \u0026ndash;timeout …","ref":"/docs/binaries/create/network/network-corrupt/","title":"网络包损坏实验场景"},{"body":"","excerpt":"","ref":"/docs/binaries/create/process/","title":"进程场景"},{"body":"介绍 查询混沌实验和混沌实验环境状态，可通过创建的混沌实验的 uid 或命令类型来查询混沌实验。\nstatus 可以简写为 s，即 blade status 可以简写为 blade s。\n参数 --asc bool 默认值为 false，按 CreateTime 进行降序排序 --limit string 查询实验数目限制，支持 OFFSET 子句，例如：limit 4,3 就表示从位置5开始，返回后3项 --status string 实验状态，create 类型支持 Created|Success|Error|Destroyed 状态，prepare 类型支持 Created|Running|Error|Revoked 状态 --target string 实验目标，例如：dubbo --type string 命令类型，attach|create|destroy|detach --uid string prepare 或 experiment 的 uid -h, --help 查看 create 命令帮助 可使用的父命令参数 -d, --debug 设置 DEBUG 执行模式 案例 # 查看 status 命令帮助文档 blade status -h # 查询 uid 为 4c6b4a3fc313e1d4 的实验信息 blade status 4c6b4a3fc313e1d4 { \u0026#34;code\u0026#34;: 200, \u0026#34;success\u0026#34;: true, \u0026#34;result\u0026#34;: { \u0026#34;Uid\u0026#34;: \u0026#34;4c6b4a3fc313e1d4\u0026#34;, \u0026#34;Command\u0026#34;: \u0026#34;cpu\u0026#34;, \u0026#34;SubCommand\u0026#34;: \u0026#34;fullload\u0026#34;, \u0026#34;Flag\u0026#34;: \u0026#34; --cpu-percent=60\u0026#34;, \u0026#34;Status\u0026#34;: \u0026#34;Destroyed\u0026#34;, \u0026#34;Error\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;CreateTime\u0026#34;: \u0026#34;2020-01-14T14:09:49.152708+08:00\u0026#34;, \u0026#34;UpdateTime\u0026#34;: \u0026#34;2020-01-14T14:10:45.605888+08:00\u0026#34; } } # 查询 create 类型命令的实验信息 blade status --type create { \u0026#34;code\u0026#34;: 200, \u0026#34;success\u0026#34;: true, \u0026#34;result\u0026#34;: [ { \u0026#34;Uid\u0026#34;: \u0026#34;4c6b4a3fc313e1d4\u0026#34;, \u0026#34;Command\u0026#34;: \u0026#34;cpu\u0026#34;, \u0026#34;SubCommand\u0026#34;: \u0026#34;fullload\u0026#34;, \u0026#34;Flag\u0026#34;: \u0026#34; --cpu-percent=60\u0026#34;, \u0026#34;Status\u0026#34;: \u0026#34;Destroyed\u0026#34;, \u0026#34;Error\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;CreateTime\u0026#34;: \u0026#34;2020-01-14T14:09:49.152708+08:00\u0026#34;, \u0026#34;UpdateTime\u0026#34;: \u0026#34;2020-01-14T14:10:45.605888+08:00\u0026#34; } ] } # 查询 prepare 类型命令的实验信息 blade status --type prepare { \u0026#34;code\u0026#34;: 200, \u0026#34;success\u0026#34;: true, \u0026#34;result\u0026#34;: [ { \u0026#34;Uid\u0026#34;: \u0026#34;e669d57f079a00cc\u0026#34;, \u0026#34;ProgramType\u0026#34;: \u0026#34;jvm\u0026#34;, \u0026#34;Process\u0026#34;: \u0026#34;dubbo.consumer\u0026#34;, \u0026#34;Port\u0026#34;: \u0026#34;59688\u0026#34;, \u0026#34;Status\u0026#34;: \u0026#34;Running\u0026#34;, \u0026#34;Error\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;CreateTime\u0026#34;: \u0026#34;2019-03-29T16:19:37.284579975+08:00\u0026#34;, \u0026#34;UpdateTime\u0026#34;: \u0026#34;2019-03-29T17:05:14.183382945+08:00\u0026#34; } ] } 常见问题 Q:{\u0026quot;code\u0026quot;:406,\u0026quot;success\u0026quot;:false,\u0026quot;error\u0026quot;:\u0026quot;data not found\u0026quot;}\nA:查询的实验不存在，可能是数据文件 chaosblade.dat 丢失，这时如果需要停止实验，需要手工停止 blade 进程\n","excerpt":"介绍 查询混沌实验和混沌实验环境状态，可通过创建的混沌实验的 uid 或命令类型来查询混沌实验。\nstatus 可以简写为 s，即 blade status 可以简写为 blade s。 …","ref":"/docs/binaries/status/","title":"status 命令"},{"body":" 命令可以简写为 blade c jvm oom\n 参数 以下是此场景特有参数，通用参数详见：blade create jvm\n--area string JVM 内存区，目前支持 [HEAP, NOHEAP, OFFHEAP]，必填项。用Heap来表示Eden+Old，,用NOHEAP来表示metaspace，用OFFHEAP来表示堆外内存 --block string 指定对象大小，仅支持 HEAP 和 OFFHEAP 区，单位是 MB --interval string 单位ms,默认500两次oom异常间的时间间隔，只有在非暴力模式才生效，可以减缓gc的频率，不用担心进程会无响应 --wild-mode string 默认false,是否开启暴力模式，如果是暴力模式，在OOM发生之后也不会释放之前创建的内存，可能会引起应用进程无响应 案例 堆内存占用：\nblade c jvm oom --area HEAP --wild-mode true --process tomcat {\u0026#34;code\u0026#34;:200,\u0026#34;success\u0026#34;:true,\u0026#34;result\u0026#34;:\u0026#34;99b9228b9632e043\u0026#34;} 故障注入之前：\n故障注入之后：\n停止 HEAP 内存占用：\nblade d 99b9228b9632e043 创建 Metaspace 区内存占用，注意，执行完此场景后，需要重启应用！！！！：\nblade c jvm oom --area NOHEAP --wild-mode true --process tomcat {\u0026#34;code\u0026#34;:200,\u0026#34;success\u0026#34;:true,\u0026#34;result\u0026#34;:\u0026#34;93264dd07149cf54\u0026#34;} 故障注入后：\n实现原理 根据不同区注入 java.lang.OutOfMemoryError: Java heap space 创建\nHeap的话分为Young，Old，这块区域的oom是最好重现，只需要不断的创建对象就可以，如果内存使用达到了 Xmx或者Xmn所规定的大小，并且gc回收不了,就会触发oom错误。\n检查\n 可以通过 jmap -heap pid 来查看当前堆占用情况是否到了100% 可以通过jstat -gcutil pid 来查看是否发生了gc,因为会一直创建新的对象，所以会频繁触发gc操作  恢复\n当演练终止后，会停止产生新的对象，但此时不一定heap就恢复了，因为恢复需要触发gc才可以进行回收,当然也可以通过手动调用 System.gc() 来强行触发 gc，但是如果你的启动参数里面有 -XX:+DisableExplicitGC 那么这个命令就无法生效了.\n注意\n触发 OOM 的时候可能会导致进程被操作系统所 kill，这个原因是因为你的 Xmx 设置的不合理，比如操作系统内存只有 3G，但是你 Xmx 会设置了 3G 甚至更多，那么就会因为系统内存不足，而被 os kill 掉进程，所以这里务必要注意 Xmx 大小\njava.lang.OutOfMemoryError: Metaspace 创建\nMetaspace 可以通过不断的加载类对象来创建，当大小超过了 -XX:MaxMetaspaceSize 并且无法进行 gc 回收就会抛出 oom 错误了。\n检查\n 可以通过 jstat -gcutil pid 来查看 M 区的使用情况以及 gc 的次数  恢复\n类对象的回收条件在 jvm 里面比较苛刻，需要满足很多条件，就算满足了条件，触发 gc 了也不一定回收,只要有下面任何一个条件就无法被回收.\n objects of that class are still reachable. the Class object representing the class is still reachable the ClassLoader that loaded the class is still reachable other classes loaded by the ClassLoader are still reachable  因此最好的办法就是重启应用.\njava.lang.OutOfMemoryError: Direct buffer memoryDirectBuffer 创建\n堆外内存可以直接通过 ByteBuffer.allocateDirect 来产生,并且会一直消耗系统内存.\n检查\n 因为堆外内存不属于堆里面，所以你通过 jmap 命令很难发现，但是可以通过 jstat -gcutil pid 来查看，如果频发出发了 fullgc，但是 e,O,M 区都没发生变化， 那就是进行堆外内存回收 可以通过 free -m 查看内存使用情况  注意\n同样，如果没有设置最大堆外内存大小，同样会因为 OS 的 memory 耗尽而导致进程被杀，所以需要配置比如下面的参数: -XX:MaxDirectMemorySize=100M\n","excerpt":"命令可以简写为 blade c jvm oom\n 参数 以下是此场景特有参数，通用参数详见：blade create jvm\n--area string JVM 内存区，目前支持 [HEAP, …","ref":"/docs/binaries/create/java/jvm/jvm-outofmemoryerror/","title":"内存溢出场景"},{"body":"介绍 可以指定网卡、本地端口、远程端口、目标 IP 包重排。需要特别注意，如果不指定端口、ip 参数，而是整个网卡包重复，切记要添加 \u0026ndash;timeout 参数或者 \u0026ndash;exclude-port 参数，前者是指定运行时间，自动停止销毁实验，后者是指定排除掉不受影响的端口，两者都是防止机器无法连接的情况，如果真实发生此问题，重启机器即可恢复。\n本地端口和远程端口之间是或的关系，即这两个端口都会生效，只要指定了本地端口或者远程端口，无需指定需要排除的端口。端口与 IP 之间是与的关系，即指定的 IP:PORT 发生包重排。\n参数 --destination-ip string 目标 IP. 支持通过子网掩码来指定一个网段的IP地址, 例如 192.168.1.0/24. 则 192.168.1.0~192.168.1.255 都生效。你也可以指定固定的 IP，如 192.168.1.1 或者 192.168.1.1/32，也可以通过都号分隔多个参数，例如 192.168.1.1,192.168.2.1。 --exclude-port string 排除掉的端口，默认会忽略掉通信的对端端口，目的是保留通信可用。可以指定多个，使用逗号分隔或者连接符表示范围，例如 22,8000 或者 8000-8010。 这个参数不能与 --local-port 或者 --remote-port 参数一起使用 --exclude-ip string 排除受影响的 IP，支持通过子网掩码来指定一个网段的IP地址, 例如 192.168.1.0/24. 则 192.168.1.0~192.168.1.255 都生效。你也可以指定固定的 IP，如 192.168.1.1 或者 192.168.1.1/32，也可以通过都号分隔多个参数，例如 192.168.1.1,192.168.2.1。 --interface string 网卡设备，例如 eth0 (必要参数) --local-port string 本地端口，一般是本机暴露服务的端口。可以指定多个，使用逗号分隔或者连接符表示范围，例如 80,8000-8080 --offset string 延迟时间上下浮动的值, 单位是毫秒 --remote-port string 远程端口，一般是要访问的外部暴露服务的端口。可以指定多个，使用逗号分隔或者连接符表示范围，例如 80,8000-8080 --correlation string 和上一包的相关性，取值在 0~100，必要参数，例如 --correlation 70 --gap string 包序列大小，取值是正整数，例如 --gap 5 --percent string 立即发送百分比，取值是不带%号的正整数，例如 --percent 50，(必要参数) --time string 网络包延迟时间，单位是毫秒，默认值是 10，取值时正整数 --force 强制覆盖已有的 tc 规则，请务必在明确之前的规则可覆盖的情况下使用 --ignore-peer-port 针对添加 --exclude-port 参数，报 ss 命令找不到的情况下使用，忽略排除端口 --timeout string 设定运行时长，单位是秒，通用参数 案例 # 访问指定的 ip 请求包乱序 blade c network reorder --correlation 80 --percent 50 --gap 2 --time 500 --interface eth0 --destination-ip 180.101.49.12 ping 180.101.49.12 -A PING 180.101.49.12 (180.101.49.12) 56(84) bytes of data. 64 bytes from 180.101.49.12: icmp_seq=1 ttl=50 time=510 ms 64 bytes from 180.101.49.12: icmp_seq=2 ttl=50 time=9.66 ms 64 bytes from 180.101.49.12: icmp_seq=4 ttl=50 time=9.70 ms 64 bytes from 180.101.49.12: icmp_seq=3 ttl=50 time=509 ms 64 bytes from 180.101.49.12: icmp_seq=6 ttl=50 time=10.0 ms 64 bytes from 180.101.49.12: icmp_seq=5 ttl=50 time=509 ms 64 bytes from 180.101.49.12: icmp_seq=8 ttl=50 time=9.71 ms 64 bytes from 180.101.49.12: icmp_seq=7 ttl=50 time=509 ms 64 bytes from 180.101.49.12: icmp_seq=10 ttl=50 time=9.72 ms 64 bytes from 180.101.49.12: icmp_seq=9 ttl=50 time=509 ms 64 bytes from 180.101.49.12: icmp_seq=11 ttl=50 time=509 ms 64 bytes from 180.101.49.12: icmp_seq=12 ttl=50 time=509 ms 64 bytes from 180.101.49.12: icmp_seq=13 ttl=50 time=509 ms 64 bytes from 180.101.49.12: icmp_seq=15 ttl=50 time=9.90 ms 64 bytes from 180.101.49.12: icmp_seq=14 ttl=50 time=509 ms 64 bytes from 180.101.49.12: icmp_seq=16 ttl=50 time=509 ms 可以看出执行命令后开始出现包乱序的情况，执行恢复命令后，开始正常\n实现原理 tc 实现\n常见问题 ","excerpt":"介绍 可以指定网卡、本地端口、远程端口、目标 IP 包重排。需要特别注意，如果不指定端口、ip 参数，而是整个网卡包重复，切记要添加 \u0026ndash;timeout …","ref":"/docs/binaries/create/network/network-reorder/","title":"网络包重排序实验场景"},{"body":"执行 执行 docker 相关实验场景，必须确保本地能访问 docker server，可通过 tcp 或 socket 方式访问，默认是通过本地 socket 访问，也可通过 \u0026ndash;docker-endpoint 参数指定。\n很重要的一点是，如果执行 CPU 场景，必须指定 chaosblade 安装包，因为需要将安装包拷贝到容器 /opt 目录下执行，使用 \u0026ndash;blade-tar-file 参数指定，例如 --blade-tar-file /home/admin/chaosblade-0.4.0.tar.gz。如果执行网络或者进程场景，无需指定，但这两个场景依赖 chaosblade-tool 镜像，默认是从 registry.cn-hangzhou.aliyuncs.com/chaosblade 仓库下载，也可以通过 --image-repo 参数指定，例如 --image-repo registry-vpc.cn-hangzhou.aliyuncs.com/chaosblade\n案例 实验场景案例请点击各场景查看\n常见问题 Q: {\u0026quot;code\u0026quot;:801,\u0026quot;success\u0026quot;:false,\u0026quot;error\u0026quot;:\u0026quot;Error: No such image: xxx/chaosblade-tool:0.4.0\u0026quot;}\nA: 说明 chaosblade-tool 镜像拉取失败，需要通过 --image-repo 指定正确的镜像仓库地址\n创建 docker 相关的混沌实验，比如杀容器，容器网络延迟、丢包，杀容器里的进程等，不同的场景依赖的参数不同，目前支持以下实验场景：\n","excerpt":"执行 执行 docker 相关实验场景，必须确保本地能访问 docker server，可通过 tcp 或 socket 方式访问，默认是通过本地 socket 访问， …","ref":"/docs/binaries/create/docker/","title":"docker 容器场景"},{"body":"介绍 CodeCache 主要用于存放 native code，其中主要是 JIT 编译后的代码。被 JIT 编译的一般都是“热代码”，简单说就是调用频率比较高的代码，JIT编译后，代码的执行效率会变高，CodeCache 满会导致 JVM 关闭 JIT 编译且不可再开启，那么CodeCache 满会引起系统运行效率降低，导致系统最大负载下降，当系统流量较大时，可表现为 RT 增高、QPS 下降等。\n命令可以简写为 blade c jvm ccf\n 参数 此场景无特有参数，通用参数详见：blade create jvm\n案例 注入 CodeCache 满故障：\nblade c jvm CodeCacheFilling --process tomcat {\u0026#34;code\u0026#34;:200,\u0026#34;success\u0026#34;:true,\u0026#34;result\u0026#34;:\u0026#34;f0e896f38c704894\u0026#34;} 实现原理 由于 CodeCache 主要存放 JIT 编译的结果，所以填充 CodeCache 分为两步，第一步是生成用于触发 JIT 编译的 class，方式是通过动态编译生成大量的 class；第二步是编译后生成的 class 进行实例化和频繁调用（“加热”），直到触发 JIT 编译后进入 CodeCache 区。通过这样方式不停的填充 CodeCache，直到 JIT 编译关闭\n常见问题  由于需要编译和“加热”代码，所以在填充的过程中 CPU 占用率会很高；并且会持续一段时间（测试中，默认大小的情况下，从无占用到填充满约5分钟，实际情况下，CodeCache 都会有一定的使用率，所以时间不会那么长）； 由于“加热”过程中需要实例化大量的 class，会有大量对象一直无法被 GC 回收，有概率导致 Metaspace 满而产生 OOM； 由于无法直接判断 JIT 编译是否关闭，所以只能根据 CodeCache 占用量来判断，但是 JIT 编译关闭时，CodeCache 占用量的阈值并不能精准获取，所以是通过 CodeCache 的增长来判断的，如果 5 秒内 CodeCache 占用量都无变化，即判断 JIT 编译关闭（JIT 编译关闭后，CodeCache 占用量不再变化）； 目前是根据 CodeCache 的默认大小来设计的（生成 class 数量等），即 240M（jdk8 64bit），如果设置更大的 CodeCache（-XX:ReservedCodeCacheSize）的话，持续时间会更长，甚至由于动态产生的 class 数量不够而导致无法填充满； 由于 JIT 编译关闭后不可再手工开启，所以该故障无法直接恢复，需要用户手工重启应用系统来恢复；  ","excerpt":"介绍 CodeCache 主要用于存放 native code，其中主要是 JIT 编译后的代码。被 JIT 编译的一般都是“热代码”，简单说就是调用频率比较高的代码，JIT编译后，代码的执行效率会变 …","ref":"/docs/binaries/create/java/jvm/jvm-codecachefilling/","title":"jvm CodeCacheFilling"},{"body":"","excerpt":"","ref":"/docs/binaries/query/","title":"query 命令"},{"body":"介绍 可以指定网卡、本地端口、远程端口、目标 IP 包重复。需要特别注意，如果不指定端口、ip 参数，而是整个网卡包重复，切记要添加 \u0026ndash;timeout 参数或者 \u0026ndash;exclude-port 参数，前者是指定运行时间，自动停止销毁实验，后者是指定排除掉不受影响的端口，两者都是防止机器无法连接的情况，如果真实发生此问题，重启机器即可恢复。\n本地端口和远程端口之间是或的关系，即这两个端口都会生效，只要指定了本地端口或者远程端口，无需指定需要排除的端口。端口与 IP 之间是与的关系，即指定的 IP:PORT 发生包重复。\n参数 --destination-ip string 目标 IP. 支持通过子网掩码来指定一个网段的IP地址, 例如 192.168.1.0/24. 则 192.168.1.0~192.168.1.255 都生效。你也可以指定固定的 IP，如 192.168.1.1 或者 192.168.1.1/32，也可以通过都号分隔多个参数，例如 192.168.1.1,192.168.2.1。 --exclude-port string 排除掉的端口，默认会忽略掉通信的对端端口，目的是保留通信可用。可以指定多个，使用逗号分隔或者连接符表示范围，例如 22,8000 或者 8000-8010。 这个参数不能与 --local-port 或者 --remote-port 参数一起使用 --exclude-ip string 排除受影响的 IP，支持通过子网掩码来指定一个网段的IP地址, 例如 192.168.1.0/24. 则 192.168.1.0~192.168.1.255 都生效。你也可以指定固定的 IP，如 192.168.1.1 或者 192.168.1.1/32，也可以通过都号分隔多个参数，例如 192.168.1.1,192.168.2.1。 --interface string 网卡设备，例如 eth0 (必要参数) --local-port string 本地端口，一般是本机暴露服务的端口。可以指定多个，使用逗号分隔或者连接符表示范围，例如 80,8000-8080 --offset string 延迟时间上下浮动的值, 单位是毫秒 --remote-port string 远程端口，一般是要访问的外部暴露服务的端口。可以指定多个，使用逗号分隔或者连接符表示范围，例如 80,8000-8080 --percent 包重复百分比，取值是不带%号的正整数 --force 强制覆盖已有的 tc 规则，请务必在明确之前的规则可覆盖的情况下使用 --ignore-peer-port 针对添加 --exclude-port 参数，报 ss 命令找不到的情况下使用，忽略排除端口 --timeout string 设定运行时长，单位是秒，通用参数 案例 # 访问指定的 ip 请求包损坏，百分比 80% blade create network corrupt --percent 80 --destination-ip 180.101.49.12 --interface eth0 ping 180.101.49.12 64 bytes from 180.101.49.12: icmp_seq=64 ttl=50 time=9.94 ms 64 bytes from 180.101.49.12: icmp_seq=65 ttl=50 time=9.73 ms 64 bytes from 180.101.49.12: icmp_seq=65 ttl=50 time=9.74 ms (DUP!) 64 bytes from 180.101.49.12: icmp_seq=66 ttl=50 time=9.77 ms 64 bytes from 180.101.49.12: icmp_seq=66 ttl=50 time=9.80 ms (DUP!) 64 bytes from 180.101.49.12: icmp_seq=67 ttl=50 time=9.70 ms 64 bytes from 180.101.49.12: icmp_seq=67 ttl=50 time=9.71 ms (DUP!) 64 bytes from 180.101.49.12: icmp_seq=68 ttl=50 time=11.0 ms 64 bytes from 180.101.49.12: icmp_seq=68 ttl=50 time=11.1 ms (DUP!) 64 bytes from 180.101.49.12: icmp_seq=69 ttl=50 time=9.78 ms 64 bytes from 180.101.49.12: icmp_seq=69 ttl=50 time=9.78 ms (DUP!) 64 bytes from 180.101.49.12: icmp_seq=70 ttl=50 time=9.70 ms 64 bytes from 180.101.49.12: icmp_seq=70 ttl=50 time=9.70 ms (DUP!) 64 bytes from 180.101.49.12: icmp_seq=71 ttl=50 time=9.71 ms 64 bytes from 180.101.49.12: icmp_seq=71 ttl=50 time=9.71 ms (DUP!) 64 bytes from 180.101.49.12: icmp_seq=72 ttl=50 time=9.73 ms 64 bytes from 180.101.49.12: icmp_seq=72 ttl=50 time=9.74 ms (DUP!) 64 bytes from 180.101.49.12: icmp_seq=73 ttl=50 time=9.69 ms 64 bytes from 180.101.49.12: icmp_seq=73 ttl=50 time=9.73 ms (DUP!) 64 bytes from 180.101.49.12: icmp_seq=74 ttl=50 time=9.73 ms 64 bytes from 180.101.49.12: icmp_seq=74 ttl=50 time=9.73 ms (DUP!) 64 bytes from 180.101.49.12: icmp_seq=75 ttl=50 time=9.68 ms 64 bytes from 180.101.49.12: icmp_seq=75 ttl=50 time=9.68 ms (DUP!) 64 bytes from 180.101.49.12: icmp_seq=76 ttl=50 time=10.0 ms 64 bytes from 180.101.49.12: icmp_seq=76 ttl=50 time=10.0 ms (DUP!) 64 bytes from 180.101.49.12: icmp_seq=77 ttl=50 time=9.68 ms 64 bytes from 180.101.49.12: icmp_seq=77 ttl=50 time=9.80 ms (DUP!) 64 bytes from 180.101.49.12: icmp_seq=78 ttl=50 time=9.70 ms 64 bytes from 180.101.49.12: icmp_seq=79 ttl=50 time=9.70 ms 64 bytes from 180.101.49.12: icmp_seq=80 ttl=50 time=9.74 ms 可以看出执行命令后开始出现包重复的情况，执行恢复命令后，开始正常\n实现原理 tc 实现\n常见问题 ","excerpt":"介绍 可以指定网卡、本地端口、远程端口、目标 IP 包重复。需要特别注意，如果不指定端口、ip 参数，而是整个网卡包重复，切记要添加 \u0026ndash;timeout …","ref":"/docs/binaries/create/network/network-duplicate/","title":"网络包重复实验场景"},{"body":"","excerpt":"","ref":"/docs/binaries/create/script/","title":"脚本函数执行"},{"body":"介绍 创建 kubernetes 相关的实验场景，除了使用 blade 命令创建场景外，还可以将实验使用 yaml 文件描述，使用 kubectl 命令执行。\n更详细 Kubernetes 平台实验场景介绍见：Kubernetes 平台场景\n部署 执行 Kubernetes 实验场景，需要提前部署 ChaosBlade Operator，Helm 安装包下载地址：https://github.com/chaosblade-io/chaosblade-operator/releases 。\n部署方式见安装部署。\n创建实验 执行方式有两种，一是通过配置 yaml 方式，使用 kubectl 执行，另一种是直接使用 chaosblade 包中的 blade 命令执行。\n配置 yaml 使用 kubectl 执行方式见：Kubernetes 平台场景\nblade 命令执行方式 下载 chaosblade 工具包，下载地址：https://github.com/chaosblade-io/chaosblade/releases ，解压即可使用。还是上述例子，使用 blade 命令执行如下：\nblade create k8s node-cpu fullload --names cn-hangzhou.192.168.0.205 --cpu-percent 80 --kubeconfig ~/.kube/config 使用 blade 命令执行，如果执行失败，会返回详细的错误信息；如果执行成功，会返回实验的 UID，使用查询命令可以查询详细的实验结果：\nblade query k8s create \u0026lt;UID\u0026gt; 销毁实验 可以通过以下三种方式停止实验：\n根据实验资源名停止 比如上述 cpu-load 场景，可以执行以下命令停止实验\nkubectl delete chaosblade cpu-load 通过 yaml 配置文件停止 指定上述创建好的 yaml 文件进行删除，命令如下：\nkubectl delete -f chaosblade_cpu_load.yaml 通过 blade 命令停止 此方式仅限使用 blade 创建的实验，使用以下命令停止：\nblade destroy \u0026lt;UID\u0026gt; \u0026lt;UID\u0026gt; 是执行 blade create 命令返回的结果，如果忘记，可使用 blade status --type create 命令查询。\n常见问题 Q: validation failure list:spec.experiments.matchers.value in body must be of type array: \u0026quot;string\u0026quot;\nA: 所有 matchers 中 value 参数必须是字符串数组，例如：\n- name:namesvalue:[\u0026#34;cn-hangzhou.192.168.0.205\u0026#34;]或者\n- name:namesvalue:- \u0026#34;cn-hangzhou.192.168.0.205\u0026#34;Q：{\u0026quot;code\u0026quot;:800,\u0026quot;success\u0026quot;:false,\u0026quot;error\u0026quot;:\u0026quot;unable to load in-cluster configuration, KUBERNETES_SERVICE_HOST and KUBERNETES_SERVICE_PORT must be defined\u0026quot;,\u0026quot;result\u0026quot;:{\u0026quot;uid\u0026quot;:\u0026quot;08dec77bd45c8e55\u0026quot;,\u0026quot;success\u0026quot;:false,\u0026quot;error\u0026quot;:\u0026quot;unable to load in-cluster configuration, KUBERNETES_SERVICE_HOST and KUBERNETES_SERVICE_PORT must be defined\u0026quot;,\u0026quot;statuses\u0026quot;:[{\u0026quot;id\u0026quot;:\u0026quot;08dec77bd45c8e55\u0026quot;,\u0026quot;state\u0026quot;:\u0026quot;Error\u0026quot;,\u0026quot;kind\u0026quot;:\u0026quot;\u0026quot;,\u0026quot;error\u0026quot;:\u0026quot;unable to load in-cluster configuration, KUBERNETES_SERVICE_HOST and KUBERNETES_SERVICE_PORT must be defined\u0026quot;,\u0026quot;success\u0026quot;:false}]}}\nA：没有指定 --kubeconfig 文件路径\nQ: {\u0026quot;code\u0026quot;:504,\u0026quot;success\u0026quot;:false,\u0026quot;error\u0026quot;:\u0026quot;unexpected status, the real value is Error\u0026quot;,\u0026quot;result\u0026quot;:{\u0026quot;uid\u0026quot;:\u0026quot;78abb71fb0587c2e\u0026quot;,\u0026quot;success\u0026quot;:false,\u0026quot;error\u0026quot;:\u0026quot;unexpected status, the real value is Error\u0026quot;,\u0026quot;statuses\u0026quot;:[{\u0026quot;state\u0026quot;:\u0026quot;Error\u0026quot;,\u0026quot;kind\u0026quot;:\u0026quot;\u0026quot;,\u0026quot;error\u0026quot;:\u0026quot;must specify one flag in evict-count,evict-percent,labels,names\u0026quot;,\u0026quot;success\u0026quot;:false}]}}\nA: 缺少必要参数\n","excerpt":"介绍 创建 kubernetes 相关的实验场景，除了使用 blade 命令创建场景外，还可以将实验使用 yaml 文件描述，使用 kubectl 命令执行。\n更详细 Kubernetes 平台实验场 …","ref":"/docs/binaries/create/k8s/","title":"kubernetes 实验场景"},{"body":"介绍 打印 blade 工具版本信息。\nversion 可以简写为 v，即 blade version 可以简写为 blade v。\n参数 -h, --help 查看 create 命令帮助 可使用的父命令参数 -d, --debug 设置 DEBUG 执行模式 案例 # 查看 blade 工具版本信息 blade version version: 0.4.0 # 版本 env: Darwin Kernel Version 19.0.0: Wed Sep 25 20:18:50 PDT 2019; root:xnu-6153.11.26~2/RELEASE_X86_64 x86_64 # 环境信息 build-time: Thu Dec 5 14:29:44 CST 2019 # 构建时间 ","excerpt":"介绍 打印 blade 工具版本信息。\nversion 可以简写为 v，即 blade version 可以简写为 blade v。\n参数 -h, --help 查看 create 命令帮助 可使用的 …","ref":"/docs/binaries/version/","title":"version 命令"},{"body":" 命令可以简写为 blade c jvm tce\n 参数 以下是此场景特有参数，通用参数详见：blade create jvm\n--effect-count string 影响的请求条数 --effect-percent string 影响的请求百分比 --exception string 异常类，带全包名，必须继承 java.lang.Exception 或 java.lang.Exception 本身 --exception-message string 指定异常类信息，默认值是 chaosblade-mock-exception 案例 类名：com.example.controller.DubboController，业务代码如下：\nprivate String sayHello(String name) throws BeansException { demoService = (DemoService)SpringContextUtil.getBean(\u0026#34;demoService\u0026#34;); StringBuilder result = new StringBuilder(); result.append(demoService.sayHello(name)); return result.toString(); } 指定以上方法抛出 java.lang.Exception 异常，影响两条请求，命令如下：\nblade c jvm throwCustomException --exception java.lang.Exception --classname com.example.controller.DubboController --methodname sayHello --process tomcat --effect-count 2 {\u0026#34;code\u0026#34;:200,\u0026#34;success\u0026#34;:true,\u0026#34;result\u0026#34;:\u0026#34;3abbe6fe97d6bc75\u0026#34;} 验证结果：\n注入前：\n注入后：\n第三次请求后恢复正常：\n停止实验：\nblade d 3abbe6fe97d6bc75 常见问题 Q: java.lang.Throwable not assign from java.lang.Exception\nA: 配置 \u0026ndash;exception 参数值 java.lang.Throwable，其不是 java.lang.Exception 的子类\n","excerpt":"命令可以简写为 blade c jvm tce\n 参数 以下是此场景特有参数，通用参数详见：blade create jvm\n--effect-count string …","ref":"/docs/binaries/create/java/jvm/jvm-throwcustomexception/","title":"指定类方法抛自定义异常"},{"body":"介绍 本地端口占用，验证端口已被占用的情况下，使用此端口的业务容错能力\n参数 --port string 指定被占用的端口，（必填项） --force 强制占用此端口，会将已使用此端口的进程杀掉 --timeout string 设定运行时长，单位是秒，通用参数 案例 # 指定 8080 端口占用 blade c network occupy --port 8080 --force # 命令执行前 netstat -tanp | grep 8080 tcp 0 0 0.0.0.0:8080 0.0.0.0:* LISTEN 19562/java # 命令执行后 netstat -tanp | grep 8080 tcp6 0 0 :::8080 :::* LISTEN 20041/chaos_occupyn 实现原理 指定端口启动 server 实现\n常见问题 Q: {\u0026quot;code\u0026quot;:604,\u0026quot;success\u0026quot;:false,\u0026quot;error\u0026quot;:\u0026quot;Error: listen tcp :8080: bind: address already in use exit status 1\u0026quot;}\nA：指定的端口已被占用，可以添加 --force 参数，强制杀掉使用此端口的进程\n","excerpt":"介绍 本地端口占用，验证端口已被占用的情况下，使用此端口的业务容错能力\n参数 --port string 指定被占用的端口，（必填项） --force 强制占用此端口， …","ref":"/docs/binaries/create/network/network-occupy/","title":"网络本地端口占用"},{"body":"","excerpt":"","ref":"/docs/binaries/create/java/","title":"Java 实验场景"},{"body":"后台启动 blade，会暴露出 web 服务，上层可通过 http 调用\n介绍 在 server 模式下，blade 程序会对外暴露 web 服务，上层可通过 http 请求调用，请求格式是 chaosblade?cmd= 具体命令，例如执行 CPU 满载，则请求是 chaosblade?cmd=create%20cpu%20fullload\n命令 start 启动 server 模式, 暴露 web 服务 stop 停止 server 模式, 关闭 web 服务 start 命令参数 -p, --port string 服务端口号，默认是 9526 案例 # 启动 server 模式，服务端口是 8080 blade server start --port 8080 success, listening on 8080 # 触发 CPU 负载 50% 场景 curl \u0026#34;http://xxx.xxx.xxx.xxx:8080/chaosblade?cmd=create%20cpu%20load%20--cpu-percent%2050\u0026#34; {\u0026#34;code\u0026#34;:200,\u0026#34;success\u0026#34;:true,\u0026#34;result\u0026#34;:\u0026#34;e08a64a9af02c393\u0026#34;} # 销毁实验场景 curl \u0026#34;http://xxx.xxx.xxx.xxx:8080/chaosblade?cmd=destroy%20e08a64a9af02c393\u0026#34; # 停止 blade server blade server stop {\u0026#34;code\u0026#34;:200,\u0026#34;success\u0026#34;:true,\u0026#34;result\u0026#34;:\u0026#34;pid is 12619\u0026#34;} 实现原理 常见问题 Q: {\u0026quot;code\u0026quot;:605,\u0026quot;success\u0026quot;:false,\u0026quot;error\u0026quot;:\u0026quot;the chaosblade has been started. If you want to stop it, you can execute blade server stop command\u0026quot;}\nA：服务已经启动\nQ: {\u0026quot;code\u0026quot;:500,\u0026quot;success\u0026quot;:false,\u0026quot;error\u0026quot;:\u0026quot;time=\\\u0026quot;2019-09-25T11:36:28.321495762+08:00\\\u0026quot; level=error msg=\\\u0026quot;start blade server error, listen tcp :8080: bind: address already in use\\\u0026quot;\\n\u0026quot;}\nA：端口已被占用\n","excerpt":"后台启动 blade，会暴露出 web 服务，上层可通过 http 调用\n介绍 在 server 模式下，blade 程序会对外暴露 web 服务，上层可通过 http 请求调用， …","ref":"/docs/binaries/server/","title":"server 命令"},{"body":"","excerpt":"","ref":"/blog/cloudnative/","title":"云原生"},{"body":"Chaosblade Operator：在云原生场景下，将 Kubernetes 设计理解与混沌实验模型相结合标准化实现方案 chaosblade-operator 项目是针对 Kubernetes 平台所实现的混沌实验注入工具，遵循上述混沌实验模型规范化实验场景，把实验定义为 Kubernetes CRD 资源，将实验模型中的四部分映射为 Kubernetes 资源属性，很友好的将混沌实验模型与 Kubernetes 声明式设计结合在一起，依靠混沌实验模型便捷开发场景的同时，又可以很好的结合 Kubernetes 设计理念，通过 kubectl 或者编写代码直接调用 Kubernetes API 来创建、更新、删除混沌实验，而且资源状态可以非常清晰的表示实验的执行状态，标准化实现 Kubernetes 故障注入。除了使用上述方式执行实验外，还可以使用 chaosblade cli 方式非常方便的执行 kubernetes 实验场景，查询实验状态等。 遵循混沌实验模型实现的 chaosblade operator 除上述优势之外，还可以实现基础资源、应用服务、Docker 容器等场景复用，大大方便了 Kubernetes 场景的扩展，所以在符合 Kubernetes 标准化实现场景方式之上，结合混沌实验模型可以更有效、更清晰、更方便的实现、使用混沌实验场景。 下面通过一个具体的案例来说明 chaosblade-operator 的使用：对 cn-hangzhou.192.168.0.205 节点本地端口 40690 访问模拟 60% 的网络丢包。 使用 yaml 配置方式，使用 kubectl 来执行实验\napiVersion: chaosblade.io/v1alpha1 kind: ChaosBlade metadata: name: loss-node-network-by-names spec: experiments: - scope: node target: network action: loss desc: \u0026quot;node network loss\u0026quot; matchers: - name: names value: [\u0026quot;cn-hangzhou.192.168.0.205\u0026quot;] - name: percent value: [\u0026quot;60\u0026quot;] - name: interface value: [\u0026quot;eth0\u0026quot;] - name: local-port value: [\u0026quot;40690\u0026quot;] 执行实验：\nkubectl apply -f loss-node-network-by-names.yaml 查询实验状态，返回信息如下（省略了 spec 等内容）：\n~ » kubectl get blade loss-node-network-by-names -o json { \u0026quot;apiVersion\u0026quot;: \u0026quot;chaosblade.io/v1alpha1\u0026quot;, \u0026quot;kind\u0026quot;: \u0026quot;ChaosBlade\u0026quot;, \u0026quot;metadata\u0026quot;: { \u0026quot;creationTimestamp\u0026quot;: \u0026quot;2019-11-04T09:56:36Z\u0026quot;, \u0026quot;finalizers\u0026quot;: [ \u0026quot;finalizer.chaosblade.io\u0026quot; ], \u0026quot;generation\u0026quot;: 1, \u0026quot;name\u0026quot;: \u0026quot;loss-node-network-by-names\u0026quot;, \u0026quot;resourceVersion\u0026quot;: \u0026quot;9262302\u0026quot;, \u0026quot;selfLink\u0026quot;: \u0026quot;/apis/chaosblade.io/v1alpha1/chaosblades/loss-node-network-by-names\u0026quot;, \u0026quot;uid\u0026quot;: \u0026quot;63a926dd-fee9-11e9-b3be-00163e136d88\u0026quot; }, \u0026quot;status\u0026quot;: { \u0026quot;expStatuses\u0026quot;: [ { \u0026quot;action\u0026quot;: \u0026quot;loss\u0026quot;, \u0026quot;resStatuses\u0026quot;: [ { \u0026quot;id\u0026quot;: \u0026quot;057acaa47ae69363\u0026quot;, \u0026quot;kind\u0026quot;: \u0026quot;node\u0026quot;, \u0026quot;name\u0026quot;: \u0026quot;cn-hangzhou.192.168.0.205\u0026quot;, \u0026quot;nodeName\u0026quot;: \u0026quot;cn-hangzhou.192.168.0.205\u0026quot;, \u0026quot;state\u0026quot;: \u0026quot;Success\u0026quot;, \u0026quot;success\u0026quot;: true, \u0026quot;uid\u0026quot;: \u0026quot;e179b30d-df77-11e9-b3be-00163e136d88\u0026quot; } ], \u0026quot;scope\u0026quot;: \u0026quot;node\u0026quot;, \u0026quot;state\u0026quot;: \u0026quot;Success\u0026quot;, \u0026quot;success\u0026quot;: true, \u0026quot;target\u0026quot;: \u0026quot;network\u0026quot; } ], \u0026quot;phase\u0026quot;: \u0026quot;Running\u0026quot; } } 通过以上内容可以很清晰的看出混沌实验的运行状态，执行以下命令停止实验：\nkubectl delete -f loss-node-network-by-names.yaml 或者直接删除此 blade 资源\nkubectl delete blade loss-node-network-by-names 还可以编辑 yaml 文件，更新实验内容执行，chaosblade operator 会完成实验的更新操作。\n使用 chaosblade cli 的 blade 命令执行\nblade create k8s node-network loss --percent 60 --interface eth0 --local-port 40690 --kubeconfig config --names cn-hangzhou.192.168.0.205 如果执行失败，会返回详细的错误信息；如果执行成功，会返回实验的 UID：\n{\u0026quot;code\u0026quot;:200,\u0026quot;success\u0026quot;:true,\u0026quot;result\u0026quot;:\u0026quot;e647064f5f20953c\u0026quot;} 可通过以下命令查询实验状态：\nblade query k8s create e647064f5f20953c --kubeconfig config { \u0026quot;code\u0026quot;: 200, \u0026quot;success\u0026quot;: true, \u0026quot;result\u0026quot;: { \u0026quot;uid\u0026quot;: \u0026quot;e647064f5f20953c\u0026quot;, \u0026quot;success\u0026quot;: true, \u0026quot;error\u0026quot;: \u0026quot;\u0026quot;, \u0026quot;statuses\u0026quot;: [ { \u0026quot;id\u0026quot;: \u0026quot;fa471a6285ec45f5\u0026quot;, \u0026quot;uid\u0026quot;: \u0026quot;e179b30d-df77-11e9-b3be-00163e136d88\u0026quot;, \u0026quot;name\u0026quot;: \u0026quot;cn-hangzhou.192.168.0.205\u0026quot;, \u0026quot;state\u0026quot;: \u0026quot;Success\u0026quot;, \u0026quot;kind\u0026quot;: \u0026quot;node\u0026quot;, \u0026quot;success\u0026quot;: true, \u0026quot;nodeName\u0026quot;: \u0026quot;cn-hangzhou.192.168.0.205\u0026quot; } ] } } 销毁实验：\nblade destroy e647064f5f20953c 除了上述两种方式调用外，还可以使用 kubernetes client-go 方式执行，具体可参考：executor.go 代码实现。\n通过上述介绍，可以看出在设计 ChaosBlade 项目初期就考虑了云原生实验场景，将混沌实验模型与 Kubernetes 设计理念友好的结合在一起，不仅可以遵循 Kubernetes 标准化实现，还可以复用其他领域场景和 chaosblade cli 调用方式。\n详细的中文使用文档：https://chaosblade-io.gitbook.io/chaosblade-help-zh-cn/blade-create-k8s\n","excerpt":"Chaosblade Operator：在云原生场景下，将 Kubernetes 设计理解与混沌实验模型相结合标准化实现方案 chaosblade-operator 项目是针对 Kubernetes  …","ref":"/blog/2020/01/15/chaosblade-operator%E5%9C%A8%E4%BA%91%E5%8E%9F%E7%94%9F%E5%9C%BA%E6%99%AF%E4%B8%8B%E5%B0%86-kubernetes-%E8%AE%BE%E8%AE%A1%E7%90%86%E8%A7%A3%E4%B8%8E%E6%B7%B7%E6%B2%8C%E5%AE%9E%E9%AA%8C%E6%A8%A1%E5%9E%8B%E7%9B%B8%E7%BB%93%E5%90%88%E6%A0%87%E5%87%86%E5%8C%96%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%A1%88/","title":"Chaosblade Operator：在云原生场景下，将 Kubernetes 设计理解与混沌实验模型相结合标准化实现方案"},{"body":" 文章地址：https://github.com/StabilityMan/StabilityGuide 作者：肖长军（穹谷，@xcaspar）\n 在分布式系统架构下，服务间的依赖日益复杂，很难评估单个服务故障对整个系统的影响，并且请求链路长，监控告警的不完善导致发现问题、定位问题难度增大，同时业务和技术迭代快，如何持续保障系统的稳定性和高可用性受到很大的挑战。我们知道发生故障的那一刻不是由你来选择的，而是那一刻来选择你，你能做的就是为之做好准备。所以构建稳定性系统很重要的一环是混沌工程，在可控范围或环境下，通过故障注入，来持续提升系统的稳定性和高可用能力。\n本文会着重介绍什么是混沌工程，为什么需要混沌工程以及混沌工程相关工具与实践。如有遗漏或错误，欢迎补充指正。\n目录  什么是混沌工程 为什么需要混沌工程 混沌工程实施原则 混沌工程实施步骤 推荐工具\u0026amp;产品 混沌工程实践案例 相关文章\u0026amp;交流群 加入我们  什么是混沌工程 混沌工程是在 混沌工程理论 一文中提出，但在 2010 年 Netflix 从物理机基础设施迁移到 AWS 过程中，为保证 EC2 实例故障不会对业务造成影响，其团队开发出了杀 EC2 实例的工具，这也是混沌工程的雏形。在 2015 年社区发布《混沌工程理论》一文后，混沌工程开始快速发展。\n混沌工程是在分布式系统上进行实验的学科，旨在提升系统容错性，建立系统抵御生产环境中发生不可预知问题的信心。”打不倒我的必使我强大“，尼采的这句话很好了诠释了混沌工程反脆弱的思想。\n为什么需要混沌工程 分布式系统日益复杂，而且在系统逐渐云化的背景下，系统的稳定性受到很大的挑战。这里从四个角色来说明混沌工程的重要性。\n 对于架构师来说，可以验证系统架构的容错能力，比如验证现在提倡的面向失败设计的系统； 对于开发和运维，可以提高故障的应急效率，实现故障告警、定位、恢复的有效和高效性。 对于测试来说，可以弥补传统测试方法留下的空白，之前的测试方法基本上是从用户的角度去做，而混沌工程是从系统的角度进行测试，降低故障复发率。 对于产品和设计，通过混沌事件查看产品的表现，提升客户使用体验。所以说混沌工程面向的不仅仅是开发、测试，拥有最好的客户体验是每个人的目标 所以实施混沌工程，可以提早发现生产环境上的问题，并且可以以战养战，提升故障应急效率和可以使用体验，逐渐建设高可用的韧性系统。  混沌工程实施原则  第一条：”建立一个围绕稳定状态行为的假说“，其包含两个含义，一个是定义能直接反应业务服务的监控指标，需要注意的是这里的监控指标并不是系统资源指标，比如CPU、内存等，这里的监控指标是能直接衡量系统服务质量的业务监控。举个例子，一个调用延迟故障，请求的 RT 会变长，对上层交易量造成下跌的影响，那么这里交易量就可以作为一个监控指标。这条原则的另一个含义是故障触发时，对系统行为作出假设以及监控指标的预期变化。 第二条指模拟生产环境中真实的或有理论依据的故障场景，比如依赖的服务调用延迟、超时、异常等。 第三条建议在生产环境中运行实验，但也不是说必须在生产环境中执行，只是实验环境越真实，混沌工程越有价值，但如果知道系统在某个故障场景下不具备容灾能力，不可以执行此混沌实验，避免资损发生。 第四条，持续的执行才能持续的降低故障复发率和提前发现故障，所以需要持续的自动化运行试验。 最后一个，混沌工程很重要的一点是控制爆炸半径，也就是试验影响面，防止预期外的资损发生，可以通过环境隔离或者故障注入工具提供的配置粒度来控制。  混沌工程实施步骤  制订混沌实验计划 定义系统稳态指标 做出系统容错行为假设 执行混沌实验 检查系统稳态指标 记录\u0026amp;恢复混沌实验 修复发现的问题 自动化持续进行验证  推荐工具产品 大家可以从工具的场景丰富度、类型、易用性等方面来选择一款合适的工具，awesome-chaos-engineering Github 项目收纳了一些开源的混沌工程工具，在 CNCF Landscape 中混沌工程作为单独的一个领域存在，并且收纳了一些主流的工具，包含阿里巴巴开源的 ChaosBlade 工具和 AHAS 阿里云产品。 下文重点介绍 ChaosBlade 及其相关实践。\nChaosBlade ChaosBlade 中文名混沌之刃，是一款混沌实验实施工具，支持丰富的实验场景，比如应用、容器、基础资源等。工具使用简单，扩展方便，其遵循社区提出的混沌实验模型。Github 地址：https://github.com/chaosblade-io/chaosblade\n功能和特点 场景丰富度高 ChaosBlade 支持的混沌实验场景不仅覆盖基础资源，如 CPU 满载、磁盘 IO 高、网络延迟等，还包括运行在 JVM 上的应用实验场景，如 Dubbo 调用超时和调用异常、指定方法延迟或抛异常以及返回特定值等，同时涉及容器相关的实验，如杀容器、杀 Pod。后续会持续的增加实验场景。\n使用简洁，易于理解 ChaosBlade 通过 CLI 方式执行，具有友好的命令提示功能，可以简单快速的上手使用。命令的书写遵循阿里巴巴集团内多年故障测试和演练实践抽象出的故障注入模型，层次清晰，易于阅读和理解，降低了混沌工程实施的门槛。\n动态加载，无侵入 ChaosBlade采用动态故障注入的方式，执行混沌实验时用户系统不需要做任何系统改造或发布，开箱即用。\n场景扩展方便 所有的 ChaosBlade 实验执行器同样遵循上述提到的故障注入模型，使实验场景模型统一，便于开发和维护。模型本身通俗易懂，学习成本低，可以依据模型方便快捷的扩展更多的混沌实验场景。\n使用方式 在 ChaosBlade Release 页面下载最新版本的包，解压即用。如创建一个 CPU 满载实验，命令为：\nblade create cpu fullload 具体使用方式可详见：ChaosBlade 新手指南\n中文使用文档：帮助文档\n混沌实验模型 该模型分四次，层层递进，很清晰的表达出对什么组件做实验，实验范围是什么，实验触发的匹配规则有哪些，执行什么实验。该模型简洁、通用，语言领域无关、易于实现。阿里集团内的 C++、NodeJS、Dart 应用以及容器平台的实验场景都基于此模型实现。此模型具有很重要的意义，依据此模型可以更精准的描述、更好的理解、更方便沉淀实验场景以及发掘更多的场景。依据此模型实现的工具更加规范、简洁。实验模型介绍可详见：混沌实验模型介绍。\n混沌工程实践案例 此拓扑图来自于阿里云 AHAS 产品架构感知功能，可自动感知架构拓扑，并且可以展示进程、网络、节点等数据。这个分布式服务 Demo 分三级调用，consumer 调用 provider，provider 调用 base，同时 provider 还调用 mk-demo 数据库，provider 和 base 服务具有两个实例，在 AHAS 架构拓扑图上，我们点击一个实例节点，可以到非常清晰的调用关系。我们后面结合这个 Demo 去讲解实践。\n验证监控告警 案例一，我们验证系统的监控告警性有效性。按照前面提到的混沌工程实施步骤，那么这个案例执行的实验场景是数据库调用延迟，我们先定义监控指标：慢 SQL 数和告警信息，做出期望假设：慢 SQL 数增加，钉钉群收到慢 SQL 告警。接下来执行实验。我们直接使用 ChaosBlade 工具执行，可以看下左下角，我们对 demo-provider 注入调用 mysql 查询时，若数据库是 demo 且表名是 d_discount，则对 50% 的查询操作延迟 600 毫秒。我们使用阿里云产品 ARMS 做监控告警。大家可以看到，当执行完混沌实验后，很快钉钉群里就收到了报警。所以我们对比下之前定义的监控指标，是符合预期的。但需要注意的是这次符合预期并不代表以后也符合，所以需要通过混沌工程持续性的验证。出现慢 SQL，可通过 ARMS 的 链路追踪 来排查定位，可以很清楚的看出哪条语句执行慢。\n案例二 前面讲了一个符合预期的案例，我们再来看一个不符合预期的。此案例是验证系统异常实例隔离的能力，我们的 Demo 中 consumer 调用 provider 服务，provider 服务具有两个实例，我们对其中一个注入延迟故障，监控指标是 consumer 的 QPS，稳态在 510 左右。我们做的容错假设是系统会自动隔离或下线出问题的服务实例，防止请求路由的此实例，所有 QPS 会有短暂的下跌，但很快会恢复。这个案例，我们使用阿里云 AHAS 混沌实验平台来执行，我们对 demo-provider-1 注入延迟故障，基于此平台可以很方便的执行混沌实验。执行混沌实验后，QPS 下跌到 40 左右，很长时间没有自动恢复，所以不符合预期，我们通过人工的方式对该异常的实例做下线处理，很快就看到，consumer 的 QPS 恢复正常。所以我们通过混沌工程发现了系统问题，我们后面需要做就是记录此问题，并且推动修复，后续做持续性的验证。\n相关文章交流群  ChaosBlade 钉钉讨论群号：23177705 相关资料：awesome-chaosblade 项目 后续的分享和讨论都会在上述钉钉群中进行，欢迎加入。我们还会不定期的给 ChaosBlade 社区贡献者发放纪念品，欢迎加入到 ChaosBlade 社区中，加入方式：star、issue、pr 等均可。  加入我们 【稳定大于一切】打造国内稳定性领域知识库，让无法解决的问题少一点点，让世界的确定性多一点点。\n GitHub 地址 钉钉群号：23179349 如果阅读本文有所收获，欢迎分享给身边的朋友，期待更多同学的加入！  ","excerpt":"文章地址：https://github.com/StabilityMan/StabilityGuide 作者：肖长军（穹谷，@xcaspar）\n 在分布式系统架构下，服务间的依赖日益复杂，很难评估单个 …","ref":"/blog/2019/12/10/%E6%B7%B7%E6%B2%8C%E5%B7%A5%E7%A8%8B%E4%BB%8B%E7%BB%8D%E4%B8%8E%E5%AE%9E%E8%B7%B5/","title":"混沌工程介绍与实践"},{"body":"如何获取最新版本 chaosblade 每次发布，相关的 changelog 和新版的包都会同步到 RELEASE ，可在此地址下载。\nWindows 平台是否有支持计划 暂无支持计划，不过欢迎大家提相关支持的 issue，社区会根据大家的需求来决定是否支持。\n执行 blade 命令报错： exec format error 或 cannot execute binary file 是由于 chaosblade 包和运行的平台不兼容造成的，请提 ISSUE来告知我们，issue 中标注下载的 chaosblade 包版本和操作系统版本信息。\n","excerpt":"如何获取最新版本 chaosblade 每次发布，相关的 changelog 和新版的包都会同步到 RELEASE ，可在此地址下载。\nWindows 平台是否有支持计划 暂无支持计划，不过欢迎大家提 …","ref":"/faq/","title":"FAQ"},{"body":"","excerpt":"","ref":"/try/","title":"互动教程"},{"body":"","excerpt":"","ref":"/blog/","title":"博客"},{"body":" 项目的成长离不开社区的支持，文档是社区发展的基石，将你的经验沉淀成文档传承给后来者，是一件多么令人愉快的工作。 开源世界，任何帮助都是贡献。 当然你也可以参与代码开发中来，chaosblade-io 组织下的项目总会有一个 issue 适合你。 社区会不定期的给贡献者发放周边纪念物以示感谢。  以下是 ChaosBlade 贡献指南。\n","excerpt":"项目的成长离不开社区的支持，文档是社区发展的基石，将你的经验沉淀成文档传承给后来者，是一件多么令人愉快的工作。 开源世界，任何帮助都是贡献。 当然你也可以参与代码开发中来，chaosblade-io  …","ref":"/contributing/","title":"贡献指南"}]